 A GLANCE The Indira Gandhi National Open University IGNOU established by an Act of Parliament in provides seamless education to the people of India transcending the barriers of place age caste pace creed and religion The objectives of the University are Democratizing higher education by taking it to the doorsteps of the learners Providing access to high quality education to all irrespective of age region religion and gender Offering need based academic programmes having professional and vocational orientation Promotion and development of open and distance learning system and Setting and maintaining standards in distance education in the country The special features of IGNOU can be listed thus International jurisdiction Flexible admission rules Continuous upgrade of information and communication technologies Nationwide student support services network Cost effective programmes Modular approach to programmes and Resource sharing collaboration and networking with Conventional Universities Open Universities and Educational Institutions Organizations Some notable facts about IGNOU are as under Emergence of IGNOU as the largest Open University system in the world Student enrolment touching million mark Pan India network of learner support centres Statutory declaration of Term End Exam results within days Academic programmes approaching Recognition as a Centre of Excellence in Distance Education by the Commonwealth of Learning Award of Excellence for Distance Education Materials by the Commonwealth of Learning IGNOU working as the nodal agency for round the clock Educational Channels UNESCO declaring IGNOU as the largest institution of higher learning in the world in These channels and regular transmissions are done from the studio at Electronic Media Production Centre IGNOU and Research Unit IGNOU Handbook Prospectus PhD MPhil RESEARCH POLICY Research is an academic institution s most lasting contribution to society Research activities are normally composed of two main aspects the production of theoretical knowledge and an integral experiential encounter with subjects constituting the society Indeed the body of published material built up by hundreds of researcher writers and creation of a massive data base from which to retrieve information regularly and which is constantly augmented corrected and revised is a natural corollary of research activities This body of published material and the data base constitute the research canon that is central to the functioning of a reputed academic institution like IGNOU and that forms a material expression of its scholarship In about twenty years since its inception IGNOU s Research Programme has shifted gear from the initial focus on distance education and its methodologies and practices to vital contributions to both theoretical and empirical research in various academic disciplines and interdisciplinary areas This shift has been smooth without any major impediment and has yielded the desired objective of the creation of a viable research canon The core of our research endeavour is harnessed to the creation and continual expansion of this research canon A principal objective of IGNOU s Research Programme has been to maintain a strong focus on the flow of theoretical ideas and to connect it with the empirical works of subject oriented researches in sciences social sciences humanities management technology and other disciplines offered by the University as areas of probe and investigation from time to time There has to be a conjunctive mix of theoretical ideas and extended probes into concrete social situations It is now commonly agreed that the object of the subject discipline oriented research is to delineate a methodology of investigation that guarantees the discovery of truth and to prescribe that methodology as canonical imperatives which practicing researchers are obliged to follow Our research programme has indeed had great practical import studying the philosophy of research and training into research methods have become important ingredients of our research programme RESEARCH DEGREE PROGRAMMES General Eligibility Criteria and Selection Procedure A candidate is eligible for Admission and Registration for the MPhil PhD programme provided he she has qualified a For the award of Master s Degree of any recognized University other qualification recognized as equivalent thereto in such fields of study as are notified for the purpose from time to time by the University The minimum qualifying marks are at Post Graduation level in case of reserved categories and b In the Entrance Examination conducted by the University at the national level on the pattern of UGC CSIR Research Unit IGNOUHandbook Prospectus PhD MPhil However candidates holding MPhil degree or those candidates who have cleared JEST of DAE or UGC NET or GATE of IIT or those having at least five years of related Teaching Practical Industry Professional experience as validated by the respective Disciplines may be exempted from appearing in the Entrance Examination N B Additional eligibility conditions have been prescribed by individual Disciplines Candidates are advised to refer these details in the Table given at the end of the Prospectus and ensure that they meet the desired condition s Candidates who are employees of IGNOU shall have completed at least two year service in the University on the date they submit the Application for admission Programme Fee The PhD Programme Fee is Rs per annum for years MPhil candidates are to pay one time fee of Rs which is inclusive of the Course Fee Individual Disciplines may assign course work for PhD candidates for which additional fee may be charged The fee as stated above is subject to revision as decided by the University from time to time Duration The maximum durations of the PhD Programme and the MPhil programme are years and years respectively Reservation IGNOU follows the provisions of the Government of India Policy on Reservation for admission to its Research Degree Programmes FORTY STEPS TO RESEARCH DEGREE In this section the important steps which doctoral students are expected to follow are listed We assure that if you proceed along these steps you should be able to complete your doctoral work in a smooth and effective way You are advised to keep checking on these steps as you pursue your research Steps before Admission into Research Programmes When you first aspire to do your PhD or MPhil through IGNOU you should log on to the IGNOU website at www ignou ac in The Home Page opens and you get the link Research Degree Programmes there You will here find detailed information on the Research Degree Programmes of IGNOU viz MPhil and PhD You would do well to carefully read and even download this information and choose your area of research based on this information Now look for Admission Advertisement on the Website The University advertises for research programmes twice a year once for the January cycle and second time for the July cycle The advertisement is placed almost four months in advance of the impending cycle on the University website indicating the Disciplines which are offering Research Programmes for particular cycle Please note that all the Disciplines may not offer Research Programme in both cycles Research Unit IGNOU Handbook Prospectus PhD MPhil The Application Form is also placed on the Website You may download the Application Form and fill in the details Remember you should respond to each and every item contained in the Application Form If there is inadequate or wrong information your Application Form is likely to be rejected You must ensure that the Application Fee as indicated in the Advertisement in the form of Demand Draft drawn in favour of IGNOU payable at New Delhi is made ready before the last date indicated in the Advertisement and is attached with your Application Form You must ensure that copies of all documents testifying the information submitted by you in the Application are attached along with your Application Form If you are required to attach a research proposal with your Application Form you must study the Guidelines Research Proposal given below and prepare a Research Proposal accordingly Please note that if you intend to have a supervisor who is not an IGNOU faculty you will have to attach a CV of the supervisor and a letter of consent from the proposed Supervisor Kindly note that every Discipline specifies its own criteria for admitting students Therefore you are advised to carefully read and understand the requirements of the Discipline you are applying for as given in the Table attached at the end of the Prospectus Upon the receipt of your Application Form at the Research Unit IGNOU an initial scrutiny will be made to examine if all the essential conditions of eligibility are met and relevant documents are attached with the Application Fee Thereafter all information contained in your Application Form is recorded in the Master Data Base of the Research Unit The Application Form is then sent to the concerned Discipline through the related School of Study for further consideration There is a Doctoral Committee in each Discipline which is vested with the power to decide and manage admissions in the Research Programmes see Comprehensive Guidelines The Doctoral Committee will examine the Application Form and may get in touch with you to advise you to revise and resubmit your Research Proposal for which reasonable time will be given to you The Doctoral Committee will thus shortlist candidates who are found to be suitable for making their presentations before the Doctoral Committee At the same time Application Forms of candidates who are supposed to take the Entrance Examination before facing the Interview will be screened and checked for eligibility The Discipline wise list of eligible candidates who will appear in the Entrance Examination will be displayed on the Website Hall Tickets enabling the candidates to take the Entrance Examination will be dispatched by the Research Unit and also displayed on our Website In case you do not receive the Hall Ticket dispatched by post you are advised to download the same from the Website and appear in the Examination You are advised to regularly check our Website for Research related information and notifications Research Unit IGNOUHandbook Prospectus PhD MPhil The Research Unit in cooperation with Teaching Faculty of the University will conduct the Entrance Examination on the date fixed for the purpose and announced in advance to help you make your travel arrangements Generally the Entrance Examinations are organized in the last week of April and September for respective cycles of admission beginning July and January every year Candidates who are successful in the Entrance Examination will be duly informed and called for Interview Viva Presentation of Research Proposal before the Doctoral Committee of the Discipline Those candidates who are exempted from appearing in the Entrance Examination will also be called to make their presentations before the Doctoral Committee Here again the Doctoral Committee may give guidance on your Research proposal It is at the discretion of the Doctoral Committee to conduct Interview Viva Presentations according to the convenience of the Experts The details of candidates who are finally selected by the Doctoral Committee along with the allotted Supervisor s in each case will be sent to the School Board for consideration In the case of MPhil the Topic of Dissertation will also be decided at the time of Interview Viva and will be recommended to School Board for consideration The admission of the candidates recommended by the School Board will be placed for final approval to the Research Council Research Council Standing Committee after which an Offer Letter for provisional Admission Registration will be sent by the Research Unit to the candidates The Offer Letter will inform the candidate about his selection and advise her him to deposit the required fee for the MPhil PhD Programme within a stipulated time It is only when you deposit the fee that you are admitted to the Research Programme technically You will then be assigned an enrolment number by the Research Unit Please note that failure to deposit the fee within the stipulated time will result in the cancellation of your admission If your topic of research and the Research Proposal are not finalised at the time of Interview you may be given a maximum of six month time to work on your research topic to finalize the title methodology research approach and such aspects of your work as are advised by the Doctoral Committee You will be guided by your Supervisor s in this matter You should finalize your topic and Research Proposal within six months of your provisional Admission Registration In case you fail to do so your admission will be cancelled and no refund of fees will be made Please understand that it is your responsibility to finalize the Research Topic and Research Proposal within the six month period After the finalization of your Research Proposal and its approval by the Research Council Research Council Standing Committee you will be issued a Confirmation Letter With this your admission into the University s Research Programme is formalised Research Unit IGNOU Handbook Prospectus PhD MPhil Steps after Admission into Research Programmes Course Work At the time of approving your Research Proposal the Doctoral Committee may also assign Course Work related to the thrust areas of research and research methodology The details of Course Work evaluation methodology and the teaching schedule will be given by the Research Programme Coordinator Generally Course Work is assigned to those candidates who are seeking admission to MPhil programme and to the PhD candidates who have not done MPhil However Course Work can also be assigned by the Doctoral Committee to PhD candidates who have done MPhil The Course Work will have to be completed in a maximum period of one year A candidate shall be deemed to have completed the Course Work successfully on obtaining at least C Grade measured on a five point scale or of the maximum score in the Course Work Progress through Research Research is a senior level study You should take responsibility for the progress of your research which will be monitored by your Supervisor s You are supposed to submit Six Monthly Progress Reports of your research work on the prescribed format given in the Prospectus You are advised to submit your Progress Report to the Supervisor for his considerations and placement before the Doctoral Committee on a regular basis and within the stipulated time As a Research Student you will have to give Two Seminar Presentations during your tenure as a Research Scholar and submit a Certificate to this effect in the prescribed format to the Research Unit MPhil candidates are exempted You are also required to publish at least One Research Paper Published Accepted for publication in a peer reviewed refereed Journal and submit a Certificate to this effect in the prescribed format to the Research Unit before submitting the PhD Thesis MPhil candidates are exempted Before the submission of the thesis a Pre submission Seminar will be organized by your Supervisor The seminar will be open to all The report of this seminar incorporating suggestions for improvement if any will be sent to Research Unit for records The Supervisor will ensure that the suggestions given at the Pre submission Seminar are incorporated by you in the Thesis and a Certificate to this effect in the prescribed format is submitted to the Research Unit MPhil candidates are exempted Dissertation Thesis Submission On the completion of your study you shall submit a Summary of the Thesis in electronic form and hard copies of the same words duly approved by the Supervisor s at least days before the submission of Thesis MPhil candidates are exempted Research Unit IGNOUHandbook Prospectus PhD MPhil Thereafter four hard bound copies of the Thesis along with one in the electronic form on a CD shall be submitted by you to the Research Unit through your Supervisor s and the Director of the School The Thesis shall include a Certificate signed by the Supervisor s about the originality of your research work in the prescribed format In case of MPhil candidates two hard bound copies of the dissertation along with one in the electronic form on a CD shall be submitted to the Research Unit through the Director concerned The dissertation shall include a certificate signed by the Supervisor about the originality of the work The thesis will be examined by three External Experts nominated by the Vice Chancellor from a list of seven experts submitted by the Supervisor s through the School Board concerned In case of MPhil the dissertation will be examined by one external examiner nominated by the Vice Chancellor from a list of at least experts submitted by the supervisor through the School Board concerned The report of the Examiner s in each case will be submitted on the prescribed format In case any examiner suggests certain modifications and re submission of the Thesis the same will be communicated to you and you will be asked to re submit the Thesis incorporating all the modifications within six months The Supervisor s will ensure that the suggestions of the examiner are adequately addressed The modified Thesis shall be referred again to the examiner concerned for re evaluation If one of the examiners does not recommend the Thesis for the award of a PhD degree the Thesis shall be referred to another examiner for independent evaluation However if this examiner also rejects the Thesis the Thesis shall be rejected by the University Viva Voce Examination The reports received from Examiners of the thesis will be shown to you beforehand so as to enable you to address the issues raised therein while preparing to defend the Thesis during the viva voce examination An open defence of the Thesis in the viva voce shall be conducted at IGNOU by a panel comprising one of the external examiners nominated by the Vice Chancellor and the principal supervisor of the candidate The Director concerned shall be the Chairperson of the panel The supervisor shall be the convener of the panel The date for open defence venue and topic of the thesis with a brief abstract shall be communicated to the Research Unit by the Supervisor This will also be given wide publicity to facilitate larger participation in the session In case of MPhil after evaluation of the dissertation by the examiner the viva voce shall be conducted by a panel comprising the external examiner the supervisor of the candidate as Convener of the panel and the Director concerned as the Chairperson of the panel The evaluated marks will be given on prescribed format Successful completion of the MPhil Programme will require the candidate to secure minimum marks in each course in the dissertation work and in viva voce Research Unit IGNOU Handbook Prospectus PhD MPhil In case the candidate does not obtain the qualifying marks in the dissertation the evaluation report shall be sent to the Supervisor who can guide the research student in improving the dissertation for re submission This provision can be invoked only once A joint report of the viva voce examination of the PhD candidate will be submitted to the Research Unit by the Director of the School concerned on the prescribed format Award of the Degree All evaluation reports and the joint report giving the final recommendation shall be placed before the Vice Chancellor for approval The Vice Chancellor s decision will be placed before the Academic Council through the Research Council After approval by the Academic Council Research Council notification about the award of Doctoral Degree shall be issued by the Student Evaluation Division SED of the University Pending the approval of the Academic Council a Provisional Notification of the award of PhD will be issued by the Student Evaluation Division SED Congratulations You have meticulously worked through your research topic and deservingly earned your Doctorate CHECK LIST Before submission of Dissertation for MPhil or Thesis for PhD you are advised to ensure that the requirements specified in this check list are fulfilled For MPhil Programme Completion of Course Work Certification of Originality of Dissertation Work by your Supervisor s For PhD Programme Registration for nd rd year through payment of fee for two three years as applicable Submission of all six monthly progress report for the period of research Completion of Course Work if applicable Presentation of at least two Seminar Conference Papers Publication Acceptance of at least one Research Paper in a referred Journal Completion of Pre submission Seminar Certification of Originality of your research by the Supervisor s Research Unit IGNOUHandbook Prospectus PhD MPhil GUIDELINES RESEARCH PROPOSAL Research Proposal is the statement of your scheme of research You have decided the topic which you want to explore Now is the time to put some questions to your own self What is the purpose of your research It is not supposed to be just a rehash of what other people have said on the subject You would certainly like to contribute something original to the world of knowledge through the proposed research It is therefore important to organize your proposed scheme in the form of a cogent and viable write up This write up makes for your research proposal We give below the main components of a research proposal as is generally expected by our decision taking bodies viz Doctoral Committee School Board and Research Council It should contain the following Title Give proposed Research Title Introduction Give a broad description of proposed Research Work Explain important concepts in the study use more space if needed Objectives Establish the rationale for undertaking the study in the background of work done on that theme or the logic of the originality of your research work identify gaps in the knowledge and justify the need for the present study use more space if needed Give broad aims of the study and also the specific objectives State the hypothesis if any which the research intends to examine In case the study does not contain explicit hypothesis it may be mentioned so Research Unit IGNOU Handbook Prospectus PhD MPhil Review of Literature Review some important and related Published Works and analyze them in the context of your study use more space if needed Methodology Write a paragraph on the Research Methodology you propose to use use more space if needed Bibliography Selected list of references used and proposed for the study should be mentioned use more space if needed Note The Research Proposal should be between words SCHOLARSHIPS AND FELLOWSHIPS a Candidates who have qualified UGC NET GATE JEST etc and have been awarded Fellowships by these and such other agencies are welcome to enrol for Doctoral Studies at IGNOU The University will disburse the fellowships awarded to them as per the rules of the awarding agencies b The University also awards Fellowships IGNOU Research Fellowship to full time PhD students of IGNOU The objective of the IGNOU RF scheme is to provide opportunities to full time research students who have no other financial support to undertake research leading to PhD degree in the disciplines offered by IGNOU The tenure of IGNOU RF is initially for a period of two years from the date of the award If the research work is found satisfactory fellowship for an additional year will be awarded to the candidate There is no provision for extension beyond three years The value of the award is Rs pm for all three years presently c The University has the Research and Teaching Assistantship Scheme RTA which provides opportunities to the researchers to undertake advanced studies and research and teaching in the field of Open and Distance Learning RTAs will have to work as full time students in the University and will have to assist the Faculty in teaching related activities The tenure of the Research Unit IGNOUHandbook Prospectus PhD MPhil award is initially for a period of three years which is extendable by two years on annual basis based on satisfactory progress evaluated every year There is no provision for extension beyond five years The value of RTA award is Rs per month with an annual contingent grant of Rs for three years SOME IMPORTANT RULES Some important rules governing the Research Programme are as follows All registrations to MPhil PhD Programmes shall be provisional and the same shall be confirmed according to the procedures prescribed by the Research Council from time to time A candidate who has been offered registration shall deposit the prescribed registration fee within a period of three months from the date of registration failing which his her registration will be treated as cancelled However under special circumstances extension up to six months may be given The decision of the University in such matters will be final The registration of a student may be cancelled for any of the following reasons i Non payment of fees ii Unsatisfactory progress iii Non compliance with the provisions of the Ordinance and other Regulations of the University iv Failure to submit the Dissertation Thesis within the time limit prescribed The Research Council may consider requests for re registration from students whose registration is cancelled An application for re registration if made within a period not exceeding six months from the cancellation of the registration may be considered only on the recommendation of the supervisor s and the School Board as the case may be RESEARCH RESOURCES University Library The IGNOU library is the most resourceful information centre in the country in the field of Distance Education The library has the largest collection of books journals and other related materials in the field of Distance Education throughout the country It was established in in tune with the objectives of IGNOU The primary mission of the library is to support the educational and research programmes of the University by providing physical and intellectual access to information In accordance with the objectives of the University the library aims to develop a comprehensive collection of documents useful to readers The IGNOU library uses LIBSYS Research Unit IGNOU Handbook Prospectus PhD MPhil an integrated Library Management software package with all the modules for the library housekeeping operations Using LIBSYS Web OPAC users can search the Library online catalogue by Author Title Subject and Keywords The library also provides the facility of accessing e resources Chairs of the University The University has identified certain areas in the knowledge domain for focused efforts aimed at knowledge advancement as also extension work wherever possible and has instituted several Chairs for this purpose The Chairs are Academic Resources which provide opportunity to the researchers to enrich themselves in numerous ways A brief mention of such Chairs is presented below i Bahadur Shah Zafar Chair established to commemorate the th Anniversary of the First War of Independence which is supported by the grants released by the Ministry of Culture Govt of India ii The Chair for Sustainable Development was established by the University to mark the decade of education for Sustainable Development by the United Nations The main focus of the Chair is the promotion of research and education in the field of sustainability science iii Visualizing that satellite communications will play a critical role in the growth of the Open and Distance Learning System in the country the University in collaboration with the ISRO has established the ISRO Chair for Satellite Communication Education in IGNOU The Chair will undertake research and educational activities in the application of satellite communication to education iv The Tagore Chair for Indian Literature is located in the School of Humanities The Chair is established to organize symposia seminars and undertake researches in Indian Literature v The Catholic Bishops Council of India has established the CBCI IGNOU Chair in the University to address the needs of the disadvantaged sections of the society through educational programmes extension activities and research vi The Chair for Technology enabled Education is a University level located in the School of Education The Chair will take up various academic activities for effective utilization of technology for development planning and transaction of the curriculum vii The Rajiv Gandhi Chair for Contemporary Studies was established by MHRD to conduct research and studies on themes close to the heart of the former Prime Minister The objective of the Chair is to create National Centres for academic deliberations and action oriented research in the frontier areas of contemporary relevance for improving the quality of life and life management systems viii The UNESCO Chair in Teacher Education through Distance Mode acts as a focal point for activities implemented in the field of teacher education through distance mode ix The Dr B R Ambedkar Chair on Social Change and Development focuses on dissemination of the ideas and thoughts of Dr Ambedkar It also undertakes projects for documenting the history of the movements which tried to remove the caste system Research Unit IGNOUHandbook Prospectus PhD MPhil x The Raman Chair for Mathematics and Science Education is situated in the School of Sciences aims at mapping out policies for national initiatives for furthering the cause of education in the fields xi The Visvesvarayya Chair for Work Education Linkages is located in the School of Engineering and Technology It aims at identifying technological gaps between the needs in the field and available technology It also develops tailor made education and training programmes to cater to the customized needs of the industry IGNOU Researchers Forum As outlined in the Research Policy studying the philosophy of research and training into research methods are important ingredients Modern research methods have impacted the structures of society and relations of power They have also remained pervasive in cultural relations throughout the world The research programmes of the University should therefore draw upon a variety of theoretical positions and their associated strategies and techniques Moreover the researchers should also seek to develop adequate and appropriate approaches to subjects that are diverse hybrid and diasporic It is felt that the research programmes of the University function in an atmosphere of intellectual exchange and cultural negotiation Keeping this in mind the IGNOU Researchers Forum has been formed to provide a platform for interaction among the researchers and to ensure that the essence of the Research Policy is realized The Forum meets on a regular basis and encourages research scholars to make their presentations and participate in the discussions and debates The Forum is open for participation to all teachers staff and students International Collaborations From time to time the University works out schemes which provide an opportunity to enter into international collaborations Under these schemes students and teachers of the University may visit universities and other institutions overseas for study and interaction COMPREHENSIVE GUIDELINES PhD Relevant Notifications and necessary alterations in conformity with the Ordinance on Research Degree Programmes and UGC Minimum Standards and Procedure for Awards of MPhil PhD Degree Regulation incorporated Admission to PhD Program shall take place in two sessions viz January and July every year The admission schedule will be announced through advertisement on the IGNOU website and or in national newspapers for each session indicating the Disciplines which are on offer in the session All applications in the prescribed format shall be received at the Research Unit of IGNOU by duly notified dates The format of application may be downloaded from the website or purchased at the designated Regional Centres and or Study Centres and IGNOU Headquarter at Maidan Garhi New Delhi The applications shall be submitted at the Research Unit as stated above Research Unit IGNOU Handbook Prospectus PhD MPhil The eligibility for admission in PhD program is post graduation level for reserved category marks at the i Candidates who fulfil the eligibility criteria and have qualified UGC NET SLET IIT GATE DAE JEST etc will be selected after making the presentation of their research proposal before Doctoral Committee of the Discipline in an interview Such candidates after admission will be prescribed course work by the Discipline concerned ii Candidates who fulfil the eligibility criteria and also have MPhil Degree and or five years of Work Professional experience as validated by the respective Disciplines may be exempted from appearing in Entrance Examination Such candidates will be invited to make the presentation of their research proposals before Doctoral Committee of the Discipline in an interview Selected candidates may be prescribed Course Work as deemed appropriate by the Discipline iii Candidates who fulfil the eligibility criteria and do not have MPhil NET or five years work experience will appear in the Entrance Examination Those who qualify the Entrance Examination will appear in the interview conducted by the Discipline concerned Such candidates after admission will undergo course work prescribed by the Discipline The Applications received at the Research Unit will be subjected to an initial scrutiny for the eligibility Thereafter the Applications of MPhil and SLET NET GATE JEST qualified candidates will be sent to respective Schools for conduct of interview and research proposal presentations before the Doctoral Committee s of the Discipline s Candidates short listed with MPhil NET SLET GATE JEST or five year work experience as validated by the Discipline will be invited to present their research proposals before the Doctoral Committee of the Discipline The recommendation of the Doctoral Committee shall be placed before the School Board for approval The Director of the School shall forward the recommendation of the School Board to the Research Unit in the prescribed format for the consideration of the Research Council Standing Committee RCSC Research Council RC for final approval Subsequently Research Unit shall send an offer letter to the candidate intimating the approval of provisional admission in the respective PhD Programme A candidate who accepts the offer will remit the prescribed fee within the stipulated time to the Research Unit The candidate whose research topic and synopsis are already approved by the Research Council on the recommendation of the Doctoral Committee shall be issued a letter by the Research Unit confirming registration as PhD student In case the Doctoral Committee suggests modification s the candidate may finalise the Synopsis Research topic in consultation with the Supervisor Thereafter the modified Synopsis Research topic should be processed through the Doctoral Committee and the School Board before its consideration in the RC The candidate will get six month time for finalizing the research topic and synopsis Failure to finalize synopsis within six months as above will result in the cancellation of provisional Registration Admission without any refund of fee Applications of candidates who have to appear in the Entrance Examination will be processed by the Research Unit and uploaded on IGNOU Website Simultaneously Hall Tickets will be issued to them Candidates who qualify in the Research Unit IGNOUHandbook Prospectus PhD MPhil Entrance Examination will appear in an interview conducted by the Discipline Selected candidates will be enrolled provisionally and will undergo course work of one year duration prescribed by the Doctoral Committee of the Discipline The candidate shall be deemed to have completed the course work successfully on obtaining at least C Grade measured on a five point scale or of the maximum score in the course work The candidate will get six months time to finalize research topic and synopsis since the completion of course work of one year duration and will attract the same provision of cancellation as in Sl No above on failure to finalize synopsis within a period of six months since provisional Registration Admission Students enrolled in PhD program may work on full time basis or on part time basis at the University vide Clause of the Ordinance on Research Degree Programmes All those who have been awarded a fellowship either by IGNOU or any other funding agency will work as full time research students Change from part time to full time or vice versa will have to be approved by the Doctoral Committee and the School Board and placed before the RCSC RC for approval within a reasonable time The decision of the RCSC RC in this matter will be final Minor change in the topic of PhD thesis can be made within years of provisional registration for PhD This minor change in the topic will have to be approved by Doctoral Committee School Board and thereafter placed before RCSC RC for approval No minor change of topic will be permitted after years of provisional registration In case there is a major change of topic as decided by the Doctoral Committee the student will have to go through the process of fresh registration There will be a Doctoral Committee for each Discipline that will manage all aspects of research program pertaining to the Discipline The Doctoral Committee of each Discipline will comprise the following i Director of the School Chairperson ii Faculty of the Discipline concerned Members iii At least one External Expert from a Panel recommended by the School Board and approved by the Vice Chancellor Member Programme Coordinator of PhD Convener iv The term of an External Expert on the Panel of the Doctoral Committee will be two years and the Expert will be eligible for re nomination Doctoral Committee will perform the following functions i Organize all such activities as are relevant to the research programme of the Discipline ii Approve the topic of research the synopsis and the allocation of supervisor iii Assess and approve the progress reports of PhD students iv Prescribe course work v Approve change of topic of dissertation thesis change of supervisor and status of researcher full time to part time and vice versa Research Unit IGNOU Handbook Prospectus PhD MPhil vi Recommend or not extension of tenure of fellowships if applicable beyond the initial period of the award vii Approve the finalized synopsis within six month period of provisional admission registration of students viii Consider and recommend to the School Board for approval the CVs and names of supervisors in accordance with the Ordinance ix Ensure observance of the admission schedule in each cycle as announced by the Research Unit and x Ensure the observance of the Reservation Policy of the Government of India The courses will be designed and developed as per the laid down procedures of the University and the details along with the evaluation methodology will be provided by the Research Programme Coordinator as worked out by the Doctoral Committee for the approval of the School Board and RC RCSC The schedule of the course work decided by the Doctoral Committee will be announced by the Research Programme Coordinator Records related to admission registration payment of fees and other learner records will be maintained by the Research Unit The relevant information on the payment of fee by the research student will be regularly communicated by the Research Unit to the respective Disciplines enabling them to keep an update on the status of the research student All research Supervisors approved by IGNOU in accordance with the Ordinance on Research Degree Programmes can guide research students A Supervisor shall be deemed to have renewed her his quota of enrolment on completion of three years of registration of a candidate under her his supervision The progress of the research student shall be monitored by the supervisor s However generating the six monthly progress reports on the prescribed format will be the responsibility of the research student S He shall submit her his progress report to the Supervisor for placing the same before the Doctoral Committee The recommendation of the Doctoral Committee will be placed before the School Board The minutes of the Doctoral Committee and that of the School Board will be forwarded by the Director of the School for placing before the RCSC RC In case of unsatisfactory progress over a time period of one year and or non submission of timely report fee the University reserves the right to cancel the registration under Clause of the Ordinance Each research student will give at least two seminars prior to the pre submission seminar before the Doctoral Committee The maximum duration after registration for the PhD Program shall be five years The maximum duration can be extended by a maximum of one year with the permission of the Vice Chancellor The request for extension shall have to be moved by the research student through Supervisor and the Doctoral Committee In such cases a prescribed fee will have to be paid by the student for the period of extension Research Unit IGNOUHandbook Prospectus PhD MPhil When the research student is nearing the completion of his PhD work a pre submission seminar open to all will be organized by the Supervisor The report of the seminar and suggestions for improvement if any will be sent by the Supervisor through the Director of the School to the Research Unit for records The Supervisor will ensure that constructive suggestions made in the pre submission seminar to improve the quality of research are incorporated in the thesis At least one research paper should be published accepted for publication in a peer reviewed refereed Journal online or print before the submission of thesis The research student shall submit a copy in electronic form on a CD and four hard copies of the summary of the thesis words to the Research Unit duly approved by the Supervisor s at least days before the submission of thesis Four hard bound copies of the thesis along with one in the electronic form on a CD shall be submitted to the Research Unit through the Director concerned The thesis shall include a certificate in the prescribed format signed by the Supervisor s about the originality of the work The thesis shall be examined by three external experts nominated by the Vice Chancellor from a list of seven experts submitted by the Supervisor s through the School Board concerned The report of the evaluation will be given on a prescribed format In case an examiner suggests certain modifications or re submission of the thesis the same should be communicated to the candidate who will be asked to resubmit the thesis with all the modifications within six months The research Supervisor s will ensure that the suggestions of the examiner are adequately addressed before resubmission of the thesis The modified thesis shall be referred again to the examiner concerned for re evaluation If one of the examiners does not recommend the thesis for the award of a PhD degree the thesis shall be referred to another examiner for independent evaluation If the fourth examiner recommends the thesis for the award the viva voce examination shall be organized by the Director of the School as prescribed at Sl No However if this examiner also rejects the thesis the thesis shall be deemed to be rejected by the University The examiners reports will be communicated to the School concerned and the Supervisor to be shared with the candidate prior to the viva voce examination to enable her him to address the issues that arise in the reports while preparing to defend the thesis The viva voce examination shall be conducted at IGNOU as an open defence of the thesis by a panel comprising one of the external examiners nominated by the Vice Chancellor and the Supervisor s of the candidate The Director concerned shall be the Chairperson of the panel The Supervisor from IGNOU shall be the Convener of the panel The date for open defence venue and topic of the thesis with a brief abstract shall be communicated to the Research Unit by the Director of the School concerned This should also be given wide publicity by the Research Unit so as to facilitate larger participation Research Unit IGNOU Handbook Prospectus PhD MPhil The report of the viva voce examination prepared by the External Examiner and the Research Supervisor s in the prescribed format will be sent to the Research Unit through the Director of the School concerned The report shall be placed before the Vice Chancellor for approval The Research Unit will communicate the approval of the Vice Chancellor along with other relevant matter to the Student Evaluation Division for issuing the notification The PhD degree will be awarded at the Convocation COMPREHENSIVE GUIDELINES MPhil Relevant Notifications and necessary alterations in conformity with the Ordinance on Research Degree Programmes and UGC Minimum Standards and Procedure for Awards of MPhil PhD Degree Regulation incorporated Admission to MPhil Program shall take place in two sessions viz January and July every year The admission schedule will be announced through advertisement on the IGNOU website and or in national newspapers for each session indicating the Disciplines which are on offer in the session All applications in the prescribed format shall be received at the Research Unit of IGNOU by duly notified dates The format of application may be downloaded from the website or purchased at the designated Regional Centres and or Study Centres and IGNOU Headquarter at Maidan Garhi New Delhi The applications shall be submitted at the Research Unit as stated above Candidates having post graduation with marks for reserved category will be eligible for admission into MPhil Programme There will be a Doctoral Committee for each Discipline that will manage all aspects of research program pertaining to the Discipline The Doctoral Committee of each Discipline will comprise the following i Director of the School Chairperson ii Faculty of the Discipline concerned Members iv At least one External Expert from a panel recommended by the School Board and approved by the VC Member Programme Coordinator of PhD Convener iv Doctoral Committee will perform the following functions i Organize all such activities as are relevant to the research programme of the Discipline ii Approve the topic of research the synopsis and the allocation of supervisor iii Prescribe course work iv Approve change of topic of dissertation change of supervisor and status of researcher full time to part time and vice versa Research Unit IGNOUHandbook Prospectus PhD MPhil v Recommend or not extension of tenure of fellowships if applicable beyond the initial period of the award vi Consider and recommend to the School Board for approval the CVs and names of supervisors in accordance with the Ordinance vii Ensure observance of the admission schedule in each cycle as announced by the Research Unit and viii Ensure the observance of the Reservation Policy of the Government of India Applications of candidates who have to appear in the Entrance Examination will be processed by the Research Unit and uploaded on IGNOU Website Simultaneously Hall Tickets will be issued to them Candidates who qualify in the Entrance Examination will appear in an interview conducted by the Doctoral Committee The Doctoral Committee will recommend the selected candidates and place their cases along with the topics of their dissertation before the School Board for approval The approval of the School Board will be forwarded to the RC RCSC for approval After approval by RC RCSC the Research Unit shall inform the student about his her selection through an Offer Letter A student who accepts the offer will remit the prescribed fee within the stipulated time to the Research Unit Thereafter her his admission will be confirmed through a confirmation letter issued by Research Unit All the candidates so admitted shall undergo course work The candidates may simultaneously undertake course work and dissertation work The maximum duration for completing MPhil Programme shall be years Two hard bound copies of the dissertation along with one in the electronic form on a CD shall be submitted to the Research Unit through the Director concerned The dissertation shall include on the prescribed format a certificate signed by the Supervisor s about the originality of the work The dissertation shall be examined by an external examiner nominated by the Vice Chancellor from a list of at least experts submitted by the Supervisor through the School Board concerned The report of the examiner will be submitted on the prescribed format After evaluation of the dissertation by the examiner the viva voce shall be conducted by a panel comprising the external examiner the Supervisor of the candidate as Convener of the panel and the Director concerned as the Chairperson of the panel The report of the evaluation will be given on the prescribed format Successful completion of the MPhil Programme will require the candidate to secure minimum marks in each course in the dissertation work and in viva voce In case the candidate does not obtain the qualifying marks in the dissertation the evaluation report shall be sent to the Supervisor who can guide the research student in revising the dissertation for re submission The revised dissertation will be examined by the same examiner and the re evaluation report will be considered as final report This provision can be invoked only once Research Unit IGNOU Handbook Prospectus PhD MPhil PLEASE NOTE The next pages comprise the Application Form consisting of two Parts namely Part A and Part B Before you start filling in the two Parts of the Application Form make sure that you have read the Instructions for filling up the Form very carefully Remember that making wrong entries in the Application Form will lead to rejection An electronic version of the Prospectus is also available on the internet at www ignou ac in Make sure that you fill Part A and Part B of Application Form before submission In case any part is not filled your Application will be rejected Ensure that all attested documents in support of information given by you are attached along with your Application Form Research Unit IGNOUHandbook Prospectus PhD MPhil INSTRUCTIONS FOR FILLING UP THE APPLICATION FORM PART A Please fill up the Application Form and mail or submit in person the same along with copies of attested Certificates to Director Research Unit Block Room No Indira Gandhi National Open University Maidan Garhi New Delhi Please abide by the dates mentioned in the Advertisement Notification on the website of IGNOU Some instructions for filling up Part A of Application Form are given below Please strike out the Session which is not applicable Please strike out the Programme Code which is not applicable For Programme Code refer to Appendix RU I of this Prospectus For Research Discipline refer to Appendix RU I of this Prospectus and write down the name of the Discipline Enrolment Number leave it blank University will allot the Enrolment Number Regional Centre Code is shown by default You need not fill it For State Code refer to Appendix RU II of this Prospectus a and b if you are already registered or have done a programme with IGNOU please write the relevant code in the boxes If A then write the Enrolment Number and Programme Code Please follow the rule of Date Month Year e g th June should be written as If your name is MUKESH KUMAR SHARMA then write it as below M U K E S H K U M A R S H A R M A Please write your Father s Husband s Mother s name If name is RAKESH KUMAR SHARMA then write it as below R A K E S H K U M A R S H A R M A Fill in your address for correspondence where you will receive letters from the University Do not give Post Box Number as Address Leave a box blank between each unit of address like House Number Street Name P O etc to Write your Landline Telephone Number Fax Number Mobile Number and E mail Address if any Research Unit IGNOU Handbook Prospectus PhD MPhil to Write relevant codes in the appropriate Boxes For example if you are Male put A in box against Sl No For a and b write the relevant code in the box If A then fill the Column b also Write the relevant code in the box a and b write the relevant code if you are below poverty line and also mention the annual family income a and b write the relevant code if you are receiving Scholarships and tick the box for the name of the Agency Also write the amount received per year Fill all the Columns beginning with your Matriculation till the highest Degree obtained by you so far For fee details the amount is shown by default Please enter the Demand Draft Number Date Amount Place of Bank and Name of the Issuing Bank Make sure that your Demand Draft is drawn in favour of IGNOU payable at New Delhi only In case you have bought the Prospectus by paying Rs you need not enclose the Demand Draft However if you have downloaded the Application Form you must attach Demand Draft CHECK LIST Before sending the filled in form to Director Research Unit please check whether you have a Affixed your Photograph b Enclosed the attested certificates as proof of information given c Enclosed Category Certificate for SC ST PH OBC Non creamy Layer Minority Candidates No change of category shall be entertained from student after the submission of Application Form d Enclosed Age certificate wherever required e Enclosed a Demand Draft as Application Fee and have written your Name Programme Code Discipline and Application Form Number on the reverse of the Demand Draft issued by bank f In case of below poverty line students documentary proof photocopy of BPL Ration Card is to be attached separately g Enclosed Annexure RU III and RU IV Research Unit IGNOUHandbook Prospectus PhD MPhil Application Number INDIRA GANDHI NATIONAL OPEN UNIVERSITY bafnjk xak kh jk Vah eqDr fo ofo ky APPLICATION FORM Part A FOR MPhil PhD PROGRAMMES SESSION JANUARY PHOTOGRAPH JULY Strike out the Session not applicable PROGRAMME APPLIED FOR MPHIL Affix your latest passport size cm X cm photograph duly attested by you PHD Strike out which is not applicable Programme Code Research Discipline Enrolment Number Regional Centre Code C O To be issued by the University State Code a Are you already Registered with IGNOU A YES B NO b If YES write the Enrolment No and Programme Code Date of Birth Date Month Year Name of the Applicant Leave one box blank between First Middle and Surname Father s Husband s Mother s Name Strikeout whichever is not applicable Address for Correspondence Please do not give Post Box No Leave a blank box between each unit of address City District PIN Code State Landline Telephone Number if any with STD CODE STD CODE Telephone Number Mobile No FAX Number if any STD CODE FAX Number Email Address ID if any Nationality A Indian B Others Gender Write the relevant Code in the box A Male B Female C Others Research Unit IGNOU Category Write the relevant Code in the box A GEN B SC C ST D A OBC Creamy D B OBC Non Creamy Territory Code Write the relevant Code in the box A Urban B Rural C Tribal Handbook Prospectus PhD MPhil Marital Status Write the relevant Code in the box Religion Write the relevant Code in the box A Married B Unmarried A Hindu B Muslim C Christian D Sikh E Jain F Budhist G Parsi H Jews I Others Whether Minority Social Status a Whether a Person with Disability b If yes give Nature of Disability Employment Status a Whether Below Poverty Line Write the relevant Code in the box A Yes B No Whether Kashmiri Migrant Write the relevant Code in the box A Ex servicemen B War Widow C Not Applicable Write the relevant Code in the box A Yes B No Write the relevant Code in the box A Yes B No Write the relevant Code in the box A Speech and Hearing Impairment D Low Vision B Locomotor Impairment E Any other C Visual Impairment pl specify Write the relevant Code in the box A Unemployed B IGNOU Employee C Employed D KVS Employee b Annual Family Income A Yes B No a Are you in Receipt of any of these Scholarships Write the relevant Code in the box A Yes B No Rs b If Yes please specify Agency and Amount Rs per year Tick which is applicable UGC CSIR ICMR DST ICSSR ICHR OTHERS Pl specify Details of Educational Qualifications from Graduation onwards Sl No University Name of the Examination Year of Passing Subjects Percentage of Marks Details of Application Fee to be paid by a Demand Draft in favour of IGNOU payable at New Delhi if the Form is downloaded from IGNOU website Candidates buying the Prospectus need not attach Demand Draft Note Application shall not be accepted without this fee Amount Rs DD Date DD Number Place of Bank Date Month Year Name of the Bank DECLARATION BY THE APPLICANT I hereby declare that I have read and understood the conditions of eligibility for the academic programme for which I seek the admission I fulfil the minimum eligibility criteria and I have provided the necessary information I also declare that the information submitted above is true and correct to the best of my knowledge In the event of any information being found incorrect or misleading my candidature shall be liable to cancellation by the University at any point of time even after award of Degree and I shall not be entitled to refund of any fee paid by me to the University Further I have carefully studied the rules of the University as printed in the Prospectus and I accept them and shall not raise any dispute in the future over the same rules Dated Signature of the Applicant Research Unit IGNOUHandbook Prospectus PhD MPhil INSTRUCTIONS FOR FILLING UP THE APPLICATION FORM PART B Some instructions for filling up Part B of Application Form are given below Please strike out the Session which is not applicable Please strike out the Programme Code which is not applicable For Programme Code refer to Appendix RU I of this Prospectus For Research Discipline refer to Appendix RU I of this Prospectus and write the name of the Discipline a and b please tick in the relevant box If Yes fill in details of Dissertation Research Discipline Month and Year of Award and University a Please write the position in which you are working b Give the Date and Year from which you are working in the Organization c Name the Organization in which you are working d Fill in the Address of the Organization e Write down the Landline Telephone Number Fax Number Mobile Number and E mail Address if any of the Organization through which you may be contacted Give details about various jobs held by you as evidence of your Work Experience after Post Graduation Mention the Title of the Thesis you propose to work on This will be filled in later by the Research Unit Tick mark if you have enclosed not enclosed your Research Proposal If you propose to work with external Research Supervisor or a Co supervisor give details as required in this section Make sure that you enclose the CV of the Research Supervisor in case you intend to have such support Research Unit IGNOU Handbook Prospectus PhD MPhil CHECK LIST Before sending the filled in form to Director Research Unit please check whether you have a Enclosed MPhil Certificate b Enclosed proof of your current employment c Enclosed proof of your employment after Post Graduation d Research proposal e Consent Letter of External Research Supervisor if any f Brief CV of the External Research Supervisor Research Unit IGNOUHandbook Prospectus PhD MPhil Application Number INDIRA GANDHI NATIONAL OPEN UNIVERSITY bafnjk xak kh jk Vah eqDr fo ofo ky APPLICATION FORM Part B FOR MPhil PhD PROGRAMMES SESSION JANUARY JULY PHOTOGRAPH Strike out the Session not applicable PROGRAMME APPLIED FOR MPHIL PHD Affix your latest passport size cm X cm photograph duly attested by you Strike out which is not applicable Programme Code Research Discipline Whether you have M Phil If YES YES NO i Please specify the Title of Dissertation ii Research Discipline Area iii Month and Year of Award of M Phil Month Year iv Name of the University and Place If Employed please give details of current Employment a Designation b Serving from c Name of the Organization d Address of employer City e Landline Telephone Number with STD CODE STD CODE Telephone Number Mobile No PIN Code f FAX Number if any STD CODE FAX Number Email Address ID if any Work Experience after Post Graduation Please mention in Chronological Order Name and Address of the Organization Nature of Post Designation Temporary Ad hoc Permanent Research Unit IGNOU Tasks Undertaken Period of Service Number of Years of Experience Years and Months From To Year Month Handbook Prospectus PhD MPhil Proposed Title of the Thesis of Ph D Approved Title of the Thesis to be filled by the Office after acceptance of Application Research proposal for Ph D ENCLOSED NOT ENCLOSED Tick whichever is applicable Note Candidates for M Phil need not enclosed Research Proposal M Phil selections are based on entrance test plus interview to be conducted by the University In case you propose to have External Research Supervisor please furnish the following details Note External Research Supervisors must be approved and empanelled by the concerned School Board of the University i Name of the External Research Supervisor ii Name and Address of the Institution iii a Present Position if in Service b if Retired give details iv Address and Contact details v Consent letter for Guiding Student Enclosed Not Enclosed Tick whichever is applicable vi CV of the Research Supervisor Enclosed Not Enclosed Tick whichever is applicable CV should be a brief in pages duly signed by the Supervisor DECLARATION BY THE APPLICANT I hereby declare that statements made in this application form are true and correct to the best of my knowledge and belief I am aware that if at any stage it is found that the statement made by me are not true or misleading my admission registration will be cancelled by the University and I shall not be entitled to refund of any fee paid by me to the University Further I have carefully studied the rule of the University as printed in the Prospectus and I accept them and shall not raise any dispute in the future over the same rules Dated Signature of the Applicant Research Unit IGNOUHandbook Prospectus PhD MPhil Checklist Tick the relevant Boxes Certificates in support of educational qualification s Date of birth Certificate Age Certificate Category certificate if applicable Work Experience Certificate CV of External Supervisor if any Consent letter of External Supervisor if applicable Research Unit IGNOU for SC ST OBC PH Kashmiri Migrant War Widow Handbook Prospectus PhD MPhil SOME USEFUL FORMS The following Forms are for your use Certificate of Presentation of Seminar Conference Papers Certificate of Publication of Papers Certificate of Completion of Course Work Certificate of Completion of Pre submission Seminar Certificate of Originality Thesis Dissertation Progress Report Registration Form for nd Year rd Year for PhD Programme Joint Report of Viva Voce of Research to be attached with Research Unit IGNOU theHandbook Prospectus PhD MPhil INDIRA GANDHI NATIONAL OPEN UNIVERSITY RESEARCH UNIT CERTIFICATE OF PRESENTATION OF SEMINAR CONFERENCE PAPERS This is to certify that Mr Ms pursuing PhD Programme in with Enrolment Number has made the following Two Seminar Presentations in the Forums mentioned thereby fulfilling the Programme requirements Date Research Supervisor Research Unit IGNOU Research Programme Coordinator Handbook Prospectus PhD MPhil INDIRA GANDHI NATIONAL OPEN UNIVERSITY RESEARCH UNIT CERTIFICATE OF PUBLICATION OF PAPERS This is to certify that Mr Ms pursuing PhD Programme in with Enrolment Number has the following Publications Letters of Acceptance in the Journals mentioned thereby fulfilling the Programme requirements Sl No Title of the Paper Publication Details Date Research Supervisor Research Programme Coordinator Research Unit IGNOUHandbook Prospectus PhD MPhil INDIRA GANDHI NATIONAL OPEN UNIVERSITY RESEARCH UNIT CERTIFICATE OF COMPLETION OF COURSE WORK This is to certify that Mr Ms pursuing PhD MPhil Programme in with Enrolment Number has completed the following Course Work thereby fulfilling the Programme requirements Sl No Course Title Course Credits Date Research Supervisor Research Unit IGNOU Research Programme Coordinator Handbook Prospectus PhD MPhil INDIRA GANDHI NATIONAL OPEN UNIVERSITY RESEARCH UNIT CERTIFICATE OF COMPLETION OF PRE SUBMISSION SEMINAR This is to certify that Mr Ms pursuing PhD Programme in with Enrolment Number has made his her presentation in the pre submission seminar held on thereby fulfilling the Programme requirements Date Research Supervisor Research Programme Coordinator Research Unit IGNOUHandbook Prospectus PhD MPhil INDIRA GANDHI NATIONAL OPEN UNIVERSITY RESEARCH UNIT CERTIFICATE OF ORIGINALITY OF RESEARCH To be attached with the Thesis Dissertation This is to certify that the thesis entitled submitted by Smt Km Shri is her his original Research Work and has not been presented for the award of any Degree elsewhere Date Research Unit IGNOU Research Supervisor Handbook Prospectus PhD MPhil INDIRA GANDHI NATIONAL OPEN UNIVERSITY RESEARCH UNIT PROGRESS REPORT FOR MPHIL AND PHD STUDENTS To be submitted on Six Monthly basis after Admission Progress Report for the Period Name and Enrolment Number Address Mobile Number Email ID Discipline and School Month of MPhil PhD Registration and Cycle Topic Approved for MPhil PhD Name of the Research Supervisor s Status of PhD Research Progress of the Research in terms of Problem Formulation Pilot Study Field Work Experimentation Data Collection Data Analysis Report Writing etc may be given use more space as needed Details of Course Work undertaken i Course work Assigned with Credits ii Course work Completed with Credits Teaching Activities undertaken Participation in Writing and Editing ODL Study Materials Academic Counseling Evaluation Teleconferencing IRC etc may be given use more space as needed Research Unit IGNOUHandbook Prospectus PhD MPhil Participation in seminars conferences during the period under report use more space as needed Presentation of papers in seminars conferences during the period under report use more space as needed Publications during the period use more space as needed i Professional ii General Details of Books Research Papers reviewed use more space as needed Any other special contributions by the researcher to the institution during the period under report use more space as needed OBSERVATIONS OF THE SUPERVISOR including on the research aptitude of the candidate Evaluation of the Progress of the Researcher Progress is Very Good Good Satisfactory Needs improvement Date Research Supervisor Research Unit IGNOU Research Programme Coordinator Handbook Prospectus PhD MPhil INDIRA GANDHI NATIONAL OPEN UNIVERSITY RESEARCH UNIT REGISTRATION FORM FOR ND AND RD YEAR FOR PHD PROGRAMMES Name and Enrolment Number Address Contact Number E mail ID Discipline and School Topic of PhD Research Demand Draft Number Date Bank Issuing Demand Draft Indicate if the fees is for nd or rd Year Date Signature of the Candidate Full Name of the Candidate Encl Demand Draft along with this Application Form Please super scribe the Envelope Registration Fee for nd rd Year as the case may be Research Unit IGNOUHandbook Prospectus PhD MPhil INDIRA GANDHI NATIONAL OPEN UNIVERSITY RESEARCH UNIT JOINT REPORT OF VIVA VOCE This is to certify that Mr Ms Enrolment Number pursuing MPhil PhD Programme in Discipline on the topic has been examined by us in the Viva Voce conducted on Date at Venue The marks for the Viva Voce examination of MPhil are Wherever applicable The Board has the following observations to make The Board recommends does not recommend the award of the Degree of Master Doctor of Philosophy to Mr Ms Research Supervisor Research Unit IGNOU Director External Examiner Handbook Prospectus PhD MPhil LIST OF DOCTOR OF PHILOSOPHY PhD PROGRAMMES Sl No Name of the Programme Code and Coordinator Eligibility Course Work SCHOOL OF AGRICULTURE SOA Doctor of Philosophy in Agriculture Extension PHDAGE Dr P K Jain pkjain ignou ac in M Sc in Agriculture Extension Extension Education Home Science Extension Dairy Extension Veterinary and Animal Husbandry Extension Fisheries Extension Agricultural Communication Development Communication Agricultural Extension and Communication Masters degree in any branch of Agricultural Sciences or allied fields with bridge course in Agricultural Extension will appear in Entrance Examination All Courses of Credits each RAE Advances in Agriculture Extension RAE Agriculture Extension Management RAE Information Communication Technology in Agriculture RAE Research Methodology and Scaling Techniques Bridge Course RAE Fundamentals of Agriculture Extension and Communication Doctor of Philosophy in Dairy Science and Technology PHDDR Dr M K Salooja mkslooja ignou ac in Master s Degree in Dairy Science Dairy Technology Dairy Chemistry Dairy Microbiology Dairy Engineering Food Science Food Technology M V Sc Animal Products Technology Live Products Technology Dairy Science M Sc Agriculture Dairy Science Dairy Technology M Sc Agriculture Processing and Food Engineering with B Tech in Dairy Technology will appear in Entrance Examination Compulsory Courses Credits each RDR Advances in Lipid Technology RDR Advances in Protein Technology RDR Product Monitoring and Process Control RDR R D Management in Dairy Industry Four Optional Courses Credits each RDR Developments in Dairy Processing RDR Dairy By products Technology and Processing RDR Advances in Chemistry of Milk Processing RDR Advances in Analytical Techniques in Dairy Chemistry RDR Applied Food Biotechnology RDR Dairy and Food Microbiology RDR Dairy and Food Engineering I RDR Dairy and Food Engineering II Research Unit IGNOUHandbook Prospectus PhD MPhil Sl No Name of the Programme Code and Coordinator Eligibility Course Work SCHOOL OF CONTINUING EDUCATION SOCE Doctor of Philosophy in Child An MPhil Degree and a Development PHDCDEV Post Graduate Degree in the discipline of Child Development Prof Neerja Chadha or Human Development Human neerja chadha ignou ac in Development and Family Studies Human Development and Childhood Studies or an allied discipline such as Psychology Sociology Anthropology Social Work Education Disability Studies and other allied fields such as Physiotherapy Occupational Therapy etc with minimum marks marks for SC ST PH candidates or an equivalent grade from a University or a recognized Institution of higher learning The student should have exhibited interest in the discipline of Child Development and familiarity with Research Methodology during the MPhil programme and through Teaching Research Professional Public Service experience in the area of Child Development Evidence of interest and candidate s familiarity with Research Methodology in the area of Child Development will be evaluated by candidate s research publications at least three published in reputed National International Journals of which at least one should be in a peer reviewed Journal OR Master s Degree in the discipline of Child Development or Human Development Human Development and Family Studies Human Development and Childhood Studies or an allied discipline such as Psychology Sociology Anthropology Social Work Education Disability Studies and other allied fields such as Physiotherapy Occupational Therapy etc with minimum marks marks for SC ST PH candidates or an equivalent grade from a University or a recognized Institution of Research Unit IGNOU Handbook Prospectus PhD MPhil Sl No Name of the Programme Code and Coordinator Eligibility Course Work higher learning and at least years of Teaching Professional experience in a University or a recognized Institution of higher Learning Research as well as Demonstrable Research experience and familiarity with Research Methodology in the area of Child Development Evidence of demonstrable research experience and candidate s familiarity with Research Methodology will be evaluated by candidate s Research Publications at least three published in reputed National International Journals of which at least one should be in a peer reviewed Journal SCHOOL OF COMPUTER AND INFORMATION SCIENCE SOCIS Doctor of Philosophy in One of the following All will Computer and Information appear in Entrance Examination Sciences PHDCISC M Tech MPhil in Computer Prof Shashi Bhushan Science Information shashibhushan ignou ac in Technology MCA MSc in Computer Science B Tech in Computer Science Information Technology with five year experience either in Teaching or in Software Industry Doctor of Philosophy in Food MPhil Degree and a Master Degree and Nutrition PHDFN in Nutrition Dietetics with and above and above in case of Prof Deeksha Kapur SC ST PH or an equivalent grade deekshakapur ignou ac in from a recognized Institution of higher learning OR A Masters Degree M Sc in Foods and Nutrition with and above and above in case of SC ST PH or an equivalent grade from a recognized Institution and FIVE years Teaching Industry Professional Public service experience in an area related to Nutrition Dietetics at senior level SCHOOL OF EDUCATION SOE Doctor of Philosophy in All will appear in Entrance Education PHDEDU Examination Prof C B Sharma MPhil in Education sharmacb yahoo com OR Master degree in Education and five years Teaching experience Research Methodology Credits Analysis and Design of Algorithm Credits Topics in Mathematical Science Credits Operating Systems Credits Elective Courses Credits All students eligible for PhD would be required to enrol simultaneously and successfully complete the Course Research Methods and Biostatistics MFN However students with an MPhil may be exempted from taking the Research Methods and Biostatistics Course on the recommendation of the Doctoral Committee Research Unit IGNOUHandbook Prospectus PhD MPhil Sl No Name of the Programme Code and Coordinator Eligibility Course Work SCHOOL OF ENGINEERING AND TECHNOLOGY SOET Doctor of Philosophy in Civil Engineering PHDCENG Prof Ajit Kumar ajit ignou ac in Master of Engineering Technology in Civil or in the relevant field of Civil Engineering will appear in Entrance Examination Doctor of Philosophy in Mechanical Engineering PHDMCE Dr Ashish Agarwal ashisha ignou ac in Master of Engineering Technology in Mechanical or in the relevant field of Mechanical Engineering will appear in Entrance Examination SCHOOL OF GENDER AND DEVELOPMENT STUDIES SOGDS Doctor of Philosophy in Master s Degree and five years Gender and Development Teaching Research or work Studies PHDGDS experience Prof Annu J Thomas OR athomas ignou ac in MPhil Degree in any discipline with demonstrable evidence of Research Publications Interest in areas relevant to Gender and Development Studies Doctor of Philosophy in Academic performance at Women s Studies PHDWS MPhil Master s level Post Graduate Degree in relevant discipline Prof Anu Aneja number of years of Teaching anuaneja ignou ac in experience and Demonstrable Evidence of Research Publications Interest in Women s and Gender Issues Civil Engineering Mathematics Research Methodology System Dynamics Construction Management Mechanical Engineering Operations Research Materials Management System Dynamics Production and Operation Management Mathematics Research Methodology Candidates would spend six months in research related activities SCHOOL OF HUMANITIES SOH Doctor of Philosophy in Hindi PHDHIN Prof Satyakam satyakam ignou ac in Master Degree in Hindi will appear in the Entrance Examination OR Master Degree and MPhil in Hindi OR Master Degree and five years Teaching Research experience in Lecturer s Grade Research Unit IGNOU Theory courses are compulsory Two more shall be allotted from electives RHD Anusandhan Ka Swaroop Aur Pravidhi Theory RHD Sahitya Ke Naye Vimarsh Theory RHDE Aadhunic Sahitya Aur Chintan Elective RHDE Madhyakalin Sahitya Aur Chintan Elective RHDE Jansanchar Madhyam Elective RHDE Anuvad Sanskrit Aur Bhasha Asmita Elective RHDE Hindi Bhasha Aur Bhasha Vigyan Elective Handbook Prospectus PhD MPhil Sl No Name of the Programme Code and Coordinator Eligibility Course Work RHDE Tulnatmak Sahitya Elective RHDE Sanskrit Pali Prakrit Apbrhansh Aur Adhunik Bharitya Bhashaon Ke Sahitya Ka Itihas Elective Credits each Doctor of Philosophy in English PHDENG Dr Prema Eden Samdup psamdup ignou ac in Master Degree in English and MPhil and having five years Teaching Research experience in Lecturer s Grade Theory courses are compulsory Two more shall be allotted from electives REG Research Methodology Theory REG Resistance Literature Theory REGE Gender Elective REGE Literature and Migration Elective REGE Translation Theory and Practice Elective REGE The Nature and Structure of Language Elective REGE Folk Narratives Text and Performance Elective Credits each SCHOOL OF HEALTH SCIENCES SOHS Doctor of Philosophy in Nursing professionals having Nursing PHDNUR MPhil from a recognized University Prof Bimla Kapoor OR bkapoor ignou ac in M Sc Nursing and having five Prof Pity Koul years Teaching Industry pkoul ignou ac in Administration Professional Clinical experience The scholars will do the course work in the form of assignments and presentation recommended by Doctoral Committee which will be evaluated internally by the PhD Coordinators of Nursing Discipline SCHOOL OF INTER DISCIPLINARY AND TRANS DISCIPLINARY STUDIES SOITS Doctor of Philosophy in Preferably Master Degree in Social RITS Inter Inter Disciplinary and Sciences or Humanities and disciplinary and Trans Disciplinary Studies MPhil Degree or years of Trans disciplinary PHDITS Teaching Professional experience Research PhD Research proposal in an area Dr Nandini Sinha Kapur RITS Research of Interdisciplinary Research nandini ignou ac in Methods in Social Science should be enclosed RITS Area Studies OR RITS Literature Post Graduate Degree in any Survey discipline with research proposal All Courses are of Credits on any aspect of interdisciplinary each studies preferably from Social Sciences and Humanities background will appear in the Entrance Examination Research Unit IGNOUHandbook Prospectus PhD MPhil Sl No Name of the Programme Code and Coordinator Eligibility Course Work SCHOOL OF MANAGEMENT SCIENCES SOMS Doctor of Philosophy in Commerce PHDCOM Prof Naval Kishor nkishor ignou ac in Prof Madhu Tyagi mtyagi ignou ac in MPhil and with Post Graduate Degree in Commerce or any other allied disciplines from any recognized University Institution of higher learning OR Master Degree in Commerce or any other allied disciplines from any recognized University Institute of higher learning with years of Teaching Professional Industry experience Doctor of Philosophy in Management PHDMGMT Prof P C Basak pcbasak ignou ac in Master Degree equivalent Degree from a recognized University Institution will appear in Entrance Examination OR Master Degree and with M Phil or years relevant Teaching Professional experience SCHOOL OF SCIENCES SOS Doctor of Philosophy in Biochemistry Dr Seema Kalra seemakalra ignou ac in Dr Maneesha Pandey maneesha ignou ac in M Sc M Tech M Pharma in Life Sciences Allied Sciences Doctor of Philosophy in Chemistry PHDCHE Prof Sunita Malhotra smalhotra ignou ac in Dr Kamalika Banerjee kamalika ignou ac in MPhil or years Teaching Professional experience with Master Degree in relevant area Doctor of Philosophy in Geography Dr Subhakanta Mohapatra subhakanta ignou ac in MPhil and Post graduate degree in Geography Applied Geography Earth Systems Science relevant discipline of Geospatial Technology fulfilling general eligibility criteria MPhil and Master Degree in a relevant Discipline OR Master Degree in the relevant Discipline with five years of Teaching Research and Professional experience OR Post Graduate Degree in the Disciplines mentioned above and five year experience in Research Teaching Professional experience Research Unit IGNOU Handbook Prospectus PhD MPhil Sl No Name of the Programme Code and Coordinator Doctor of Philosophy in Geology Dr Meenal Mishra meenamishra ignou ac in Eligibility Course Work MPhil and Master Degree in Geology Applied Geology Earth Sciences Marine Geology Hydrogeology OR Master Degree in the above mentioned fields of study and having five years Teaching Research Professional experience Doctor of Philosophy in Life Sciences PHDLS Prof Neera Kapoor neerakapoor ignou ac in MPhil Degree in any area of Life Sciences Botany Zoology Microbiology and Biotechnology and Master Degree in a relevant Discipline OR Master Degree in the relevant discipline and having five years Teaching Research experience in higher education Core Courses Research Methodology Credit Biological Techniques Credit Biostatics and Computer Applications in Biological Research Credit Optional Courses Any Two Molecular Cell Biology Credit Biotechnology Credit Biochemistry Credit Microbial Ecology and Systematics Credit Molecular Microbiology Credit Applied Microbiology Credit Bioinformatics Credit Genomics and Proteomics Credit Insect Biosystematics Credit Insect Pest Management Credit Insect Toxicology Credit Medical Entomology Credit Plant Disease Management Credit Post Harvest Management of Pests and Diseases Credit Natural Plant Products Credit Plant Tissue Culture Credit Genetics Credit Plant Taxonomy Credit Introduction to Nematology Credit Nematological Techniques Credit Research Unit IGNOUHandbook Prospectus PhD MPhil Sl No Name of the Programme Code and Coordinator Eligibility Course Work Nematode Biosystematics Credit Nematode Ecology Credit Medical Genetics Credit Human Physiology Credit Animal Systematics Credit Human Brain and Disorders Credit Cancer Biology Credit Techniques in Animal Biotechnology Credit Biology Education Credit Doctor of Philosophy in Physics PHDPH Dr S Lamba slamba ignou ac in Masters and MPhil Degree in Physics OR Master Degree in relevant discipline and working in recognized College Research Institution and having minimum five years Teaching Research experience SCHOOL OF TRANSLATION STUDIES AND TRAINING SOTST Master Degree in Translation Doctor of Philosophy in Translation Studies PHDTT Studies and MPhil Degree Dr Deo Shankar Navin OR deoshankar hotmail com Master Degree in Translation Dr Jagdish Sharma Studies and five years of jagdishsharma ignou ac in Teaching Research experience Dr Rajendra Pd Pandey OR rajendrapandey ignou ac in Master Degree in Translation Studies or in allied subjects will appear in Entrance Examination All courses are of Credits each Compulsory Courses RTT Research Methodology RTT Translation Theory and Practice RTT Critiquing Translation Any one of the following RTT Translation and Power RTT Translation and Nationalist Movement RTT Translating Women Writing RTT Translating Dalit Writing SCHOOL OF TOURISM AND HOSPITALITY SERVICES MANAGEMENT SOTHSM marks in Post Graduation in RTS Interdisciplinary Doctor of Philosophy in Tourism and Hospitality the relevant field Approaches in Tourism and Services PHDTS Hospitality Candidate with MPhil NET Dr Paramita Suklabaidya Professional experience as RTS Tourism Concepts paramitz ignou ac in validated by the faculty in the RTS Research relevant field would be exempted Methodology in Tourism and from taking the Entrance Hospitality Examination RTS Seminar Presentations Credits each Research Unit IGNOU Handbook Prospectus PhD MPhil Sl No Name of the Programme Code and Coordinator Eligibility Course Work STAFF TRAINING AND RESEARCH IN DISTANCE EDUCATION STRIDE Doctor of Philosophy in Distance Education PHDDE Dr R Satyanarayana rsatyanarayana ignou ac in Post Graduate Degree in any Discipline will appear in Entrance Examination OR Post Graduate Degree in Distance Education with specialization in Educational Technology Instructional Design Education will appear in Entrance Examination OR MPhil or five years of Teaching Professional Administrative experience in Open Distance Learning ODL Credits Exempted for candidates with MPhil Degree or year experience subject to recommendation of the Doctoral Committee Both MPhil and PhD programmes are modular in nature with exit option for MPhil or PhD as the case may be RDE Research Methodology RDE Information and Communication Technology RDE Web based Education RDE Contexts and Concerns of Distance Education RED Term Paper and Seminar SCHOOL OF VOCATIONAL EDUCATION AND TRAINING SOVET Doctor of Philosophy in Vocational Education PHDVED Prof C G Naidu cgnaidu ignou ac in Master Degree and MPhil OR Master Degree and five years Teaching Research Professional experience Research Methodology and Statistical Methods in VET Credits VET Perspectives Credits Planning and Management of VET Credits Instructional and Training Processes in VET Credits Trade Area Specific Course Credits Critical Review of Literature and Contributions in VET Credits LIST OF MASTER OF PHILOSOPHY MPhil PROGRAMMES All will appear in Entrance Examination SCHOOL OF TRANSLATION STUDIES AND TRAINING SOTST Master of Philosophy in Translation Studies MPHILTT M A In Translation Studies The course work details are given in the section on PhD STAFF TRAINING AND RESEARCH IN DISTANCE EDUCATION STRIDE Master of Philosophy in Distance Education MPHILDE Candidates having Masters Degree in a relevant Discipline and fulfilling the general eligibility criteria may apply Course work details are given in the section on PhD Research Unit IGNOUHandbook Prospectus PhD MPhil Appendix RU I Programme Names and Codes Sl No Name of the Programme Programme Code Name of the School Doctor of Philosophy in Agriculture Extension PHDAGE SOA Doctor of Philosophy in Dairy Science and Technology PHDDR SOA Doctor of Philosophy in Child Development PHDCDEV SOCE Doctor of Philosophy in Food and Nutrition PHDFN SOCE Doctor of Philosophy in Computer and Information Sciences PHDCISC SOCIS Doctor of Philosophy in Education PHDEDU SOE Doctor of Philosophy in Civil Engineering PHDCENG SOET Doctor of Philosophy in Mechanical Engineering PHDCMCE SOET Doctor of Philosophy in Gender and Development Studies PHDGDS SOGDS Doctor of Philosophy in Women s Studies PHDWS SOGDS Doctor of Philosophy in Hindi PHDHIN SOH Doctor of Philosophy in English PHDENG SOH Doctor of Philosophy in Nursing PHDNUR SOHS Doctor of Philosophy in Inter disciplinary and Trans disciplinary Studies IPHDAP SOITS Doctor of Philosophy in Commerce PHDCOM SOMS Doctor of Philosophy in Management PHDMGMT SOMS Doctor of Philosophy in Biochemistry To be Allotted SOS Doctor of Philosophy in Chemistry PHDCHE SOS Doctor of Philosophy in Geography To be Allotted SOS Doctor of Philosophy in Geology To be Allotted SOS Doctor of Philosophy in Life Sciences PHDLS SOS Doctor of Philosophy in Physics PHDPH SOS Doctor of Philosophy in Translation Studies PHDTT SOTST Doctor of Philosophy in Tourism and Hospitality PHDTS SOTHSM Doctor of Philosophy in Distance Education PHDDE STRIDE Doctor of Philosophy in Vocational Education PHDVED SOVET Master of Philosophy in Translation Studies MPHILTT SOTST Master of Philosophy in Distance Education MPHILDE STRIDE To be allotted through a Supplementary Communication Research Unit IGNOU Handbook Prospectus PhD MPhil Appendix RU II State Codes Code Description Code Description Andhra Pradesh Mizoram Andaman Nicobar Islands UT Nagaland Arunachal Pradesh Orissa Assam Punjab Bihar Rajasthan Chandigarh UT Sikkim Delhi Tamil Nadu Goa Tripura Gujarat Uttar Pradesh Haryana West Bengal Himachal Pradesh Dadra Nagar Haveli Daman Diu UT Jammu Kashmir Lakshadweep UT Karnataka Pondicherry UT Kerala C o APO Madhya Pradesh Learners Abroad Maharashtra Chattisgarh Manipur Jharkhand Meghalaya Uttarakhand Research Unit IGNOUHandbook Prospectus PhD MPhil Appendix RU III AFFIDAVIT BY THE STUDENT TO BE SUBMIITED ALONGWITH APPLICATION FORM I full name of the student with Admission Registration Enrolment Number S o D o Mr Mrs Ms having been admitted to name of the Institution have received a copy of the UGC Regulations on Curbing the Menace of Ragging in Higher Educational Institutions hereinafter called the Regulations carefully read and fully understand the provisions contained in the said Regulations I have in particular perused Clause of the Regulations and am aware as to what constitutes ragging I have also in particular perused Clause and Clause of the Regulations and am fully aware or the penal and administrative action that is liable to be taken against me in case I am found guilty of or abetting ragging actively or passively or being part of a conspiracy to promote ragging I hereby solemnly aver and undertake that a I will not indulge in any behaviour or act that may be constituted as ragging under Clause of the Regulations b I will not participate in or abet or propagate through any act of commission or omission that may be constituted as ragging under Clause of the Regulations I hereby affirm that if found guilty of ragging I am liable for punishment according to Clause of the Regulations without prejudice to any other criminal action that may be taken against me under any penal law or any law for the time being in force I hereby declare that I have not been expelled or debarred from admission in any institution in the country on account of being found guilty of abetting or being part of a conspiracy to promote ragging and further affirm that in case the declaration is found to be untrue I am aware that my admission is liable to be cancelled Declared this day of month of year Signature of deponent Name Address Tel Mobile No VERIFICATION Verified that the contents of this affidavit are true to the best of my knowledge and no part of the affidavit is false and nothing has been concealed or misstated therein Verified at place this the day of month year Signature of deponent Solemnly affirmed and signed in my presence on this the day of month year after reading the contents of this affidavit OATH COMMISSIONER Research Unit IGNOU Handbook Prospectus PhD MPhil Appendix RU IV AFFIDAVIT BY PARENT GUARDIAN TO BE SUBMIITED ALONGWITH APPLICATION FORM I Mr Mrs Ms full name of Parent Guardian Father Mother Guardian of full name of Student with Admission Registration Enrolment Number having been admitted to name of the institution have received a copy of the UGC Regulations on Curbing the Menace of Ragging in Higher Educational Institutions hereinafter called the Regulations carefully read and fully understand the provisions contained in the said Regulations I have in particular perused Clause of the Regulations and am aware as to what constitutes ragging I have also in particular perused Clause and Clause of the Regulations and am fully aware or the penal and administrative action that is liable to be taken against me in case I am found guilty of or abetting ragging actively or passively or being part of a conspiracy to promote ragging I hereby solemnly aver and undertake that a I will not indulge in any behaviour or act that may be constituted as ragging under Clause of the Regulations b I will not participate in or abet or propagate through any act of commission or omission that may be constituted as ragging under Clause of the Regulations I hereby affirm that if found guilty of ragging I am liable for punishment according to Clause of the Regulations without prejudice to any other criminal action that may be taken against me under any penal law or any law for the time being in force I hereby declare that I have not been expelled or debarred from admission in any institution in the country on account of being found guilty of abetting or being part of a conspiracy to promote ragging and further affirm that in case the declaration is found to be untrue I am aware that my admission is liable to be cancelled Declared this day of month of year Signature of deponent Name Address Tel Mobile No VERIFICATION Verified that the contents of this affidavit are true to the best of my knowledge and no part of the affidavit is false and nothing has been concealed or misstated therein Verified at place this the day of month year Signature of deponent Solemnly affirmed and signed in my presence on this the day of month year after reading the contents of this affidavit OATH COMMISSIONER Research Unit IGNOU Concurrent Programming in JavaTM Design Principles and Patterns SecondEditionBy Doug LeaPublisher Addison WesleyPub Date October ISBN Pages In Concurrent Programming in Java Second Edition you will find thoroughlyupdated coverage of the Java platform and new or expanded coverage of Memory modelCancellationPortable parallel programmingUtility classes for concurrency controlThe Java platform provides a broad and powerful set of APIs tools and technologies One of its most powerful capabilities is the built in support for threads This makesconcurrent programming an attractive yet challenging option for programmers usingthe Java programming language This book shows readers how to use the Java platform s threading model moreprecisely by helping them to understand the patterns and tradeoffs associated withconcurrent programming You will learn how to initiate control and coordinate concurrent activities using theclass java lang Thread the keywords synchronized and volatile and the methods wait notify and notifyAll In addition you will find detailed coverage of all aspects ofconcurrent programming including such topics as confinement and synchronization deadlocks and conflicts state dependent action control asynchronous message passingand control flow coordinated interaction and structuring web based andcomputational services The book targets intermediate to advanced programmers interested in mastering thecomplexities of concurrent programming Taking a design pattern approach the bookoffers standard design techniques for creating and implementing components thatsolve common concurrent programming challenges The numerous code examplesthroughout help clarify the subtleties of the concurrent programming conceptsdiscussed CopyrightAcknowledgmentsChapter Concurrent Object Oriented ProgrammingSection Using Concurrency ConstructsSection Objects and ConcurrencySection Design ForcesSection Before After PatternsChapter ExclusionSection ImmutabilitySection SynchronizationSection ConfinementSection Structuring and Refactoring ClassesSection Using Lock UtilitiesChapter State DependenceSection Dealing with FailureSection Guarded MethodsSection Structuring and Refactoring ClassesSection Using Concurrency Control UtilitiesSection Joint ActionsSection TransactionsSection Implementing UtilitiesChapter Creating ThreadsSection Oneway MessagesSection Composing Oneway MessagesSection Services in ThreadsSection Parallel DecompositionSection Active ObjectsCopyrightMany of the designations used by manufacturers and sellers to distinguish their products are claimedas trademarks Where those designations appear in this book and Addison Wesley was aware of atrademark claim the designations have been printed in initial caps or all caps DukeTM designed by Joe Palrang Sun Microsystems Inc has intellectual property rights relating to implementations of the technologydescribed in this publication In particular and without limitation these intellectual property rightsmay include one or more U S patents foreign patents or pending applications Sun SunMicrosystems the Sun Logo and all Sun Java Jini and Solaris based trademarks and logos aretrademarks or registered trademarks of Sun Microsystems Inc in the United States and othercountries UNIX is a registered trademark in the United States and other countries exclusivelylicensed through X Open Company Ltd As used in this book the terms Java virtual machine and JVM mean a virtual machine for the Javaplatform THIS PUBLICATION IS PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND EITHEREXPRESS OR IMPLIED INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIESOF MERCHANTABILITY FITNESS FOR A PARTICULAR PURPOSE OR NON INFRINGEMENT THIS PUBLICATION COULD INCLUDE TECHNICAL INACCURACIES ORTYPOGRAPHICAL ERRORS CHANGES ARE PERIODICALLY ADDED TO THEINFORMATION HEREIN THESE CHANGES WILL BE INCORPORATED IN NEW EDITIONSOF THE PUBLICATION SUN MICROSYSTEMS INC MAY MAKE IMPROVEMENTSAND OR CHANGES IN ANY TECHNOLOGY PRODUCT OR PROGRAM DESCRIBED INTHIS PUBLICATION AT ANY TIME The author and publisher have taken care in the preparation of this document but make no expressedor implied warranty of any kind and assume no responsibility for errors or omissions No liability isassumed for incidental or consequential damages in connection with or arising out of the use of theinformation or programs contained herein Library of Congress Card Number Copyright by Addison Wesley Longman Inc All rights reserved No part of this publicationmay be reproduced stored in a retrieval system or transmitted in any form or by any means electronic mechanical photocopying recording or otherwise without the prior consent of thepublisher Printed in the United States of America Published simultaneously in Canada Text printed on recycled and acid free paper MA Second printing November AcknowledgmentsThis book began as a small set of Web pages that I put together in spring while trying to makesense of my own early attempts to use Java concurrency features in experimental development efforts Then it grew first on the World Wide Web where I extended expanded and removed patterns toreflect my and other people s increasing experience with Java concurrency and now into this book which places patterns within the broader perspective of concurrent software development The webpages also live on but they now serve as a supplement to the conceptual presentations best suited tobook form There have been many changes along the way in a process that has benefited from commentary suggestions errata reports and exchanges with many kind and knowledgeable people These includeOle Agesen Tatsuya Aoyagi Taranov Alexander Moti Ben Ari Peter Buhr Bruce Chapman Il Hyung Cho Colin Cooper Kelly Davis Bruce Eckel Yacov Eckel Saleh Elmohamed Ed Falis Randy Farmer Glenn Goldstein David Hanson Jyrki Heikkinen Alain Hsiung Jerry James Johannes Johannsen Istvan Kiss Ross Knippel Bil Lewis Sheng Liang Jonathan Locke SteveMacDonald Hidehiko Masuhara Arnulf Mester Mike Mills Trevor Morris Bill Pugh AndrewPurshottam Simon Roberts John Rose Rodney Ryan Joel Rosi Schwartz Miles Sabin Aamod Sane Beverly Sanders Doug Schmidt Kevin Shank Yukari Shirota David Spitz David Stoutamire HenryStory Sumana Srinivasan Satish Subramanian Jeff Swartz Patrick Thompson Volker Turau DennisUlrich Cees Vissar Bruce Wallace Greg Wilson Grant Woodside Steve Yen and Dave Yost aswell as people who submitted anonymous electronic mail commentary The members of Ralph Johnson s patterns seminar especially Brian Foote and Ian Chai read throughearly forms of some patterns and suggested many improvements Raj Datta Sterling Barrett andPhilip Eskelin of the New York City Patterns Group and Russ Rufer Ming Kwok Mustafa Ozgen Edward Anderson and Don Chin of the Silicon Valley Patterns Group performed similar valuableservice for preliminary versions of the second edition Official and unofficial reviewers of the first and second edition manuscripts made helpful commentsand suggestions on tight schedules They include Ken Arnold Josh Bloch Joseph Bowbeer PatrickChan Gary Craig Desmond D Souza Bill Foote Tim Harrison David Henderson Tim Lindholm Tom May Oscar Nierstrasz James Robins Greg Travis Mark Wales Peter Welch and DeborraZukowski Very special thanks go to Tom Cargill for his many insights and corrections as well as forpermission to include a description of his Specific Notification pattern Very special thanks also go toDavid Holmes for among many contributions helping to develop and extend material for tutorialsthat in turn became included in the second edition Rosemary Simpson contributed numerous improvements in the course of creating the index KenArnold patiently helped me deal with FrameMaker Mike Hendrickson and the editorial crew atAddison Wesley have been continually supportive This book would not have been possible without the generous support of Sun Labs Thanks especiallyto Jos Marlowe and Steve Heller for providing opportunities to work collaboratively on fun andexciting research and development projects Thanks above all to Kathy Keith and Colin for tolerating all this Doug Lea September Chapter Concurrent Object Oriented ProgrammingThis book discusses some ways of thinking about designing and implementing concurrent programsin the JavaTM programming language Most presentations in this book assume that you are anexperienced developer familiar with object oriented OO programming but have little exposure toconcurrency Readers with the opposite background experience with concurrency in otherlanguages may also find this book useful The book is organized into four coarse grained chapters Perhaps parts would be a better term Thisfirst chapter begins with a brief tour of some frequently used constructs and then backs up to establisha conceptual basis for concurrent object oriented programming how concurrency and objects fittogether how the resulting design forces impact construction of classes and components and howsome common design patterns can be used to structure solutions The three subsequent chapters are centered around use and evasion of the three kinds of concurrencyconstructs found in the Java programming language Exclusion Maintaining consistent states of objects by preventing unwanted interference amongconcurrent activities often using synchronized methods State dependence Triggering preventing postponing or recovering from actions depending onwhether objects are in states in which these actions could or did succeed sometimes using monitormethods Object wait Object notify and Object notifyAll Creating threads Establishing and managing concurrency using Thread objects Each chapter contains a sequence of major sections each on an independent topic They present high level design principles and strategies technical details surrounding constructs utilities thatencapsulate common usages and associated design patterns that address particular concurrencyproblems Most sections conclude with an annotated set of further readings providing moreinformation on selected topics The online supplement to this book contains links to additional onlineresources as well as updates errata and code examples It is accessible via links from http java sun com Series or http gee cs oswego edu dl cpjIf you are already familiar with the basics you can read this book in the presented order to exploreeach topic in more depth But most readers will want to read this book in various different orders Because most concurrency concepts and techniques interact with most others it is not always possibleto understand each section or chapter in complete isolation from all the others However you can stilltake a breadth first approach briefly scanning each chapter including this one before proceedingwith more detailed coverage of interest Many presentations later in the book can be approached afterselectively reading through earlier material indicated by extensive cross references You can practice this now by skimming through the following preliminaries Terminology This book uses standard OO terminological conventions programs define methods implementing operations and fields representing attributes that hold for all instances objects ofspecified classes Interactions in OO programs normally revolve around the responsibilities placed upon a client objectneeding an action to be performed and a server object containing the code to perform the action Theterms client and server are used here in their generic senses not in the specialized sense of distributedclient server architectures A client is just any object that sends a request to another object and aserver is just any object receiving such a request Most objects play the roles of both clients andservers In the usual case where it doesn t matter whether an object under discussion acts as a client orserver or both it is usually called a host others that it may in turn interact with are often calledhelpers or peers Also when discussing invocations of the form obj msg arg the recipient that is the object bound to variable obj is called the target object This book generally avoids dealing with transient facts about particular classes and packages notdirectly related to concurrency And it does not cover details about concurrency control in specializedframeworks such as Enterprise JavaBeansTM and Servlets But it does sometimes refer to brandedsoftware and trademarked products associated with the JavaTM Platform The copyright page of thisbook provides more information Code listings Most techniques and patterns in this book are illustrated by variants of an annoyinglysmall set of toy running examples This is not an effort to be boring but to be clear Concurrencyconstructs are often subtle enough to get lost in otherwise meaningful examples Reuse of runningexamples makes small but critical differences more obvious by highlighting the main design andimplementation issues Also the presentations include code sketches and fragments of classes thatillustrate implementation techniques but are not intended to be complete or even compilable Theseclasses are indicated by leading comments in the listings Import statements access qualifiers and even methods and fields are sometimes omitted from listingswhen they can be inferred from context or do not impact relevant functionality The protectedqualifier is used as a default for non public features whenever there is no particular reason to restrictsubclass access This emphasizes opportunities for extensibility in concurrent class design see and Classes by default have no access qualifier Sample listings are sometimes formatted innonstandard ways to keep them together on pages or to emphasize the main constructions of interest The code for all example classes in this book is available from the online supplement Most techniquesand patterns in this book are illustrated by a single code example showing their most typical forms The supplement includes additional examples that demonstrate minor variations as well as some linksto other known usages It also includes some larger examples that are more useful to browse andexperiment with online than to read as listings The supplement provides links to a package util concurrent that contains production quality versions of utility classes discussed in this book This code runs on the Java Platform and hasbeen tested with x releases Occasional discussions asides and footnotes briefly mention changesfrom previous releases potential future changes known at the time of this writing and a fewimplementation quirks to watch out for Check the online supplement for additional updates Diagrams Standard UML notation is used for interaction and class diagrams see the FurtherReadings in The accompanying diagrams courtesy of Martin Fowler illustrate the onlyforms used in this book Other aspects of UML notation methodology and terminology are notspecifically relied on Most other diagrams show timethreads in which free form gray curves trace threads traversingthrough collections of objects Flattened arrowheads represent blocking Objects are depicted as ovalsthat sometimes show selected internal features such as locks fields and bits of code Thin usuallylabeled lines between objects represent relations normally references or potential calls betweenthem Here s an otherwise meaningless example showing that thread A has acquired the lock for objectX and is proceeding through some method in object Y that serves as a helper to X Thread B ismeanwhile somehow blocked while entering some method in object X Using Concurrency ConstructsThis section introduces basic concurrency support constructs by example and then proceeds with awalk through of the principal methods of class Thread Other concurrency constructs are brieflydescribed as they are introduced but full technical details are postponed to later chapters mainly and Also concurrent programs often make use of a few ordinary Java programminglanguage features that are not as widely used elsewhere These are briefly reviewed as they arise A Particle AppletParticleApplet is an Applet that displays randomly moving particles In addition toconcurrency constructs this example illustrates a few of the issues encountered when using threadswith any GUI based program The version described here needs a lot of embellishment to be visuallyattractive or realistic You might enjoy experimenting with additions and variations as an exercise As is typical of GUI based programs ParticleApplet uses several auxiliary classes that domost of the work We ll step through construction of the Particle and ParticleCanvasclasses before discussing ParticleApplet ParticleThe Particle class defines a completely unrealistic model of movable bodies Each particle isrepresented only by its x y location Each particle also supports a method to randomly change itslocation and a method to draw itself as a small square given a supplied java awt Graphicsobject While Particle objects do not themselves exhibit any intrinsic concurrency their methods may beinvoked across multiple concurrent activities When one activity is performing a move and another isinvoking draw at about the same time we d like to make sure that the draw paints an accuraterepresentation of where the Particle is Here we require that draw uses the location valuescurrent either before or after the move For example it would be conceptually wrong for a drawoperation to display using the y value current before a given move but the x value current after themove If we were to allow this then the draw method would sometimes display the particle at alocation that it never actually occupied This protection can be obtained using the synchronized keyword which can modify either amethod or a block of code Every instance of class Object and its subclasses possesses a lock thatis obtained on entry to a synchronized method and automatically released upon exit The code block version works in the same way except that it takes an argument stating which object to lock Themost common argument is this meaning to lock the object whose method is executing When alock is held by one thread other threads must block waiting for the holding thread to release the lock Locking has no effect on non synchronized methods which can execute even if the lock is being heldby another thread Locking provides protection against both high level and low level conflicts by enforcing atomicityamong methods and code blocks synchronized on the same object Atomic actions areperformed as units without any interleaving of the actions of other threads But as discussed in and in Chapter too much locking can also produce liveness problems that cause programs tofreeze up Rather than exploring these issues in detail now we ll rely on some simple default rules forwriting methods that preclude interference problems Always lock during updates to object fields Always lock during access of possibly updated object fields Never lock when invoking methods on other objects These rules have many exceptions and refinements but they provide enough guidance to write classParticle import java util Random class Particle protected int x protected int y protected final Random rng new Random public Particle int initialX int initialY x initialX y initialY public synchronized void move x rng nextInt y rng nextInt public void draw Graphics g int lx ly synchronized this lx x ly y g drawRect lx ly Notes The use of final in the declaration of the random number generator rng reflects ourdecision that this reference field cannot be changed so it is not impacted by our locking rules Many concurrent programs use final extensively in part as helpful automaticallyenforced documentation of design decisions that reduce the need for synchronization see The draw method needs to obtain a consistent snapshot of both the x and y values Since asingle method can return only one value at a time and we need both the x and y values here we cannot easily encapsulate the field accesses as a synchronized method We insteaduse a synchronized block See for some alternatives The draw method conforms to our rule of thumb to release locks during method invocationson other objects here g drawRect The move method appears to break this rule bycalling rng nextInt However this is a reasonable choice here because eachParticle confines its own rng conceptually the rng is just a part of theParticle itself so it doesn t count as an other object in the rule Section describesmore general conditions under which this sort of reasoning applies and discusses factors thatshould be taken into account to be sure that this decision is warranted ParticleCanvasParticleCanvas is a simple subclass of java awt Canvas that provides a drawing areafor all of the Particles Its main responsibility is to invoke draw for all existing particleswhenever its paint method is called However the ParticleCanvas itself does not create or manage the particles It needs either tobe told about them or to ask about them Here we choose the former The instance variable particles holds the array of existing Particle objects This field is setwhen necessary by the applet but is used in the paint method We can again apply our defaultrules which in this case lead to the creation of little synchronized get and set methods alsoknown as accessor and assignment methods for particles otherwise avoiding direct access ofthe particles variable itself To simplify and to enforce proper usage the particles field isnever allowed to be null It is instead initialized to an empty array class ParticleCanvas extends Canvas private Particle particles new Particle ParticleCanvas int size setSize new Dimension size size intended to be called by appletprotected synchronized void setParticles Particle ps if ps null throw new IllegalArgumentException Cannot set null particles ps protected synchronized Particle getParticles return particles public void paint Graphics g override Canvas paintParticle ps getParticles for int i i ps length i ps i draw g ParticleAppletThe Particle and ParticleCanvas classes could be used as the basis of several differentprograms But in ParticleApplet all we want to do is set each of a collection of particles inautonomous continuous motion and update the display accordingly to show where they are Tocomply with standard applet conventions these activities should begin when Applet start isexternally invoked normally from within a web browser and should end when Applet stop isinvoked We could also add buttons allowing users to start and stop the particle animationthemselves There are several ways to implement all this Among the simplest is to associate an independent loopwith each particle and to run each looping action in a different thread Actions to be performed within new threads must be defined in classes implementingjava lang Runnable This interface lists only the single method run taking no arguments returning no results and throwing no checked exceptions public interface java lang Runnable void run An interface encapsulates a coherent set of services and attributes broadly a role withoutassigning this functionality to any particular object or code Interfaces are more abstract than classessince they say nothing at all about representations or code All they do is describe the signatures names arguments result types and exceptions of public operations without even pinning down theclasses of the objects that can perform them The classes that can support Runnable typically havenothing in common except that they contain a run method Each instance of the Thread class maintains the control state necessary to execute and manage thecall sequence comprising its action The most commonly used constructor in class Thread accepts aRunnable object as an argument which arranges to invoke the Runnable s run method whenthe thread is started While any class can implement Runnable it often turns out to be bothconvenient and helpful to define a Runnable as an anonymous inner class The ParticleApplet class uses threads in this way to put particles into motion and cancelsthem when the applet is finished This is done by overriding the standard Applet methods startand stop which have the same names as but are unrelated to methods Thread start andThread stop The above interaction diagram shows the main message sequences during execution of the applet Inaddition to the threads explicitly created this applet interacts with the AWT event thread described inmore detail in The producer consumer relationship extending from the omitted right hand sideof the interaction diagram takes the approximate form public class ParticleApplet extends Applet protected Thread threads null null when not runningprotected final ParticleCanvas canvas new ParticleCanvas public void init add canvas protected Thread makeThread final Particle p utilityRunnable runloop new Runnable public void run try for p move canvas repaint Thread sleep msec is arbitrary catch InterruptedException e return return new Thread runloop public synchronized void start int n just for demoif threads null bypass if already startedParticle particles new Particle n for int i i n i particles i new Particle canvas setParticles particles threads new Thread n for int i i n i threads i makeThread particles i threads i start public synchronized void stop if threads null bypass if already stoppedfor int i i threads length i threads i interrupt threads null Notes The action in makeThread defines a forever loop which some people prefer to writeequivalently as while true that is broken only when the current thread isinterrupted During each iteration the particle moves tells the canvas to repaint so the movewill be displayed and then does nothing for a while to slow things down to a human viewable rate Thread sleep pauses the current thread It is later resumed by a systemtimer One reason that inner classes are convenient and useful is that they capture all appropriatecontext variables here p and canvas without the need to create a separate class withfields that record these values This convenience comes at the price of one minorawkwardness All captured method arguments and local variables must be declared asfinal as a guarantee that the values can indeed be captured unambiguously Otherwise forexample if p were reassigned after constructing the Runnable inside methodmakeThread then it would be ambiguous whether to use the original or the assignedvalue when executing the Runnable The call to canvas repaint does not directly invoke canvas paint Therepaint method instead places an UpdateEvent on a java awt EventQueue This may be internally optimized and further manipulated to eliminate duplicate events Ajava awt EventDispatchThread asynchronously takes this event from the queueand dispatches it by ultimately invoking canvas paint This thread and possibly othersystem created threads may exist even in nominally single threaded programs The activity represented by a constructed Thread object does not begin until invocation ofthe Thread start method As discussed in there are several ways to cause a thread s activity to stop Thesimplest is just to have the run method terminate normally But in infinitely loopingmethods the best option is to use Thread interrupt An interrupted thread willautomatically abort via an InterruptedException from the methodsObject wait Thread join and Thread sleep Callers can then catch thisexception and take any appropriate action to shut down Here the catch in runloop justcauses the run method to exit which in turn causes the thread to terminate The start and stop methods are synchronized to preclude concurrent starts orstops Locking works out OK here even though these methods need to perform manyoperations including calls to other objects to achieve the required started to stopped orstopped to started state transitions Nullness of variable threads is used as a convenientstate indicator Thread MechanicsA thread is a call sequence that executes independently of others while at the same time possiblysharing underlying system resources such as files as well as accessing other objects constructedwithin the same program see A java lang Thread object maintains bookkeeping andcontrol for this activity Every program consists of at least one thread the one that runs the main method of the classprovided as a startup argument to the Java virtual machine JVM Other internal backgroundthreads may also be started during JVM initialization The number and nature of such threads varyacross JVM implementations However all user level threads are explicitly constructed and startedfrom the main thread or from any other threads that they in turn create Here is a summary of the principal methods and properties of class Thread as well as a few usagenotes They are further discussed and illustrated throughout this book The JavaTM LanguageSpecification JLS and the published API documentation should be consulted for more detailed andauthoritative descriptions ConstructionDifferent Thread constructors accept combinations of arguments supplying A Runnable object in which case a subsequent Thread start invokes run of thesupplied Runnable object If no Runnable is supplied the default implementation ofThread run returns immediately A String that serves as an identifier for the Thread This can be useful for tracing anddebugging but plays no other role The ThreadGroup in which the new Thread should be placed If access to theThreadGroup is not allowed a SecurityException is thrown Class Thread itself implements Runnable So rather than supplying the code to be run in aRunnable and using it as an argument to a Thread constructor you can create a subclass ofThread that overrides the run method to perform the desired actions However the best defaultstrategy is to define a Runnable as a separate class and supply it in a Thread constructor Isolating code within a distinct class relieves you of worrying about any potential interactions ofsynchronized methods or blocks used in the Runnable with any that may be used bymethods of class Thread More generally this separation allows independent control over the natureof the action and the context in which it is run The same Runnable can be supplied to threads thatare otherwise initialized in different ways as well as to other lightweight executors see Alsonote that subclassing Thread precludes a class from subclassing any other class Thread objects also possess a daemon status attribute that cannot be set via any Threadconstructor but may be set only before a Thread is started The method setDaemon asserts thatthe JVM may exit abruptly terminating the thread so long as all other non daemon threads in theprogram have terminated The isDaemon method returns status The utility of daemon status is verylimited Even background threads often need to do some cleanup upon program exit The spelling ofdaemon often pronounced as day mon is a relic of systems programming tradition Systemdaemons are continuous processes for example print queue managers that are always present on asystem Starting threadsInvoking its start method causes an instance of class Thread to initiate its run method as anindependent activity None of the synchronization locks held by the caller thread are held by the newthread see A Thread terminates when its run method completes by either returning normally or throwing anunchecked exception i e RuntimeException Error or one of their subclasses Threadsare not restartable even after they terminate Invoking start more than once results in anInvalidThreadStateException The method isAlive returns true if a thread has been started but has not terminated It willreturn true if the thread is merely blocked in some way JVM implementations have been known todiffer in the exact point at which isAlive returns false for threads that have been cancelled see There is no method that tells you whether a thread that is not isAlive has ever beenstarted Also one thread cannot readily determine which other thread started it although it maydetermine the identities of other threads in its ThreadGroup see PrioritiesTo make it possible to implement the Java virtual machine across diverse hardware platforms andoperating systems the Java programming language makes no promises about scheduling or fairness and does not even strictly guarantee that threads make forward progress see But threads dosupport priority methods that heuristically influence schedulers Each Thread has a priority ranging between Thread MIN PRIORITY andThread MAX PRIORITY defined as and respectively By default each new thread has the same priority as the thread that created it The initialthread associated with a main by default has priority Thread NORM PRIORITY The current priority of any thread can be accessed via method getPriority The priority of any thread can be dynamically changed via method setPriority Themaximum allowed priority for a thread is bounded by its ThreadGroup When more runnable see threads than available CPUs a scheduler is generally biased toprefer running those with higher priorities The exact policy may and does vary across platforms Forexample some JVM implementations always select the thread with the highest current priority withties broken arbitrarily Some JVM implementations map the ten Thread priorities into a smallernumber of system supported categories so threads with different priorities may be treated equally And some mix declared priorities with aging schemes or other scheduling policies to ensure that evenlow priority threads eventually get a chance to run Also setting priorities may but need not affectscheduling with respect to other programs running on the same computer system Priorities have no other bearing on semantics or correctness see In particular prioritymanipulations cannot be used as a substitute for locking Priorities can be used only to express therelative importance or urgency of different threads where these priority indications would be useful totake into account when there is heavy contention among threads trying to get a chance to execute Forexample setting the priorities of the particle animation threads in ParticleApplet below that ofthe applet thread constructing them might on some systems improve responsiveness to mouse clicks and would at least not hurt responsiveness on others But programs should be designed to run correctly although perhaps not as responsively even if setPriority is defined as a no op Similarremarks hold for yield see The following table gives one set of general conventions for linking task categories to prioritysettings In many concurrent applications relatively few threads are actually runnable at any giventime others are all blocked in some way in which case there is little reason to manipulate priorities In other cases minor tweaks in priority settings may play a small part in the final tuning of aconcurrent system Range UseCrisis managementInteractive event drivenIO boundBackground computation Run only if nothing else can Control methodsOnly a few methods are available for communicating across threads Each Thread has an associated boolean interruption status see Invokingt interrupt for some Thread t sets t s interruption status to true unlessThread t is engaged in Object wait Thread sleep or Thread join inthis case interrupt causes these actions in t to throw InterruptedException but t s interruption status is set to false The interruption status of any Thread can be inspected using method isInterrupted This method returns true if the thread has been interrupted via the interrupt methodbut the status has not since been reset either by the thread invokingThread interrupted see or in the course of wait sleep or jointhrowing InterruptedException Invoking t join for Thread t suspends the caller until the target Thread tcompletes the call to t join returns when t isAlive is false see A version with a millisecond time argument returns control even if the thread has notcompleted within the specified time limit Because of how isAlive is defined it makes nosense to invoke join on a thread that has not been started For similar reasons it is unwiseto try to join a Thread that you did not create Originally class Thread supported the additional control methods suspend resume stop and destroy Methods suspend resume and stop have since been deprecated methoddestroy has never been implemented in any release and probably never will be The effects ofmethods suspend and resume can be obtained more safely and reliably using the waiting andnotification techniques discussed in The problems surrounding stop are discussed in Static methodsSome Thread class methods can be applied only to the thread that is currently running i e thethread making the call to the Thread method To enforce this these methods are declared asstatic Thread currentThread returns a reference to the current Thread This referencemay then be used to invoke other non static methods For example Thread currentThread getPriority returns the priority of the threadmaking the call Thread interrupted clears interruption status of the current Thread and returnsprevious status Thus one Thread s interruption status cannot be cleared from otherthreads Thread sleep long msecs causes the current thread to suspend for at leastmsecs milliseconds see Thread yield is a purely heuristic hint advising the JVM that if there are any otherrunnable but non running threads the scheduler should run one or more of these threadsrather than the current thread The JVM may interpret this hint in any way it likes Despite the lack of guarantees yield can be pragmatically effective on some single CPU JVMimplementations that do not use time sliced pre emptive scheduling see In this case threadsare rescheduled only when one blocks for example on IO or via sleep On these systems threadsthat perform time consuming non blocking computations can tie up a CPU for extended periods decreasing the responsiveness of an application As a safeguard methods performing non blockingcomputations that might exceed acceptable response times for event handlers or other reactive threadscan insert yields or perhaps even sleeps and when desirable also run at lower prioritysettings To minimize unnecessary impact you can arrange to invoke yield only occasionally forexample a loop might contain if Math random Thread yield On JVM implementations that employ pre emptive scheduling policies especially those onmultiprocessors it is possible and even desirable that the scheduler will simply ignore this hintprovided by yield ThreadGroupsEvery Thread is constructed as a member of a ThreadGroup by default the same group as thatof the Thread issuing the constructor for it ThreadGroups nest in a tree like fashion When anobject constructs a new ThreadGroup it is nested under its current group The methodgetThreadGroup returns the group of any thread The ThreadGroup class in turn supportsmethods such as enumerate that indicate which threads are currently in the group One purpose of class ThreadGroup is to support security policies that dynamically restrict accessto Thread operations for example to make it illegal to interrupt a thread that is not in yourgroup This is one part of a set of protective measures against problems that could occur for example if an applet were to try to kill the main screen display update thread ThreadGroups may alsoplace a ceiling on the maximum priority that any member thread can possess ThreadGroups tend not to be used directly in thread based programs In most applications normal collection classes for example java util Vector are better choices for trackinggroups of Thread objects for application dependent purposes Among the few ThreadGroup methods that commonly come into play in concurrent programs ismethod uncaughtException which is invoked when a thread in a group terminates due to anuncaught unchecked exception for example a NullPointerException This methodnormally causes a stack trace to be printed Further ReadingsThis book is not a reference manual on the Java programming language It is also not exclusively ahow to tutorial guide or an academic textbook on concurrency or a report on experimental research or a book on design methodology or design patterns or pattern languages but includes discussions oneach of these facets of concurrency Most sections conclude with lists of resources that provide moreinformation on selected topics If you do a lot of concurrent programming you will want to read moreabout some of them The JLS should be consulted for more authoritative accounts of the properties of Java programminglanguage constructs summarized in this book Gosling James Bill Joy and Guy Steele The JavaTM Language Specification Addison Wesley As of this writing a second edition of JLS is projected to contain clarifications and updates forthe Java Platform Introductory accounts include Arnold Ken and James Gosling The JavaTM Programming Language Second Edition Addison Wesley If you have never written a program using threads you may find it useful to work through either theonline or book version of the Threads section of Campione Mary and Kathy Walrath The JavaTM Tutorial Second Edition Addison Wesley A concise guide to UML notation is Fowler Martin with Kendall Scott UML Distilled Second Edition Addison Wesley TheUML diagram keys on pages of the present book are excerpted by permission A more extensive account of UML is Rumbaugh James Ivar Jacobson and Grady Booch The Unified Modeling Language ReferenceManual Addison Wesley Objects and ConcurrencyThere are many ways to characterize objects concurrency and their relationships This sectiondiscusses several different perspectives definitional system based stylistic and modeling based that together help establish a conceptual basis for concurrent object oriented programming ConcurrencyLike most computing terms concurrency is tricky to pin down Informally a concurrent program isone that does more than one thing at a time For example a web browser may be simultaneouslyperforming an HTTP GET request to get an HTML page playing an audio clip displaying the numberof bytes received of some image and engaging in an advisory dialog with a user However thissimultaneity is sometimes an illusion On some computer systems these different activities mightindeed be performed by different CPUs But on other systems they are all performed by a single time shared CPU that switches among different activities quickly enough that they appear to besimultaneous or at least nondeterministically interleaved to human observers A more precise though not very interesting definition of concurrent programming can be phrasedoperationally A Java virtual machine and its underlying operating system OS provide mappingsfrom apparent simultaneity to physical parallelism via multiple CPUs or lack thereof by allowingindependent activities to proceed in parallel when possible and desirable and otherwise by time sharing Concurrent programming consists of using programming constructs that are mapped in thisway Concurrent programming in the Java programming language entails using Java programminglanguage constructs to this effect as opposed to system level constructs that are used to create newoperating system processes By convention this notion is further restricted to constructs affecting asingle JVM as opposed to distributed programming for example using remote method invocation RMI that involves multiple JVMs residing on multiple computer systems Concurrency and the reasons for employing it are better captured by considering the nature of a fewcommon types of concurrent applications Web services Most socket based web services for example HTTP daemons servlet engines andapplication servers are multithreaded Usually the main motivation for supporting multipleconcurrent connections is to ensure that new incoming connections do not need to wait out completionof others This generally minimizes service latencies and improves availability Number crunching Many computation intensive tasks can be parallelized and thus execute morequickly if multiple CPUs are present Here the goal is to maximize throughput by exploitingparallelism I O processing Even on a nominally sequential computer devices that perform reads and writes ondisks wires etc operate independently of the CPU Concurrent programs can use the time otherwisewasted waiting for slow I O and can thus make more efficient use of a computer s resources Simulation Concurrent programs can simulate physical objects with independent autonomousbehaviors that are hard to capture in purely sequential programs GUI based applications Even though most user interfaces are intentionally single threaded theyoften establish or communicate with multithreaded services Concurrency enables user controls to stayresponsive even during time consuming actions Component based software Large granularity software components for example those providingdesign tools such as layout editors may internally construct threads in order to assist in bookkeeping provide multimedia support achieve greater autonomy or improve performance Mobile code Frameworks such as the java applet package execute downloaded code inseparate threads as one part of a set of policies that help to isolate monitor and control the effects ofunknown code Embedded systems Most programs running on small dedicated devices perform real time control Multiple components each continuously react to external inputs from sensors or other devices andproduce external outputs in a timely manner As defined in The JavaTM Language Specification theJava platform does not support hard real time control in which system correctness depends on actionsbeing performed by certain deadlines Particular run time systems may provide the strongerguarantees required in some safety critical hard real time systems But all JVM implementationssupport soft real time control in which timeliness and performance are considered quality of serviceissues rather than correctness issues see This reflects portability goals that enable the JVM tobe implemented on modern opportunistic multipurpose hardware and system software Concurrent Execution ConstructsThreads are only one of several constructs available for concurrently executing code The idea ofgenerating a new activity can be mapped to any of several abstractions along a granularity continuumreflecting trade offs of autonomy versus overhead Thread based designs do not always provide thebest solution to a given concurrency problem Selection of one of the alternatives discussed below canprovide either more or less security protection fault tolerance and administrative control with eithermore or less associated overhead Differences among these options and their associated programmingsupport constructs impact design strategies more than do any of the details surrounding each one Computer systemsIf you had a large supply of computer systems you might map each logical unit of execution to adifferent computer Each computer system may be a uniprocessor a multiprocessor or even a clusterof machines administered as a single unit and sharing a common operating system This providesunbounded autonomy and independence Each system can be administered and controlled separatelyfrom all the others However constructing locating reclaiming and passing messages among such entities can beexpensive opportunities for sharing local resources are eliminated and solutions to problemssurrounding naming security fault tolerance recovery and reachability are all relatively heavy incomparison with those seen in concurrent programs So this mapping choice is typically applied onlyfor those aspects of a system that intrinsically require a distributed solution And even here all but thetiniest embedded computer devices host more than one process ProcessesA process is an operating system abstraction that allows one computer system to support many unitsof execution Each process typically represents a separate running program for example an executingJVM Like the notion of a computer system a process is a logical abstraction not a physical one So for example bindings from processes to CPUs may vary dynamically Operating systems guarantee some degree of independence lack of interference and security amongconcurrently executing processes Processes are generally not allowed to access one another s storagelocations although there are usually some exceptions and must instead communicate viainterprocess communication facilities such as pipes Most systems make at least best effort promisesabout how processes will be created and scheduled This nearly always entails pre emptive time slicing suspending processes on a periodic basis to give other processes a chance to run The overhead for creating managing and communicating among processes can be a lot lower than inper machine solutions However since processes share underlying computational resources CPUs memory IO channels and so on they are less autonomous For example a machine crash caused byone process kills all processes ThreadsThread constructs of various forms make further trade offs in autonomy in part for the sake of loweroverhead The main trade offs are Sharing Threads may share access to the memory open files and other resources associated with asingle process Threads in the Java programming language may share all such resources Someoperating systems also support intermediate constructions for example lightweight processes and kernel threads that share only some resources do so only upon explicit request or impose otherrestrictions Scheduling Independence guarantees may be weakened to support cheaper scheduling policies Atone extreme all threads can be treated together as a single threaded process in which case they maycooperatively contend with each other so that only one thread is running at a time without giving anyother thread a chance to run until it blocks see At the other extreme the underlyingscheduler can allow all threads in a system to contend directly with each other via pre emptivescheduling rules Threads in the Java programming language may be scheduled using any policy lyingat or anywhere between these extremes Communication Systems interact via communication across wires or wireless channels for exampleusing sockets Processes may also communicate in this fashion but may also use lighter mechanismssuch as pipes and interprocess signalling facilities Threads can use all of these options plus othercheaper strategies relying on access to memory locations accessible across multiple threads andemploying memory based synchronization facilities such as locks and waiting and notificationmechanisms These constructs support more efficient communication but sometimes incur theexpense of greater complexity and consequently greater potential for programming error Tasks and lightweight executable frameworksThe trade offs made in supporting threads cover a wide range of applications but are not alwaysperfectly matched to the needs of a given activity While performance details differ across platforms the overhead in creating a thread is still significantly greater than the cheapest but least independent way to invoke a block of code calling it directly in the current thread When thread creation and management overhead become performance concerns you may be able tomake additional trade offs in autonomy by creating your own lighter weight execution frameworksthat impose further restrictions on usage for example by forbidding use of certain forms of blocking or make fewer scheduling guarantees or restrict synchronization and communication to a morelimited set of choices As discussed in these tasks can then be mapped to threads in about thesame way that threads are mapped to processes and computer systems The most familiar lightweight executable frameworks are event based systems and subsystems see and in which calls triggering conceptually asynchronous activities aremaintained as events that may be queued and processed by background threads Several additionallightweight executable frameworks are described in Chapter When they apply construction and useof such frameworks can improve both the structure and performance of concurrent programs Theiruse reduces concerns see that can otherwise inhibit the use of concurrent executiontechniques for expressing logically asynchronous activities and logically autonomous objects see Concurrency and OO ProgrammingObjects and concurrency have been linked since the earliest days of each The first concurrent OOprogramming language created circa Simula was also the first OO language and was amongthe first concurrent languages Simula s initial OO and concurrency constructs were somewhatprimitive and awkward For example concurrency was based around coroutines thread likeconstructs requiring that programmers explicitly hand off control from one task to another Severalother languages providing both concurrency and OO constructs followed indeed even some of theearliest prototype versions of C included a few concurrency support library classes And Ada although in its first versions scarcely an OO language helped bring concurrent programming outfrom the world of specialized low level languages and systems OO design played no practical role in the multithreaded systems programming practices emerging inthe s And concurrency played no practical role in the wide scale embrace of OO programmingthat began in the s But interest in OO concurrency stayed alive in research laboratories andadvanced development groups and has re emerged as an essential aspect of programming in part dueto the popularity and ubiquity of the Java platform Concurrent OO programming shares most features with programming of any kind But it differs incritical ways from the kinds of programming you may be most familiar with as discussed below Sequential OO programmingConcurrent OO programs are often structured using the same programming techniques and designpatterns as sequential OO programs see for example But they are intrinsically more complex When more than one activity can occur at a time program execution is necessarily nondeterministic Code may execute in surprising orders any order that is not explicitly ruled out is allowed see So you cannot always understand concurrent programs by sequentially reading through theircode For example without further precautions a field set to one value in one line of code may have adifferent value due to the actions of some other concurrent activity by the time the next line of codeis executed Dealing with this and other forms of interference often introduces the need for a bit morerigor and a more conservative outlook on design Event based programmingSome concurrent programming techniques have much in common with those in event frameworksemployed in GUI toolkits supported by java awt and javax swing and in other languagessuch as Tcl Tk and Visual Basic In GUI frameworks events such as mouse clicks are encapsulated asEvent objects that are placed in a single EventQueue These events are then dispatched andprocessed one by one in a single event loop which normally runs as a separate thread As discussed in this design can be extended to support additional concurrency by among other tactics creatingmultiple event loop threads each concurrently processing events or even dispatching each event in aseparate thread Again this opens up new design possibilities but also introduces new concerns aboutinterference and coordination among concurrent activities Concurrent systems programmingObject oriented concurrent programming differs from multithreaded systems programming inlanguages such as C mainly due to the encapsulation modularity extensibility security and safetyfeatures otherwise lacking in C Additionally concurrency support is built into the Java programminglanguage rather than supplied by libraries This eliminates the possibility of some common errors andalso enables compilers to automatically and safely perform some optimizations that would need to beperformed manually in C While concurrency support constructs in the Java programming language are generally similar to thosein the standard POSIX pthreads library and related packages typically used in C there are someimportant differences especially in the details of waiting and notification see It is verypossible to use utility classes that act almost just like POSIX routines see But it is oftenmore productive instead to make minor adjustments to exploit the versions that the language directlysupports Other concurrent programming languagesEssentially all concurrent programming languages are at some level equivalent if only in the sensethat all concurrent languages are widely believed not to have defined the right concurrency features However it is not all that hard to make programs in one language look almost equivalent to those inother languages or those using other constructs by developing packages classes utilities tools andcoding conventions that mimic features built into others In the course of this book constructions areintroduced that provide the capabilities and programming styles of semaphore based systems futures barrier based parallelism CSP and others It is a perfectly greatidea to write programs using only one of these styles if this suits your needs However manyconcurrent designs patterns frameworks and systems have eclectic heritages and steal good ideasfrom anywhere they can Object Models and MappingsConceptions of objects often differ across sequential versus concurrent OO programming and evenacross different styles of concurrent OO programming Contemplation of the underlying object modelsand mappings can reveal the nature of differences among programming styles hinted at in the previoussection Most people like to think of software objects as models of real objects represented with somearbitrary degree of precision The notion of real is of course in the eye of the beholder and oftenincludes artifices that make sense only within the realm of computation For a simple example consider the skeletal UML class diagram and code sketch for classWaterTank class WaterTank final float capacity float currentVolume f WaterTank overflow Code sketchWaterTank float cap capacity cap void addWater float amount throws OverflowException void removeWater float amount throws UnderflowException The intent here is to represent or simulate a water tank with Attributes such as capacity and currentVolume that are represented as fields ofWaterTank objects We can choose only those attributes that we happen to care about insome set of usage contexts For example while all real water tanks have locations shapes colors and so on this class only deals with volumes Invariant state constraints such as the facts that the currentVolume always remainsbetween zero and capacity and that capacity is nonnegative and never changes afterconstruction Operations describing behaviors such as those to addWater and removeWater Thischoice of operations again reflects some implicit design decisions concerning accuracy granularity and precision For example we could have chosen to model water tanks at thelevel of valves and switches and could have modeled each water molecule as an object thatchanges location as the result of the associated operations Connections and potential connections to other objects with which objects communicate such as pipes or other tanks For example excess water encountered in an addWateroperation could be shunted to an overflow tank that is known by each tank Preconditions and postconditions on the effects of operations such as rules stating that it isimpossible to remove water from an empty tank or to add water to a full tank that is notequipped with an available overflow tank Protocols constraining when and how messages operation requests are processed Forexample we may impose a rule that at most one addWater or removeWater messageis processed at any given time or alternatively a rule stating that removeWater messagesare allowed in the midst of addWater operations Object modelsThe WaterTank class uses objects to model reality Object models provide rules and frameworksfor defining objects more generally covering Statics The structure of each object is described normally via a class in terms of internal attributes state connections to other objects local internal methods and methods or ports for acceptingmessages from other objects Encapsulation Objects have membranes separating their insides and outsides Internal state can bedirectly modified only by the object itself We ignore for now language features that allow this rule tobe broken Communication Objects communicate only via message passing Objects issue messages that triggeractions in other objects The forms of these messages may range from simple procedural calls to thosetransported via arbitrary communication protocols Identity New objects can be constructed at any time subject to system resource constraints by anyobject subject to access control Once constructed each object maintains a unique identity thatpersists over its lifetime Connections One object can send messages to others if it knows their identities Some models rely onchannel identities rather than or in addition to object identities Abstractly a channel is a vehicle forpassing messages Two objects that share a channel may pass messages through that channel withoutknowing each other s identities Typical OO models and languages rely on object based primitives fordirect method invocations channel based abstractions for IO and communication across wires andconstructions such as event channels that may be viewed from either perspective Computation Objects may perform four basic kinds of computation Accept a message Update internal state Send a message Create a new object This abstract characterization can be interpreted and refined in several ways For example one way toimplement a WaterTank object is to build a tiny special purpose hardware device that onlymaintains the indicated states instructions and connections But since this is not a book on hardwaredesign we ll ignore such options and restrict attention to software based alternatives Sequential mappingsThe features of an ordinary general purpose computer a CPU a bus some memory and some IOports can be exploited so that this computer can pretend it is any object for example aWaterTank This can be arranged by loading a description of WaterTanks via a classfile into a JVM The JVM can then construct a passive representation of an instance and theninterpret the associated operations This mapping strategy also applies at the level of the CPU whenoperations are compiled into native code rather than interpreted as bytecodes It also extends toprograms involving many objects of different classes each loaded and instantiated as needed byhaving the JVM at all times record the identity this of the object it is currently simulating In other words the JVM is itself an object although a very special one that can pretend it is any otherobject More formally it serves as a Universal Turing Machine While similar remarks hold for themappings used in most other languages Class objects and reflection make it simpler to characterizereflective objects that treat other objects as data In a purely sequential environment this is the end of the story But before moving on consider therestrictions on the generic object model imposed by this mapping On a sequential JVM it would beimpossible to directly simulate multiple concurrent interacting waterTank objects And because allmessage passing is performed via sequential procedural invocation there is no need for rules aboutwhether multiple messages may be processed concurrently they never are anyway Thus sequentialOO processing limits the kinds of high level design concerns you are allowed to express Active objectsAt the other end of the mapping spectrum are active object models also known as actor models inwhich every object is autonomous Each may be as powerful as a sequential JVM Internal class andobject representations may take the same forms as those used in passive frameworks For examplehere each waterTank could be mapped to a separate active object by loading in a description to aseparate JVM and then forever allowing it to simulate the defined actions Active object models form a common high level view of objects in distributed object orientedsystems Different objects may reside on different machines so the location and administrativedomain of an object are often important programming issues All message passing is arranged viaremote communication for example via sockets that may obey any of a number of protocols including oneway messaging i e messages that do not intrinsically require replies multicasts simultaneously sending the same message to multiple recipients and procedure style request replyexchanges This model also serves as an object oriented view of most operating system level processes each ofwhich is as independent of and shares as few resources with other processes as possible see Mixed modelsThe models and mappings underlying concurrency support in the Java programming language fallbetween the two extremes of passive and active models A full JVM may be composed of multiplethreads each of which acts in about the same way as a single sequential JVM However unlike pureactive objects all of these threads may share access to the same set of underlying passiverepresentations This style of mapping can simulate each of the extremes Purely passive sequential models can beprogrammed using only one thread Purely active models can be programmed by creating as manythreads as there are active objects avoiding situations in which more than one thread can access agiven passive representation see and using constructs that provide the same semantic effects asremote message passing see However most concurrent programs occupy a middle ground Thread based concurrent OO models conceptually separate normal passive objects from activeobjects threads But the passive objects typically display thread awareness not seen in sequentialprogramming for example by protecting themselves via locks And the active objects are simpler thanthose seen in actor models supporting only a few operations such as run But the design ofconcurrent OO systems can be approached from either of these two directions by smartening uppassive objects to live in a multithreaded environment or by dumbing down active objects so they canbe expressed more easily using thread constructs One reason for supporting this kind of object model is that it maps in a straightforward and efficientway to stock uniprocessor and shared memory multiprocessor SMP hardware and operating systems Threads can be bound to CPUs when possible and desirable and otherwise time shared local threadstate maps to registers and CPUs and shared object representations map to shared main memory The degree of programmer control over these mappings is one distinction separating many forms ofparallel programming from concurrent programming Classic parallel programming involves explicitdesign steps to map threads tasks or processes as well as data to physical processors and their localstores Concurrent programming leaves most mapping decisions to the JVM and the underlying OS This enhances portability at the expense of needing to accommodate differences in the quality ofimplementation of these mappings Time sharing is accomplished by applying the same kind of mapping strategy to threads themselves Representations of Thread objects are maintained and a scheduler arranges context switches inwhich the CPU state corresponding to one thread is saved in its associated storage representation andrestored from another Several further refinements and extensions of such models and mappings are possible For example persistent object applications and systems typically rely on databases to maintain objectrepresentations rather than directly relying on main memory Further ReadingsThere is a substantial literature on concurrency ranging from works on theoretical foundations topractical guides for using particular concurrent applications Concurrent programmingTextbooks presenting details on additional concurrent algorithms programming strategies and formalmethods not covered in this book include Andrews Gregory Foundations of Multithreaded Parallel and Distributed Programming Addison Wesley This is an expanded update of Andrews s Concurrent Programming Principles andPractice Benjamin Cummings Ben Ari M Principles of Concurrent and Distributed Programming Prentice Hall Bernstein Arthur and Philip Lewis Concurrency in Programming and Database Systems Jones andBartlett Burns Alan and Geoff Davis Concurrent Programming Addison Wesley Bustard David John Elder and Jim Welsh Concurrent Program Structures Prentice Hall Schneider Fred On Concurrent Programming Springer Verlag The concurrency constructs found in the Java programming language have their roots in similarconstructs first described by C A R Hoare and Per Brinch Hansen See papers by them and others infollowing collections Dahl Ole Johan Edsger Dijkstra and C A R Hoare eds Structured Programming AcademicPress Gehani Narain and Andrew McGettrick eds Concurrent Programming Addison Wesley A comparative survey of how some of these constructs are defined and supported across differentlanguages and systems may be found in Buhr Peter Michel Fortier and Michael Coffin Monitor Classification ACM Computing Surveys Concurrent object oriented object based or module based languages include Simula Modula Mesa Ada Orca Sather and Euclid More information on these languages can be found in theirmanuals as well as in Birtwistle Graham Ole Johan Dahl Bjorn Myhrtag and Kristen Nygaard Simula Begin AuerbachPress Burns Alan and Andrew Wellings Concurrency in Ada Cambridge University Press Holt R C Concurrent Euclid the Unix System and Tunis Addison Wesley Nelson Greg ed Systems Programming with Modula Prentice Hall Stoutamire David and Stephen Omohundro The Sather pSather Specification Technical Report University of California at Berkeley Books taking different approaches to concurrency in the Java programming language include Hartley Stephen Concurrent Programming using Java Oxford University Press This takes anoperating systems approach to concurrency Holub Allen Taming Java Threads Apress This collects the author s columns on threads inthe JavaWorld online magazine Lewis Bil Multithreaded Programming in Java Prentice Hall This presents a somewhatlighter treatment of several topics discussed in this book and provides closer tie ins with POSIXthreads Magee Jeff and Jeff Kramer Concurrency State Models and Java Programs Wiley Thisprovides a stronger emphasis on modeling and analysis Most books articles and manuals on systems programming using threads concentrate on the details ofthose on particular operating systems or thread packages See Butenhof David Programming with POSIX Threads Addison Wesley This provides the mostcomplete discussions of the POSIX thread library and how to use it Lewis Bil and Daniel Berg Multithreaded Programming with Pthreads Prentice Hall Norton Scott and Mark Dipasquale Thread Time Prentice Hall Most texts on operating systems and systems programming describe the design and construction ofunderlying support mechanisms for language level thread and synchronization constructs See forexample Hanson David C Interfaces and Implementations Addison Wesley Silberschatz Avi and Peter Galvin Operating Systems Concepts Addison Wesley Tanenbaum Andrew Modern Operating Systems Prentice Hall ModelsGiven the diverse forms of concurrency seen in software it s not surprising that there have been alarge number of approaches to the basic theory of concurrency Theoretical accounts of processcalculi event structures linear logic Petri nets and temporal logic have potential relevance to theunderstanding of concurrent OO systems For overviews of most approaches to the theory ofconcurrency see van Leeuwen Jan ed Handbook of Theoretical Computer Science Volume B MIT Press An eclectic and still fresh sounding presentation of models associated programming techniques anddesign patterns illustrated using diverse languages and systems is Filman Robert and Daniel Friedman Coordinated Computing McGraw Hill There are several experimental concurrent OO languages based on active objects most notably thefamily of Actor languages See Agha Gul ACTORS A Model of Concurrent Computation in Distributed Systems MIT Press A more extensive survey of object oriented approaches to concurrency can be found in Briot Jean Pierre Rachid Guerraoui and Klaus Peter Lohr Concurrency and Distribution in Object Oriented Programming Computing Surveys Research papers on object oriented models systems and languages can be found in proceedings of OOconferences including ECOOP OOPSLA COOTS TOOLS and ISCOPE as well as concurrencyconferences such as CONCUR and journals such as IEEE Concurrency Also the followingcollections contain chapters surveying many approaches and issues Agha Gul Peter Wegner and Aki Yonezawa eds Research Directions in Concurrent Object Oriented Programming MIT Press Briot Jean Pierre Jean Marc Geib and Akinori Yonezawa eds Object Based Parallel andDistributed Computing LNCS Springer Verlag Guerraoui Rachid Oscar Nierstrasz and Michel Riveill eds Object Based Distributed Processing LNCS Springer Verlag Nierstrasz Oscar and Dennis Tsichritzis eds Object Oriented Software Composition Prentice Hall Distributed systemsTexts on distributed algorithms protocols and system design include Barbosa Valmir An Introduction to Distributed Algorithms Morgan Kaufman Birman Kenneth and Robbert von Renesse Reliable Distributed Computing with the Isis Toolkit IEEE Press Coulouris George Jean Dollimore and Tim Kindberg Distributed Systems Concepts and Design Addison Wesley Lynch Nancy Distributed Algorithms Morgan Kaufman Mullender Sape ed Distributed Systems Addison Wesley Raynal Michel Distributed Algorithms and Protocols Wiley For details about distributed programming using RMI see Arnold Ken Bryan O Sullivan Robert Scheifler Jim Waldo and Ann Wollrath The JiniTMSpecification Addison Wesley Real time programmingMost texts on real time programming focus on hard real time systems in which for the sake ofcorrectness certain activities must be performed within certain time constraints The Javaprogramming language does not supply primitives that provide such guarantees so this book does notcover deadline scheduling priority assignment algorithms and related concerns Sources on real timedesign include Burns Alan and Andy Wellings Real Time Systems and Programming Languages Addison Wesley This book illustrates real time programming in Ada occam and C and includes arecommended account of priority inversion problems and solutions Gomaa Hassan Software Design Methods for Concurrent and Real Time Systems Addison Wesley Levi Shem Tov and Ashok Agrawala Real Time System Design McGraw Hill Selic Bran Garth Gullekson and Paul Ward Real Time Object Oriented Modeling Wiley Design ForcesThis section surveys design concerns that arise in concurrent software development but play at bestminor roles in sequential programming Most presentations of constructions and design patterns laterin this book include descriptions of how they resolve applicable forces discussed here as well asothers that are less directly tied to concurrency such as accuracy testability and so on One can take two complementary views of any OO system object centric and activity centric Under an object centric view a system is a collection of interconnected objects But it is a structuredcollection not a random object soup Objects cluster together in groups for example the group ofobjects comprising a ParticleApplet thus forming larger components and subsystems Under an activity centric view a system is a collection of possibly concurrent activities At the mostfine grained level these are just individual message sends normally method invocations They inturn organize themselves into sets of call chains event sequences tasks sessions transactions andthreads One logical activity such as running the ParticleApplet may involve many threads At a higher level some of these activities represent system wide use cases Neither view alone provides a complete picture of a system since a given object may be involved inmultiple activities and conversely a given activity may span multiple objects However these twoviews give rise to two complementary sets of correctness concerns one object centric and the otheractivity centric Safety Nothing bad ever happens to an object Liveness Something eventually happens within an activity Safety failures lead to unintended behavior at run time things just start going wrong Livenessfailures lead to no behavior things just stop running Sadly enough some of the easiest things youcan do to improve liveness properties can destroy safety properties and vice versa Getting them bothright can be a challenge You have to balance the relative effects of different kinds of failure in your own programs But it is astandard engineering not just software engineering practice to place primary design emphasis onsafety The more your code actually matters the better it is to ensure that a program does nothing at allrather than something that leads to random even dangerous behavior On the other hand most of the time spent tuning concurrent designs in practice usually surroundsliveness and liveness related efficiency issues And there are sometimes good conscientious reasonsfor selectively sacrificing safety for liveness For example it may be acceptable for visual displays totransiently show utter nonsense due to uncoordinated concurrent execution drawing stray pixels incorrect progress indicators or images that bear no relation to their intended forms if you areconfident that this state of affairs will soon be corrected Safety and liveness issues may be further extended to encompass two categories of quality concerns one mainly object centric and the other mainly activity centric that are also sometimes in directopposition Reusability The utility of objects and classes across multiple contexts Performance The extent to which activities execute soon and quickly The remainder of this section looks more closely at safety liveness performance and reusability inconcurrent programs It presents basic terms and definitions along with brief introductions to coreissues and tactics that are revisited and amplified throughout the course of this book SafetySafe concurrent programming practices are generalizations of safe and secure sequential programmingpractices Safety in concurrent designs adds a temporal dimension to common notions of type safety A type checked program might not be correct but at least it doesn t do dangerous things likemisinterpret the bits representing a float as if they were an object reference Similarly a safeconcurrent design might not have the intended effect but at least it never encounters errors due tocorruption of representations by contending threads One practical difference between type safety and multithreaded safety is that most type safety matterscan be checked automatically by compilers A program that fails to pass compile time checks cannoteven be run Most multithreaded safety matters however cannot be checked automatically and somust rely on programmer discipline Methods for proving designs to be safe fall outside the scope ofthis book see the Further Readings The techniques for ensuring safety described here rely on carefulengineering practices including several with roots in formalisms rather than formal methodsthemselves Multithreaded safety also adds a temporal dimension to design and programming techniquessurrounding security Secure programming practices disable access to certain operations on objectsand resources from certain callers applications or principals Concurrency control introducestransient disabling of access based on consideration of the actions currently being performed by otherthreads The main goal in safety preservation is ensuring that all objects in a system maintain consistent states states in which all fields and all fields of other objects on which they depend possess legal meaningful values It sometimes takes hard work to nail down exactly what legal and meaningful mean in a particular class One path is first to establish conceptual level invariants for example therule that water tank volumes must always be between zero and their capacities These can usually berecast in terms of relationships among field values in the associated concrete classes An object is consistent if all fields obey their invariants Every public method in every class shouldlead an object from one consistent state to another Safe objects may occasionally enter transientlyinconsistent states in the midst of methods but they never attempt to initiate new actions when theyare in inconsistent states If every object is designed to perform actions only when it is logically ableto do so and if all the mechanics are properly implemented then you can be sure that an applicationusing these objects will not encounter any errors due to object inconsistency One reason for being more careful about invariants in concurrent programs is that it is much easier tobreak them inadvertently than in most sequential programs The need for protection against the effectsof inconsistency arises even in sequential contexts for example when processing exceptions andcallbacks and when making self calls from one method in a class to another However these issuesbecome much more central in concurrent programs As discussed in the most common ways ofensuring consistency employ exclusion techniques to guarantee the atomicity of public actions thateach action runs to completion without interference from others Without such protection inconsistencies in concurrent programs may stem from race conditions producing storage conflicts atthe level of raw memory cells Read Write conflicts One thread reads a value of a field while another writes to it The value seen bythe reading thread is difficult to predict it depends on which thread won the race to access thefield first As discussed in the value read need not even be a value that was ever written by anythread Write Write conflicts Two threads both try to write to the same field The value seen upon the nextread is again difficult or impossible to predict It is equally impossible to predict the consequences of actions that are attempted when objects are ininconsistent states Examples include A graphical representation for example of a Particle is displayed at a location that theobject never actually occupied A bank account balance is incorrect after an attempt to withdraw money in the midst of anautomatic transfer Following the next pointer of a linked list leads to a node that is not even in the list Two concurrent sensor updates cause a real time controller to perform an incorrect effectoraction Attributes and constraintsSafe programming techniques rely on clear understanding of required properties and constraintssurrounding object representations Developers who are not aware of these properties rarely do a verygood job at preserving them Many formalisms are available for precisely stating predicates describingrequirements as discussed in most of the texts on concurrent design methods listed in the FurtherReadings These can be very useful but here we will maintain sufficient precision withoutintroducing formalisms Consistency requirements sometimes stem from definitions of high level conceptual attributes madeduring the initial design of classes These constraints typically hold regardless of how the attributesare concretely represented and accessed via fields and methods This was seen for example in thedevelopment of the WaterTank and Particle classes earlier in this chapter Here are someother examples most of which are revisited in more detail in the course of this book A BankAccount has a balance that is equal to the sum of all deposits and interest minuswithdrawals and service charges A Packet has a destination that must be a legal IP address A Counter has a nonnegative integral count value An Invoice has a paymentDue that reflects the rules of a payment system A Thermostat has a temperature equal to the most recent sensor reading A Shape has a location dimension and color that all obey a set of stylistic guidelines for agiven GUI toolkit A BoundedBuffer has an elementCount that is always between zero and a capacity A Stack has a size and when not empty a top element A Window has a propertySet maintaining current mappings of fonts background color etc An Interval has a startDate that is no later than its endDate While such attributes essentially always somehow map to object fields the correspondences need notbe direct For example the top of a Stack is typically not held in a variable but instead in an arrayelement or linked list node Also some attributes can be computed derived via others for example the boolean attribute overdrawn of a BankAccount might be computed by comparing thebalance to zero Representational constraintsFurther constraints and invariants typically emerge as additional implementation decisions are madefor a given class Fields declared for the sake of maintaining a particular data structure for improvingperformance or for other internal bookkeeping purposes often need to respect sets of invariants Broad categories of fields and constraints include the following Direct value representations Fields needed to implement concrete attributes For example aBuffer might have a putIndex field holding the array index position to use when inserting thenext added element Cached value representations Fields used to eliminate or minimize the need for computations ormethod invocations For example rather than computing the value of overdrawn every time it isneeded a BankAccount might maintain an overdrawn field that is true if and only if thecurrent balance is less than zero Logical state representations Reflections of logical control state For example aBankCardReader might have a card field representing the card currently being read and avalidPIN field recording whether the PIN access code was verified The CardReadervalidPIN field may be used to track the point in a protocol in which the card has been successfullyread in and validated Some state representations take the form of role variables controlling responsesto all of a related set of methods sometimes those declared in a single interface For example agame playing object may alternate between active and passive roles depending on the value of awhoseTurn field Execution state variables Fields recording the fine grained dynamic state of an object for example the fact that a certain operation is in progress Execution state variables can represent the fact that agiven message has been received that the corresponding action has been initiated that the action hasterminated and that a reply to the message has been issued An execution state variable is often anenumerated type with values having names ending in ing for example CONNECTING UPDATING WAITING Another common kind of execution state variable is a counter that recordsthe number of entries or exits of some method As discussed in objects in concurrent programstend to require more such variables than do those in sequential contexts to help track and manage theprogress of methods that proceed asynchronously History variables Representations of the history or past states of an object The most extensiverepresentation is a history log recording all messages ever received and sent along with allcorresponding internal actions and state changes that have been initiated and completed Lessextensive subsets are much more common For example a BankAccount class could maintain alastSavedBalance field that holds the last checkpointed value and is used when revertingcancelled transactions Version tracking variables An integer time stamp object reference signature code or otherrepresentation indicating the time ordering or nature of the last state change made by an object Forexample a Thermostat may increment a readingNumber or record thelastReadingTime when updating its temperature References to acquaintances Fields pointing to other objects that the host interacts with but that donot themselves comprise the host s logical state For example a callback target of anEventDispatcher or a requestHandler delegated to by a WebServer References to representation objects Attributes that are conceptually held by a host object but areactually managed by other helper objects Reference fields may point to other objects that assist inrepresenting the state of the host object So the logical state of any object may include the states ofobjects that it holds references to Additionally the reference fields themselves form part of theconcrete state of the host object see Any attempts to ensure safety must take theserelationships into account For example A Stack might have a headOfLinkedList field recording the first node of a listrepresenting the stack A Person object might maintain a homePageURL field maintained as ajava net URL object The balance of a BankAccount might be maintained in a central repository in which casethe BankAccount would instead maintain a a field referring to the repository in order toask it about the current balance In this case some of the logical state of theBankAccount is actually managed by the repository An object might know of its attributes only via access to property lists maintained by otherobjects LivenessOne way to build a guaranteed safe system is to arrange that no objects ever execute any methods andthus can never encounter any conflicts But this is not a very productive form of programming Safetyconcerns must be balanced by liveness concerns Some liveness properties may be construed as safety properties of sets of thread objects For example deadlock freedom may be defined as avoiding the bad state in which a set of threads endlessly wait for eachother In live systems every activity eventually progresses toward completion every invoked methodeventually executes But an activity may perhaps only transiently fail to make progress for any ofseveral interrelated reasons Locking A synchronized method blocks one thread because another thread holds the lock Waiting A method blocks via Object wait or its derivatives waiting for an event message orcondition that has yet to be produced within another thread Input An IO based method waits for input that has not yet arrived from another process or device CPU contention A thread fails to run even though it is in a runnable state because other threads oreven completely separate programs running on the same computer are occupying CPU or othercomputational resources Failure A method running in a thread encounters a premature exception error or fault Momentary blockages in thread progress are usually acceptable In fact frequent short lived blockingis intrinsic to many styles of concurrent programming The lifecycle of a typical thread may include a number of transient blockages and reschedulings However permanent or unbounded lack of progress is usually a serious problem Examples ofpotentially permanent liveness failures described in more depth elsewhere in this book include Deadlock Circular dependencies among locks In the most common case thread A holds a lock forobject X and then tries to acquire the lock for object Y Simultaneously thread B already holds thelock for object Y and tries to acquire the lock for object X Neither thread can ever make furtherprogress see Missed signals A thread remains dormant because it started waiting after a notification to wake it upwas produced see Nested monitor lockouts A waiting thread holds a lock that would be needed by any other threadattempting to wake it up see Livelock A continuously retried action continuously fails see Starvation The JVM OS fails ever to allocate CPU time to a thread This may be due to schedulingpolicies or even hostile denial of service attacks on the host computer see and Resource exhaustion A group of threads together hold all of a finite number of resources One ofthem needs additional resources but no other thread will give one up see Distributed failure A remote machine connected by a socket serving as an InputStream crashesor becomes inaccessible see PerformancePerformance based forces extend liveness concerns In addition to demanding that every invokedmethod eventually execute performance goals require them to execute soon and quickly While we donot consider in this book hard real time systems in which failure to execute within a given timeinterval can lead to catastrophic system errors nearly all concurrent programs have implicit or explicitperformance goals Meaningful performance requirements are stated in terms of measurable qualities including thefollowing metrics Goals may be expressed for central tendencies e g mean median ofmeasurements as well as their variability e g range standard deviation Throughput The number of operations performed per unit time The operations of interest may rangefrom individual methods to entire program runs Most often throughput is reported not as a rate butinstead as the time taken to perform one operation Latency The time elapsed between issuing a message via for example a mouse click methodinvocation or incoming socket connection and servicing it In contexts where operations are uniform single threaded and continuously requested latency is just the inverse of throughput But moretypically the latencies of interest reflect response times the delays until something happens notnecessarily full completion of a method or service Capacity The number of simultaneous activities that can be supported for a given target minimumthroughput or maximum latency Especially in networking applications this can serve as a usefulindicator of overall availability since it reflects the number of clients that can be serviced withoutdropping connections due to time outs or network queue overflows Efficiency Throughput divided by the amount of computational resources for example CPUs memory and IO devices needed to obtain this throughput Scalability The rate at which latency or throughput improves when resources again usually CPUs memory or devices are added to a system Related measures include utilization the percentage ofavailable resources that are applied to a task of interest Degradation The rate at which latency or throughput worsens as more clients activities or operationsare added without adding resources Most multithreaded designs implicitly accept a small trade off of poorer computational efficiency toobtain better latency and scalability Concurrency support introduces the following kinds of overheadand contention that can slow down programs Locks A synchronized method typically requires greater call overhead than an unsynchronizedmethod Also methods that frequently block waiting for locks or for any other reason proceed moreslowly than those that do not Monitors Object wait Object notify Object notifyAll and the methodsderived from them such as Thread join can be more expensive than other basic JVM run timesupport operations Threads Creating and starting a Thread is typically more expensive than creating an ordinaryobject and invoking a method on it Context switching The mapping of threads to CPUs encounters context switch overhead when aJVM OS saves the CPU state associated with one thread selects another thread to run and loads theassociated CPU state Scheduling Computations and underlying policies that select which eligible thread to run addoverhead These may further interact with other system chores such as processing asynchronousevents and garbage collection Locality On multiprocessors when multiple threads running on different CPUs share access to thesame objects cache consistency hardware and low level system software must communicate theassociated values across processors Algorithmics Some efficient sequential algorithms do not apply in concurrent settings For example some data structures that rely on caching work only if it is known that exactly one thread performs alloperations However there are also efficient alternative concurrent algorithms for many problems including those that open up the possibility of further speedups via parallelism The overheads associated with concurrency constructs steadily decrease as JVMs improve Forexample as of this writing the overhead cost of a single uncontended synchronized method callwith a no op body on recent JVMs is on the order of a few unsynchronized no op calls Sincedifferent kinds of calls for example of static versus instance methods can take different times andinteract with other optimizations it is not worth making this more precise However these overheads tend to degrade nonlinearly For example using one lock that is frequentlycontended by ten threads is likely to lead to much poorer overall performance than having each threadpass through ten uncontended locks Also because concurrency support entails underlying systemresource management that is often optimized for given target loads performance can dramaticallydegrade when too many locks monitor operations or threads are used Subsequent chapters include discussions of minimizing use of the associated constructs whennecessary However bear in mind that performance problems of any kind can be remedied only afterthey are measured and isolated Without empirical evidence most guesses at the nature and source ofperformance problems are wrong The most useful measurements are comparative showingdifferences or trends under different designs loads or configurations ReusabilityA class or object is reusable to the extent that it can be readily employed across different contexts either as a black box component or as the basis of white box extension via subclassing and relatedtechniques The interplay between safety and liveness concerns can significantly impact reusability It is usuallypossible to design components to be safe across all possible contexts For example asynchronized method that refuses to commence until it possesses the synchronization lock willdo this no matter how it is used But in some of these contexts programs using this safe componentmight encounter liveness failures for example deadlock Conversely the functionality surrounding acomponent using only unsynchronized methods will always be live at least with respect to locking but may encounter safety violations when multiple concurrent executions are allowed to occur The dualities of safety and liveness are reflected in some extreme views of design methodology Sometop down design strategies take a pure safety first approach Ensure that each class and object is safe and then later try to improve liveness as an optimization measure An opposite bottom up approach issometimes adopted in multithreaded systems programming Ensure that code is live and then try tolayer on safety features for example by adding locks Neither extreme is especially successful inpractice It is too easy for top down approaches to result in slow deadlock prone systems and forbottom up approaches to result in buggy code with unanticipated safety violations It is usually more productive to proceed with the understanding that some very useful and efficientcomponents are not and need not be absolutely safe and that useful services supported by somecomponents are not absolutely live Instead they operate correctly only within certain restricted usagecontexts Therefore establishing documenting advertising and exploiting these contexts becomecentral issues in concurrent software design There are two general approaches and a range of intermediate choices for dealing with contextdependence Minimize uncertainty by closing off parts of systems and Establish policies andprotocols that enable components to become or remain open Many practical design efforts involvesome of each Closed subsystemsAn ideally closed system is one for which you have perfect static design time knowledge about allpossible behaviors This is typically both unattainable and undesirable However it is often stillpossible to close off parts of systems in units ranging from individual classes to product levelcomponents by employing possibly extreme versions of OO encapsulation techniques Restricted external communication All interactions both inward and outward occur through anarrow interface In the most tractable case the subsystem is communication closed never internallyinvoking methods on objects outside the subsystem Deterministic internal structure The concrete nature and ideally number of all objects and threadscomprising the subsystem are statically known The final and private keywords can be used tohelp enforce this In at least some such systems you can in principle prove informally formally or evenmechanically that no internal safety or liveness violations are possible within a closed component Or if they are possible you can continue to refine designs and implementations until a component isprovably correct In the best cases you can then apply this knowledge compositionally to analyzeother parts of a system that rely on this component Perfect static information about objects threads and interactions tells you not only what can happen but also what cannot happen For example it may be the case that even though twosynchronized methods in two objects contain calls to each other they can never be accessedsimultaneously by different threads within the subsystem so deadlock will never occur Closure may also provide further opportunities for manual or compiler driven optimization forexample removing synchronization from methods that would ordinarily require it or employing cleverspecial purpose algorithms that can be made to apply only by eliminating the possibility of unwantedinteraction Embedded systems are often composed as collections of closed modules in part toimprove predictability schedulability and related performance analyses While closed subsystems are tractable they can also be brittle When the constraints and assumptionsgoverning their internal structure change these components are often thrown away and redevelopedfrom scratch Open systemsAn ideal open system is infinitely extensible across several dimensions It may load unknown classesdynamically allow subclasses to override just about any method employ callbacks across objectswithin different subsystems share common resources across threads use reflection to discover andinvoke methods on otherwise unknown objects and so on Unbounded openness is usually asunattainable and undesirable as complete closedness If everything can change then you cannotprogram anything But most systems require at least some of this flexibility Full static analysis of open systems is not even possible since their nature and structure evolve acrosstime Instead open systems must rely on documented policies and protocols that every componentadheres to The Internet is among the best examples of an open system It continually evolves for example byadding new hosts web pages and services requiring only that all participants obey a few networkpolicies and protocols As with other open systems adherence to Internet policies and protocols issometimes difficult to enforce However JVMs themselves arrange that non conforming componentscannot catastrophically damage system integrity Policy driven design can work well at the much smaller level of typical concurrent systems wherepolicies and protocols often take the form of design rules Examples of policy domains explored inmore depth in subsequent chapters include Flow For example a rule of the form Components of type A send messages to those of type B butnever vice versa Blocking For example a rule of the form Methods of type A always immediately throw exceptions ifresource R is not available rather than blocking until it is available Notifications For example a rule of the form Objects of type A always send change notifications totheir listeners whenever updated Adoption of a relatively small number of policies simplifies design by minimizing the possibility ofinconsistent case by case decisions Component authors perhaps with the help of code reviews andtools need check only that they are obeying the relevant design rules and can otherwise focusattention on the tasks at hand Developers can think locally while still acting globally However policy driven design can become unmanageable when the number of policies grows largeand the programming obligations they induce overwhelm developers When even simple methodssuch as updating an account balance or printing Hello world require dozens of lines of awkward error prone code to conform to design policies it is time to take some kind of remedial action Simplify or reduce the number of policies or create tools that help automate code generation and orcheck for conformance or create domain specific languages that enforce a given discipline or createframeworks and utility libraries that reduce the need for so much support code to be written insideeach method Policy choices need not be in any sense optimal to be effective but they must be conformed to andbelieved in the more fervently the better Such policy choices form the basis of several frameworksand design patterns described throughout this book It is likely that some of them will be inapplicableto your software projects and may even strike you as wrong headed I d never do that because theunderlying policies clash with others you have adopted While inducing greater closedness allows you to optimize for performance inducing greater opennessallows you to optimize for future change These two kinds of tunings and refactorings are oftenequally challenging to carry out but have opposite effects Optimizing for performance usually entailsexploiting special cases by hard wiring design decisions Optimizing for extensibility entails removinghard wired decisions and instead allowing them to vary for example by encapsulating them asoverridable methods supporting callback hooks or abstracting functionality via interfaces thatcan be re implemented in completely different ways by dynamically loaded components Because concurrent programs tend to include more in the small policy decisions than sequential ones and because they tend to rely more heavily on invariants surrounding particular representationchoices classes involving concurrency constructs often turn out to require special attention in order tobe readily extensible This phenomenon is widespread enough to have been given a name theinheritance anomaly and is described in more detail in However some other programming techniques needlessly restrict extensibility for the sake ofperformance These tactics become more questionable as compilers and JVMs improve For example dynamic compilation allows many extensible components to be treated as if they are closed at class loading time leading to optimizations and specializations that exploit particular run time contextsmore effectively than any programmer could DocumentationWhen compositionality is context dependent it is vital for intended usage contexts and restrictionssurrounding components to be well understood and well documented When this information is notprovided use reuse maintenance testing configuration management system evolution and relatedsoftware engineering concerns are made much more difficult Documentation may be used to improve understandability by any of several audiences otherdevelopers using a class as a black box component subclass authors developers who later maintain modify or repair code testers and code reviewers and system users Across these audiences the firstgoal is to eliminate the need for extensive documentation by minimizing the unexpected and thusreducing conceptual complexity via Standardization Using common policies protocols and interfaces For example Adopting standard design patterns and referencing books web pages or design documentsthat describe them more fully Employing standard utility libraries and frameworks Using standard coding idioms and naming conventions Clearing against standard review checklists that enumerate common errors Clarity Using the simplest most self evident code expressions For example Using exceptions to advertise checked conditions Expressing internal restrictions via access qualifiers such as private Adopting common default naming and signature conventions for example that unlessspecified otherwise methods that can block declare that they throwInterruptedException Auxiliary code Supplying code that demonstrates intended usages For example Including sample or recommended usage examples Providing code snippets that achieve non obvious effects Including methods designed to serve as self tests After eliminating the need to explain the obvious via documentation more useful forms ofdocumentation can be used to clarify design decisions The most critical details can be expressed in asystematic fashion using semiformal annotations of the forms listed in the following table which areused and further explained as needed throughout this book PREPrecondition not necessarily checked PRE Caller holds synch lock WHEN Guard condition always checked WHEN not empty return oldest POST Postcondition normally unchecked POST Resource r is released OUT Guaranteed message send for example a callback OUT c process buff called after read RELY Required normally unchecked property of other objects or methods RELY Must be awakened by x signal INV An object constraint true at the start and end of every public method INV x y are valid screen coordinates INIT An object constraint that must hold upon construction INIT bufferCapacity greater than zero Additional less structured documentation can be used to explain non obvious constraints contextuallimitations assumptions and design decisions that impact use in a concurrent environment It isimpossible to provide a complete listing of constructions requiring this kind of documentation buttypical cases include High level design information about state and method constraints Known safety limitations due to lack of locking in situations that would require it The fact that a method may indefinitely block waiting for a condition event or resource Methods designed to be called only from other methods perhaps those in other classes This book like most others cannot serve as an especially good model for such documentationpractices since most of these matters are discussed in the text rather than as sample codedocumentation Further ReadingsAccounts of high level object oriented software analysis and design that cover at least someconcurrency issues include Atkinson Colin Object Oriented Reuse Concurrency and Distribution Addison Wesley Booch Grady Object Oriented Analysis and Design Benjamin Cummings Buhr Ray J A and Ronald Casselman Use Case Maps for Object Oriented Systems Prentice Hall Buhr and Casselman generalize timethread diagrams similar to those used in this book to UseCase Maps Cook Steve and John Daniels Designing Object Systems Object Oriented Modelling With Syntropy Prentice Hall de Champeaux Dennis Doug Lea and Penelope Faure Object Oriented System Development Addison Wesley D Souza Desmond and Alan Wills Objects Components and Frameworks with UML Addison Wesley Reenskaug Trygve Working with Objects Prentice Hall Rumbaugh James Michael Blaha William Premerlani Frederick Eddy and William Lorensen Object Oriented Modeling and Design Prentice Hall Accounts of concurrent software specification analysis design and verification include Apt Krzysztof and Ernst Rudiger Olderog Verification of Sequential and Concurrent Programs Springer Verlag Carriero Nicholas and David Gelernter How to Write Parallel Programs MIT Press Chandy K Mani and Jayedev Misra Parallel Program Design Addison Wesley Jackson Michael Principles of Program Design Academic Press Jensen Kurt and Grzegorz Rozenberg eds High level Petri Nets Theory and Application Springer Verlag Lamport Leslie The Temporal Logic of Actions SRC Research Report Digital Equipment Corp Leveson Nancy Safeware System Safety and Computers Addison Wesley Manna Zohar and Amir Pneuli The Temporal Logic of Reactive and Concurrent Systems Springer Verlag Several specialized fields of software development rely heavily on concurrency For example manysimulation systems telecommunications systems and multimedia systems are highly multithreaded While basic concurrency techniques form much of the basis for the design of such systems this bookstops short of describing large scale software architectures or specialized programming techniquesassociated with particular concurrent applications See for example Fishwick Paul Simulation Model Design and Execution Prentice Hall Gibbs Simon and Dennis Tsichritzis Multimedia Programming Addison Wesley Watkins Kevin Discrete Event Simulation in C McGraw Hill Technical issues are only one aspect of concurrent software development which also entails testing organization management human factors maintenance tools and engineering discipline For anintroduction to basic engineering methods that can be applied to both everyday programming andlarger efforts see Humphrey Watts A Discipline for Software Engineering Addison Wesley For a completely different perspective see Beck Kent Extreme Programming Explained Embrace Change Addison Wesley For more information about integrating performance concerns into software engineering efforts seefor example Jain Raj The Art of Computer Systems Performance Analysis Wiley Further distinctions between open and closed systems are discussed in Wegner Peter Why Interaction Is More Powerful Than Algorithms Communications of the ACM May Before After PatternsMany concurrent designs are best described as patterns A pattern encapsulates a successful andcommon design form usually an object structure also known as a micro architecture consisting ofone or more interfaces classes and or objects that obey certain static and dynamic constraints andrelationships Patterns are an ideal vehicle for characterizing designs and techniques that need not beimplemented in exactly the same way across different contexts and thus cannot be usefullyencapsulated as reusable components Reusable components and frameworks can play a central role inconcurrent software development But much of concurrent OO programming entails the reuse adaptation and extension of recurring design forms and practices rather than of particular classes Unlike those in the pioneering Design Patterns book by Gamma Helm Johnson and Vlissides seeFurther Readings in the patterns here are embedded within chapters discussing sets of relatedcontexts and software design principles that generate the main forces and constraints resolved in thepatterns Many of these patterns are minor extensions or variants of other common OO layering andcomposition patterns This section reviews some that are relied on heavily in subsequent chapters Others are briefly described upon first encounter LayeringLayering policy control over mechanism is a common structuring principle in systems of all sorts Many OO layering and composition techniques rely on sandwiching some method call or body ofcode between a given before action and an after action All forms of before after control arrange thata given ground method say method is intercepted so as always to execute in the sequence before method after Or to ensure that after actions are performed even if the ground methods encounter exceptions before try method finally after Most examples in this book of course revolve around concurrency control For example asynchronized method acquires a lock before executing the code inside the method and releasesthe lock after the method otherwise completes But the basic ideas of before after patterns can beillustrated in conjunction with another useful practice in OO programming self checking code Thefields of any object should preserve all invariants whenever the object is not engaged in a publicmethod see Invariants should be maintained even if these methods throw any of theirdeclared exceptions unless these exceptions denote corruption or program failure as may be true forRuntimeExceptions and Errors Conformance to computable invariants can be tested dynamically by creating classes that check themboth on entry to and on exit from every public method Similar techniques apply to preconditions andpostconditions but for simplicity we ll illustrate only with invariants As an example suppose we d like to create water tank classes that contain a self check on theinvariant that the volume is always between zero and the capacity To do this we can define acheckVolumeInvariant method and use it as both the before and after operation We can firstdefine an exception to throw if the invariant fails class AssertionError extends java lang Error public AssertionError super public AssertionError String message super message It can be disruptive to insert these checks manually inside each method Instead one of threebefore after design patterns can be used to separate the checks from the ground methods adapterclasses subclass based designs and method adapter classes In all cases the best way to set this up is to define an interface describing the basic functionality Interfaces are almost always necessary when you need to give yourself enough room to varyimplementations Conversely the lack of existing interfaces limits options when retrospectivelyapplying before after patterns Here is an interface describing a minor variant of the water tank class discussed in Before after techniques may be applied to check invariants around the transferWater operation interface Tank float getCapacity float getVolume void transferWater float amount throws OverflowException UnderflowException AdaptersWhen standardized interfaces are defined after designing one or more concrete classes these classesoften do not quite implement the desired interface For example the names of their methods might beslightly different from those defined in the interface If you cannot modify these concrete classes to fixsuch problems you can still obtain the desired effect by building an Adapter class that translates awaythe incompatibilities Say you have a Performer class that supports method perform and meets all the qualificationsof being usable as a Runnable except for the name mismatch You can build an Adapter so it canbe used in a thread by some other class class AdaptedPerformer implements Runnable private final Performer adaptee public AdaptedPerformer Performer p adaptee p public void run adaptee perform This is only one of many common contexts for building Adapters which also form the basis of severalrelated patterns presented in the Design Patterns book A Proxy is an Adapter with the same interfaceas its delegate A Composite maintains a collection of delegates all supporting the same interface In this delegation based style of composition the publicly accessible host class forwards all methodsto one or more delegates and relays back replies perhaps doing some light translation name changes parameter coercion result filtering etc surrounding the delegate calls Adapters can be used to provide before after control merely by wrapping the delegated call within thecontrol actions For example assuming that we have an implementation class say TankImpl wecan write the following AdaptedTank class This class can be used instead of the original in someapplication by replacing all occurrences of new TankImpl with new AdaptedTank new TankImpl class AdaptedTank implements Tank protected final Tank delegate public AdaptedTank Tank t delegate t public float getCapacity return delegate getCapacity public float getVolume return delegate getVolume protected void checkVolumeInvariant throws AssertionError float v getVolume float c getCapacity if v v c throw new AssertionError public synchronized void transferWater float amount throws OverflowException UnderflowException checkVolumeInvariant before checktry delegate transferWater amount The re throws will be postponed until after check in the finally clausecatch OverflowException ex throw ex catch UnderflowException ex throw ex finally checkVolumeInvariant after check SubclassingIn the normal case when the intercepted before after versions of methods have the same names andusages as base versions subclassing can be a simpler alternative to the use of Adapters Subclassversions of methods can interpose checks around calls to their super versions For example class SubclassedTank extends TankImpl protected void checkVolumeInvariant throws AssertionError identical to AdaptedTank version public synchronized void transferWater float amount throws OverflowException UnderflowException identical to AdaptedTank version except for inner call try super transferWater amount Some choices between subclassing and Adapters are just a matter of style Others reflect differencesbetween delegation and inheritance Adapters permit manipulations that escape subclassing rules For example you cannot override apublic method as private in a subclass in order to disable access but you can simply fail torelay the method in an Adapter Various forms of delegation can even be used as a substitute of sortsfor subclassing by having each sub class Adapter hold a reference to an instance of its super class Adaptee forwarding it all inherited operations Such Adapters often have exactly the sameinterfaces as their delegates in which case they are considered to be simple kinds of Proxies Delegation can also be more flexible than subclassing since sub objects can even change their supers by reassigning the delegate reference dynamically Delegation can also be used to obtain the effects of multiple code inheritance For example if a classmust implement two unrelated interfaces say Tank andjava awt event ActionListener and there are two available superclasses providing theneeded functionality then one of these may be subclassed and the other delegated However delegation is less powerful than subclassing in some other respects For example self callsin superclasses are not automatically bound to the versions of methods that have been overridden in delegation based subclasses Adapter designs can also run into snags revolving around the factthat the Adaptee and Adapter objects are different objects For example object reference equality testsmust be performed more carefully since a test to see if you have the Adaptee version of an object failsif you have the Adapter version and vice versa Most of these problems can be avoided via the extreme measure of declaring all methods in Adapteeclasses to take an apparent self argument referring to the Adapter and always using it instead ofthis even for self calls and identity checks for example by overriding Object equals Some people reserve the term delegation for objects and classes written in this style rather than theforwarding techniques that are almost always used to implement simple Adapters Template methodsWhen you are pretty sure that you are going to rely on before after control in a set of related classes you can create an abstract class that automates the control sequence via an application of the TemplateMethod pattern which has nothing to do with C generic types An abstract class supporting template methods sets up a framework facilitating construction ofsubclasses that may override the ground level actions the before after methods or both Basic ground level action code is defined in non public methods By convention we namethe non public version of any method method as doMethod Somewhat less flexibly these methods need not be declared non public if they are instead designed to be overriddenin subclasses Before and after operations are also defined as non public methods Public methods invoke the ground methods between the before and after methods Applying this to the Tank example leads to abstract class AbstractTank implements Tank protected void checkVolumeInvariant throws AssertionError identical to AdaptedTank version protected abstract void doTransferWater float amount throws OverflowException UnderflowException public synchronized void transferWater float amount throws OverflowException UnderflowException identical to AdaptedTank version except for inner call try doTransferWater amount class ConcreteTank extends AbstractTank protected final float capacity protected float volume public float getVolume return volume public float getCapacity return capacity protected void doTransferWater float amount throws OverflowException UnderflowException implementation code Method AdaptersThe most flexible but sometimes most awkward approach to before after control is to define a classwhose entire purpose is to invoke a particular method on a particular object In the Command Objectpattern and its many variants instances of such classes can then be passed around manipulated andultimately executed here between before after operations Because of static typing rules there must be a different kind of adapter class for each kind of methodbeing wrapped To avoid proliferation of all these types most applications restrict attention to onlyone or a small set of generic interfaces each defining a single method For example the Threadclass and most other execution frameworks accept only instances of interface Runnable in order toinvoke their argumentless resultless exceptionless run methods Similarly in we defineand use interface Callable containing only a method call that accepts one Object argument returns an Object and may throw any Exception In more focused applications you can define any suitable single method interface instantiate animplementation almost always via an anonymous inner class and then pass it around for laterexecution This technique is used extensively in the java awt and javax swing packages which define interfaces and abstract classes associated with different kinds of event handling methods In some other languages function pointers and closures are defined and used to achieve some ofthese effects We can apply a version of before after layering based on method adapters here by first defining aTankOp interface interface TankOp void op throws OverflowException UnderflowException In the following sample code uncharacteristically all uses of method adapters are local to theTankWithMethodAdapter class Also in this tiny example there is only one wrappablemethod However the same scaffolding could be used for any other Tank methods defined in thisclass or its subclasses Method adapters are much more common in applications where instances mustbe registered and or passed around among multiple objects before being executed which justifies theextra setup costs and programming obligations class TankWithMethodAdapter protected void checkVolumeInvariant throws AssertionError identical to AdaptedTank version protected void runWithinBeforeAfterChecks TankOp cmd throws OverflowException UnderflowException identical to AdaptedTank transferWater except for inner call try cmd op protected void doTransferWater float amount throws OverflowException UnderflowException implementation code public synchronized void transferWater final float amount throws OverflowException UnderflowException runWithinBeforeAfterChecks new TankOp public void op throws OverflowException UnderflowException doTransferWater amount Some applications of method adapters can be partially automated by using reflection facilities Ageneric constructor can probe a class for a particular java lang reflect Method set uparguments for it invoke it and transfer back results This comes at the price of weaker staticguarantees greater overhead and the need to deal with the many exceptions that can arise So this isgenerally only worthwhile when dealing with unknown dynamically loaded code More extreme and exotic reflective interception techniques are available if you escape the confines ofthe language For example it is possible to create and apply tools that splice bytecodes representingbefore and after actions into compiled class representations or do so upon class loading Further ReadingsThere are many useful design patterns besides those that are particular to concurrent programming and surely many others relating to concurrency that are not included in this book Other bookspresenting patterns and pattern related aspects of software design include Buschmann Frank Regine Meunier Hans Rohnert Peter Sommerlad and Michael Stal Pattern Oriented Software Architecture A System of Patterns Wiley Coplien James Advanced C Programming Styles and Idioms Addison Wesley Fowler Martin Analysis Patterns Addison Wesley Gamma Erich Richard Helm Ralph Johnson and John Vlissides Design Patterns Addison Wesley The Gang of Four book Rising Linda The Patterns Handbook Cambridge University Press Shaw Mary and David Garlan Software Architecture Prentice Hall Various editors Pattern Languages of Program Design Addison Wesley This series incorporatespatterns presented at the annual Pattern Languages of Programming PLoP conference The OO language Self is among the few that directly support a pure delegation based style ofprogramming without requiring explicit message forwarding See Ungar David The Self Papers Lisp and Symbolic Computation Reflective before after techniques are often seen in Lisp Scheme and CLOS the Common LispObject System See for example Abelson Harold and Gerald Sussman Structure and Interpretation of Computer Programs MITPress Kiczales Gregor Jim des Rivieres and Daniel Bobrow The Art of the Metaobject Protocol MITPress Additional layered synchronization design patterns are discussed in Rito Silva Ant nio Jo o Pereira and Jos Alves Marques Object Synchronizer in Neil Harrison Brian Foote and Hans Rohnert eds Pattern Languages of Program Design Volume Addison Wesley A compositional approach to layering concurrency control is described in Holmes David Synchronisation Rings Composable Synchronisation for Concurrent Object OrientedSystems PhD Thesis Macquarie University Composition of collections of before after methods that deal with different aspects of functionality for example mixing synchronization control with persis tence control may require more elaborateframeworks than discussed here One approach is to construct a metaclass framework that partiallyautomates the interception and wrapping of methods by class objects For an extensive analysis anddiscussion of the resulting composition techniques see Forman Ira and Scott Danforth Putting Metaclasses to Work Addison Wesley Aspect oriented programming replaces layered before after techniques with tools that weave togethercode dealing with different aspects of control Reports on the language AspectJ include someexamples from this book expressed in an aspect oriented fashion See Kiczales Gregor John Lamping Anurag Mendhekar Chris Maeda Cristina Videira Lopes Jean Marc Loingtier and John Irwin Aspect Oriented Programming Proceedings of the EuropeanConference on Object Oriented Programming ECOOP Several tools are available for partially automating invariant tests See for example Beck Kent and Erich Gamma Test Infected Programmers Love Writing Tests The Java Report July Chapter ExclusionIn a safe system every object protects itself from integrity violations This sometimes requires thecooperation of other objects and their methods Exclusion techniques preserve object invariants and avoid effects that would result from acting uponeven momentarily inconsistent state representations Programming techniques and design patternsachieve exclusion by preventing multiple threads from concurrently modifying or acting upon objectrepresentations All approaches rely on one or more of three basic strategies Eliminating the need for some or all exclusion control by ensuring that methods never modify anobject s representation so that the object cannot enter inconsistent states Dynamically ensuring that only one thread at a time can access object state by protecting objects withlocks and related constructs Structurally ensuring that only one thread or only one thread at a time can ever use a given object by hiding or restricting access to it The first three sections of this chapter describe the central features and usage patterns surroundingeach of these approaches immutability synchronization and confinement Section discusses some ways to combine these different approaches to improve safety liveness performance and or semantic guarantees Section shows how to use utility classes to obtaineffects that are otherwise difficult to arrange using built in constructs Additionally several of theclasses techniques and utilities described in Chapter can be used to ensure exclusion see especially The mandatory use of these techniques represents an important difference between sequential andconcurrent programming practices To guarantee safety in a concurrent system you must ensure thatall objects accessible from multiple threads either are immutable or employ appropriatesynchronization and also must ensure that no other object ever becomes concurrently accessible byleaking out of its ownership domain While the techniques that help maintain these guarantees are inmany ways just extensions of other OO development practices concurrent programs are typically lesstolerant of error As discussed in most of these matters cannot by nature be enforced by compilers or run timesystems Analysis and testing tools may be helpful in detecting some kinds of failure but the mainresponsibility for ensuring the safety of each class component subsystem application and systemfalls on its developers Additionally exclusion related policies and design rules must be explicit andwell advertised Much caution is needed when using code that was not designed to operate in multithreadedenvironments Most classes in the java packages are designed to be thread safe when applied intheir intended usage contexts Some exceptions are noted as they arise in this book Other limitationsappear in class API documentation However when constructing multithreaded applications it isoften necessary to rework or wrap see your own classes and packages that were originallydesigned only for use in single threaded contexts ImmutabilityIf an object cannot change state then it can never encounter conflicts or inconsistencies when multipleactivities attempt to change its state in incompatible ways Programs are much simpler to understand if existing objects are never changed but instead new onesare continually created during the course of any computation Unfortunately such programs aregenerally unable to handle interaction via user interfaces cooperating threads and so on However selective use of immutability is a basic tool in concurrent OO programming The simplest immutable objects have no internal fields at all Their methods are intrinsically stateless they do not rely on any assignable fields of any object For example all possible uses of thefollowing StatelessAdder class and its add method are obviously always safe and live class StatelessAdder public int add int a int b return a b The same safety and liveness properties hold in classes possessing only final fields Instances ofimmutable classes cannot experience low level read write or write write conflicts see because values are never written And as long as their initial values are established in a consistent legal fashion these objects cannot experience higher level invariant failures For example class ImmutableAdder private final int offset public ImmutableAdder int a offset a public int addOffset int b return offset b ApplicationsIt is of course possible to create immutable objects that contain more interesting structure andfunctionality than seen in ImmutableAdder Applications include abstract data types valuecontainers and shared state representations Abstract Data Types ADTs Immutable objects can serve as instances of simple abstract data types representing values Somecommon ones are already defined in the java packages These include java awt Color java lang Integer java math BigDecimal java lang String andothers It is easy to define your own ADT classes for example Fraction Interval ComplexFloat and so on Instances of such classes never alter their constructed field values butmay provide methods that create objects representing new values For example Note however that some other ADT style classes in the java packages are not immutable forexample java awt Point class Fraction protected final long numerator protected final long denominator Fragmentspublic Fraction long num long den normalize boolean sameSign num den long n num num num long d den den den long g gcd n d numerator sameSign n g n g denominator d g static long gcd long a long b compute greatest common divisor public Fraction plus Fraction f return new Fraction numerator f denominator f numerator denominator denominator f denominator public boolean equals Object other override defaultif other instanceof Fraction return false Fraction f Fraction other return numerator f denominator denominator f numerator public int hashCode override defaultreturn int numerator denominator Classes that represent immutable data abstractions have instances that serve only to encapsulatevalues so their identities are not important For example two java awt Color objects that bothrepresent black via RGB value are typically intended to be treated as equivalent This is one reasonwhy ADT style classes should normally override methods Object equals andObject hashCode to reflect equality of abstract value as illustrated in the Fraction class The default implementations of these methods rely on the identities of objects maintaining thesevalues Masking identity by overriding equals enables multiple ADT objects to represent the samevalues and or perform the same functionality without clients needing to know or care exactly whichADT object is being used at any given time You don t always have to commit to immutable representations of ADTs across an entire program Itis sometimes helpful to define different classes supporting different usages for the immutable versusupdatable versions of some concept For example class java lang String is immutable while class java lang StringBuffer is updatable relying on synchronized methods Value containersImmutable objects can be used when it is necessary or convenient to establish some consistent stateonce and then rely on it forever more For example an immutable ProgramConfigurationobject may reflect all of the settings to be used during the execution of a given program Immutable value containers can also be useful whenever creating different variants versions or statesof an object by creating new ones through partial copying is relatively rare or cheap In these cases the expense of copying may be outweighed by the benefits of never needing to synchronize statechanges see The analog of a state change for an immutable object is to produce a newimmutable object that differs from the original in some specified way SharingImmutability is a useful technical device when you would like to share objects for space efficiency and still provide efficient access to these objects One immutable object can be referenced by anynumber of other objects without concern for synchronization or access restriction For example manyindividual character or glyph objects may all share references to the same immutable font object This is one application of the Flyweight pattern described in the Design Patterns book MostFlyweights designs are simplest to establish by ensuring the immutability of shared representations Instances of many utility classes used in concurrent settings are intrinsically immutable and are sharedby many other objects For example class Relay protected final Server server Relay Server s server s void doIt server doIt While purely immutable objects are simple convenient prevalent and useful many concurrent OOprograms also rely on partial immutability constancy for only some fields or only after executionof a particular method or only over some period of interest Exploitation of immutability is a usefulstrategy for producing designs that would be difficult at best to realize using updatable objects Anumber of such designs are presented in the course of this book especially in ConstructionTo be effective all design decisions relying on immutability must be enforced via appropriate use ofthe final keyword Additionally some care is required when initializing immutable objects see In particular it is counterproductive to make an immutable object available to others before ithas been fully initialized As a general rule holding for any kind of class Do not allow fields to be accessed until construction is complete This can be harder to ensure in concurrent settings than in sequential programs Constructors shouldperform only actions directly related to field initialization They should not invoke any other methodswhose effects may rely on the object being fully constructed Constructors should avoid recording areference to the object being constructed in fields or tables accessible by others avoid making calls toother methods with this as an argument and more generally avoid allowing the reference to thisto escape see Without such precautions other objects and methods running in other threadscould instead access the default initialized zeros for scalar fields or nulls for reference fields set bythe JVM for each Object before its constructor is executed In some cases the values of conceptually immutable fields cannot be fully initialized in constructors for example when they are incrementally initialized from files or when there are interdependenciesamong multiple objects being constructed at the same time Further care is needed to ensure that theseobjects are not made available for use by others until values are stable This almost always requiresuse of synchronization see for example and SynchronizationLocking protects against low level storage conflicts and corresponding high level invariant failures For example consider the following class class Even Do not useprivate int n public int next POST next is always even n n return n Without locking the desired postcondition may fail due to a storage conflict when two or morethreads execute the next method of the same Even object Here is one possible execution trace showing only the reads and writes to variable n that would result from the putfields andgetfields in compiled bytecode Thread AThread Bread write read write return read write read write return As is typical in concurrent programs most traces of two threads concurrently executingEven next do not display this safety violation Programs using this version of Even are likely topass some tests but are almost sure to break eventually Such safety violations can be rare and difficultto test for yet can have devastating effects This motivates the careful conservative design practicesseen in reliable concurrent programs Declaring the next method as synchronized would preclude such conflicting traces Lockingserializes the execution of synchronized methods So here either thread A s next methodwould execute in full before thread B s or vice versa MechanicsAs a preliminary to further discussions of design strategies based on locking here is a summary ofmechanics as well as some usage notes surrounding the synchronized keyword Objects and locksEvery instance of class Object and its subclasses possesses a lock Scalars of type int float etc are not Objects Scalar fields can be locked only via their enclosing objects Individual fieldscannot be marked as synchronized Locking may be applied only to the use of fields withinmethods However as described in fields can be declared as volatile which affectsatomicity visibility and ordering properties surrounding their use Similarly array objects holding scalar elements possess locks but their individual scalar elements donot Further there is no way to declare array elements as volatile Locking an array ofObjects does not automatically lock all its elements There are no constructs for simultaneouslylocking multiple objects in a single atomic operation Class instances are Objects As described below the locks associated with Class objects areused in static synchronized methods Synchronized methods and blocksThere are two syntactic forms based on the synchronized keyword blocks and methods Blocksynchronization takes an argument of which object to lock This allows any method to lock any object The most common argument to synchronized blocks is this Block synchronization is considered more fundamental than method synchronization A declaration synchronized void f body is equivalent to void f synchronized this body The synchronized keyword is not considered to be part of a method s signature So thesynchronized modifier is not automatically inherited when subclasses override superclassmethods and methods in interfaces cannot be declared as synchronized Also constructors cannot be qualified as synchronized although block synchronization can be usedwithin constructors Synchronized instance methods in subclasses employ the same lock as those in their superclasses Butsynchronization in an inner class method is independent of its outer class However a non static innerclass method can lock its containing class say OuterClass via code blocks using synchronized OuterClass this body Acquiring and releasing locksLocking obeys a built in acquire release protocol controlled only by use of the synchronizedkeyword All locking is block structured A lock is acquired on entry to a synchronized methodor block and released on exit even if the exit occurs due to an exception You cannot forget to releasea lock Locks operate on a per thread not per invocation basis A thread hitting synchronized passes ifthe lock is free or the thread already possess the lock and otherwise blocks This reentrant orrecursive locking differs from the default policy used for example in POSIX threads Among othereffects this allows one synchronized method to make a self call to another synchronizedmethod on the same object without freezing up A synchronized method or block obeys the acquire release protocol only with respect to othersynchronized methods and blocks on the same target object Methods that are notsynchronized may still execute at any time even if a synchronized method is in progress In other words synchronized is not equivalent to atomic but synchronization can be used toachieve atomicity When one thread releases a lock another thread may acquire it perhaps the same thread if it hitsanother synchronized method But there is no guarantee about which of any blocked threadswill acquire the lock next or when they will do so In particular there are no fairness guarantees see There is no mechanism to discover whether a given lock is being held by some thread As discussed in in addition to controlling locking synchronized also has the side effectof synchronizing the underlying memory system StaticsLocking an object does not automatically protect access to static fields of that object s class or anyof its superclasses Access to static fields is instead protected via synchronized staticmethods and blocks Static synchronization employs the lock possessed by the Class objectassociated with the class the static methods are declared in The static lock for class C can also beaccessed inside instance methods via synchronized C class body The static lock associated with each class is unrelated to that of any other class including itssuperclasses It is not effective to add a new static synchronized method in a subclass thatattempts to protect static fields declared in a superclass Use the explicit block version instead It is also poor practice to use constructions of the form synchronized getClass body Do not useThis locks the actual class which might be different from a subclass of the class defining thestatic fields that need protecting The JVM internally obtains and releases the locks for Class objects during class loading andinitialization Unless you are writing a special ClassLoader or holding multiple locks duringstatic initialization sequences these internal mechanics cannot interfere with the use of ordinarymethods and blocks synchronized on Class objects No other internal JVM actions independentlyacquire any locks for any objects of classes that you create and use However if you subclassjava classes you should be aware of the locking policies used in these classes Fully Synchronized ObjectsA lock is the most basic kind of message acceptance control mechanism Locks may be used to blockclients attempting to invoke a method on an object while another method or code block running in adifferent thread is in progress The safest but not always the best concurrent OO design strategy based on locking is to restrictattention to fully synchronized objects also known as atomic objects in which All methods are synchronized There are no public fields or other encapsulation violations All methods are finite no infinite loops or unbounded recursion and so eventually releaselocks All fields are initialized to a consistent state in constructors The state of the object is consistent obeys invariants at both the beginning and end of eachmethod even in the presence of exceptions For example consider the following ExpandableArray class a simplified variant ofjava util Vector class ExpandableArray protected Object data the elementsprotected int size the number of array slots used INV size data lengthpublic ExpandableArray int cap data new Object cap public synchronized int size return size public synchronized Object get int i subscripted accessthrows NoSuchElementException if i i size throw new NoSuchElementException return data i public synchronized void add Object x add at endif size data length need a bigger arrayObject olddata data data new Object size System arraycopy olddata data olddata length data size x public synchronized void removeLast throws NoSuchElementException if size throw new NoSuchElementException data size null Without synchronization an instance of this class could not be used reliably in concurrent settings For example it could encounter a read write conflict if processing the accessor at while in the midstof a removeLast operation And it could encounter a write write conflict if concurrentlyperforming two add operations in which case the state of the data array would be very difficult topredict TraversalIn fully synchronized classes you can add another atomic operation just by encasing it in asynchronized method For the sake of reusability and convenience it is often a good idea to addsmall suites of such operations to general purpose classes or their subclasses This avoids makingclients go through contortions trying to construct atomic versions of commonly used operations out ofsmaller components For example it would be useful to define synchronized versions ofremoveFirst prepend and similar methods to ExpandableArray as found injava util Vector and other collection classes However this strategy doesn t work for another common usage of collections traversal A traversaliterates through all elements of a collection and performs some operation on or using each element Since there are an unbounded number of operations clients might want to apply to the elements of acollection it is pointless to try to code all of them as synchronized methods There are three common solutions to this design problem aggregate operations indexed traversal andversioned iterators each of which reflect different design trade offs See and for additional strategies that apply to other kinds of collection classes The issues and trade offs encountered in each approach are seen more generally in the design of many classes using locks Synchronized aggregate operationsOne way to secure traversal is to abstract out the operation being applied to each element so that it canbe sent as an argument to a single synchronized applyToAll method For example interface Procedure void apply Object obj class ExpandableArrayWithApply extends ExpandableArray public ExpandableArrayWithApply int cap super cap synchronized void applyToAll Procedure p for int i i size i p apply data i This could be used for example to print all elements in collection v v applyToAll new Procedure public void apply Object obj System out println obj This approach eliminates potential interference that could occur if other threads attempted to add orremove elements during traversal but at the expense of possibly holding the lock on the collection forprolonged periods While this is often acceptable it may lead to the kinds of liveness and performanceproblems that motivated the default rule in saying to release locks when making method calls here to apply Indexed traversal and client side lockingA second traversal strategy available with ExpandableArray is to require clients to use theindexed accessor methods for traversal for example for int i i v size i System out println v get i Do not useThis avoids holding the lock on v while performing each element operation but at the expense of twosynchronized operations size and at per element More importantly the loop must be rewritten tohandle a potential interference problem resulting from the finer locking granularity It is possible forthe check of i v size to succeed but for another thread to remove the current last elementbefore the call to v get i One way to deal with this is to employ client side locking to preserveatomicity across the size check and access for int i true i Limited utility Object obj null synchronized v if i v size obj v get i elsebreak System out println obj However even this can be problematic For example if the ExpandableArray class supportedmethods to rearrange elements this loop could print the same element twice if v were modifiedbetween iterations As a more extreme measure clients can surround the entire traversal with synchronized v Again this is often acceptable but can induce the long term locking problems seen insynchronized aggregate methods If the operations on elements are time consuming the clientcan instead first make a copy of the array for traversal purposes Object snapshot synchronized v snapshot new Object v size for int i i snapshot length i snapshot i v get i for int i snapshot length i System out println snapshot i Client side locking tends to be used more extensively in non object oriented approaches tomultithreaded programming This style is sometimes more flexible and can be useful in OO systemswhen instances of a class are designed to be embedded within others see and so must give upinternal responsibility for synchronization decisions But client side locking avoids potential interference problems at the expense of encapsulationbreakdown Correctness here relies on special knowledge of the inner workings of theExpandableArray class that may fail to hold if the class is later modified Still this may beacceptable in closed subsystems Client side locking can also be a reasonable option when classesdocument these usages as sanctioned This also constrains all future modifications and subclasses tosupport them as well Versioned iteratorsA third approach to traversal is for a collection class to support fast fail iterators that throw anexception if the collection is modified in the midst of a traversal The simplest way to arrange this is tomaintain a version number that is incremented upon each update to the collection The iterator canthen check this value whenever asked for the next element and throw an exception if it has changed The version number field should be wide enough that it can never wrap around while a traversal is inprogress An int normally suffices This strategy is used in the java util Iterator classes in the collections framework We canapply it here to a subclass of ExpandableArray that updates version numbers as an after action see class ExpandableArrayWithIterator extends ExpandableArray protected int version public ExpandableArrayWithIterator int cap super cap public synchronized void removeLast throws NoSuchElementException super removeLast version advertise update public synchronized void add Object x super add x version public synchronized Iterator iterator return new EAIterator protected class EAIterator implements Iterator protected final int currentVersion protected int currentIndex EAIterator currentVersion version public Object next synchronized ExpandableArrayWithIterator this if currentVersion version throw new ConcurrentModificationException else if currentIndex size throw new NoSuchElementException elsereturn data currentIndex public boolean hasNext synchronized ExpandableArrayWithIterator this return currentIndex size public void remove similar Here the print loop would be expressed as for Iterator it v iterator it hasNext try System out println it next catch NoSuchElementException ex fail catch ConcurrentModificationException ex fail Even here choices for dealing with failures are often very limited AConcurrentModificationException often signifies unplanned unwanted interactionsamong threads that should be remedied rather than patched over The versioned iterator approach encapsulates the design choices underlying the data structure at theprice of occasionally undue conservatism For example an interleaved add operation would notinterfere with the required semantics of a typical traversal yet would cause an exception to be thrownhere Versioned iterators are still a good default choice for collection classes in part because it isrelatively easy to layer aggregate traversal or client side locking on top of these iterators but not viceversa VisitorsThe Visitor pattern described in the Design Patterns book extends the notion of iterators to providesupport for clients performing operations on sets of objects connected in arbitrary ways thus formingthe nodes of some kind of tree or graph rather than the sequential list seen in ExpandableArray Less relevantly here the Visitor pattern also supports polymorphic operations on each node The options and concerns for visitors and other extended senses of traversal are similar to and cansometimes be reduced to those seen in simple iterators For example you might first create a list of allnodes to traverse and then apply any of the above techniques for traversing the list However lockshere would lock only the list not the nodes themselves This is usually the best policy But if you needto ensure that all of the nodes are locked during the entire traversal consider forms of confinement see or containment locking see Conversely if traversal is arranged by every node supporting a nextNode method and you do notwant to end up simultaneously holding all locks to all nodes encountered during traversal synchronization of each node must be released before proceeding to the next node as described in and Statics and SingletonsAs described in the Design Patterns book a Singleton class intentionally supports only one instance It is convenient to declare that single instance as a static in which case both class and instancemethods may use the same lock Here is one way to define a fully synchronized singleton class that postpones construction of theinstance until it is first accessed via the instance method This class represents a counter thatcould be used to assign global sequence numbers to objects transactions messages etc acrossdifferent classes in an application Just to illustrate computation during initialization the initial valueis set to a randomly chosen number with at least positive successors class LazySingletonCounter private final long initial private long count private LazySingletonCounter initial Math abs new java util Random nextLong count initial private static LazySingletonCounter s null private static final Object classLock LazySingletonCounter class public static LazySingletonCounter instance synchronized classLock if s null s new LazySingletonCounter return s public long next synchronized classLock return count public void reset synchronized classLock count initial The locking mechanics seen here or any of several minor variants prevent situations in which twodifferent threads invoke the instance method at about the same time causing two instances to becreated Only one of these instances would be bound to s and returned the next time instance isinvoked As discussed in in a few cases this and other intentional semantic weakenings mightbe acceptable in most cases however this would be a serious error An easier way to avoid this kind of error is to avoid lazy initialization Because JVMs performdynamic loading of classes there is usually no need to support lazy initialization of singletons Astatic field is not initialized until the class is loaded at runtime While there are no guaranteesabout exactly when a class will be loaded beyond that it will be loaded by the time it is accessed byexecuting code full initialization of statics is less likely to impose significant start up overhead thanin most other languages So unless initialization is both very expensive and rarely needed it is usuallypreferable to take the simpler approach of declaring a singleton as a static final field Forexample class EagerSingletonCounter private final long initial private long count private EagerSingletonCounter initial Math abs new java util Random nextLong count initial private static final EagerSingletonCounter s new EagerSingletonCounter public static EagerSingletonCounter instance return s public synchronized long next return count public synchronized void reset count initial Simpler yet if there is no compelling reason to rely on instances you can instead define and use aversion with all static methods as in class StaticCounter private static final long initial Math abs new java util Random nextLong private static long count initial private StaticCounter disable instance constructionpublic static synchronized long next return count public static synchronized void reset count initial Also consider using ThreadLocal see rather than a Singleton in situations where it ismore appropriate to create one instance of a class per thread than one instance per program DeadlockAlthough fully synchronized atomic objects are always safe threads using them are not always live Consider for example a Cell class containing a method that swaps values with another Cell class Cell Do not useprivate long value synchronized long getValue return value synchronized void setValue long v value v synchronized void swapValue Cell other long t getValue long v other getValue setValue v other setValue t SwapValue is a synchronized multiparty action one that intrinsically acquires locks on multipleobjects Without further precautions it is possible for two different threads one runninga swapValue b and the other running b swapValue a to deadlock when encounteringthe following trace Thread acquire lock for a on enteringa swapValue b pass lock for a since already held onentering t getValue block waiting for lock for b on entering v other getValue Thread acquire lock for b on enteringb swapValue a pass lock for b since already held onentering t getValue block waiting for lock for a on entering v other getValue At this point both threads block forever More generally deadlock is possible when two or more objects are mutually accessible from two ormore threads and each thread holds one lock while trying to obtain another lock already held byanother thread Resource OrderingThe need to preclude or recover from deadlocks and other liveness failures motivates the use of otherexclusion techniques presented in this chapter However one simple technique resource ordering canbe applied to classes such as Cell without otherwise altering their structure The idea behind resource ordering is to associate a numerical or any other strictly orderable datatype tag with each object that can be held in a nested synchronized block or method Ifsynchronization is always performed in least first order with respect to object tags then situations cannever arise in which one thread has the synchronization lock for x while waiting for y and another hasthe lock for y while waiting for x Instead they will both obtain the locks in the same order thusavoiding this form of deadlock More generally resource ordering can be used whenever there is aneed to arbitrarily break symmetry or force precedence in a concurrent design In some contexts see for example there may be reasons to impose some specific orderingrules surrounding a set of locks But in others you can use any convenient tag for lock orderingpurposes For example you may be able to use the value returned bySystem identityHashCode This method always returns the default implementation ofObject hashCode even if a class overrides the hashCode method While there is no guaranteethat identityHashCode is unique in practice run time systems rely on codes to be distinct witha very high probability To be even safer about it you could override method hashCode orintroduce another tag method to ensure uniqueness in any classes employing resource ordering Forexample you could assign each object a sequence number using one of the classes in One further check alias detection can be applied in methods using nested synchronization to handlecases in which two or more of the references are actually bound to the same object For example inswapValue you can check whether a Cell is being asked to swap with itself This kind of checkis strictly optional here but see Synchronization lock access is per thread not per invocation Additional attempts to synchronize on already held objects will still work However routine alias checking is a useful way to forestall downstream functionality efficiency and synchronization basedcomplications It may be applied before using synchronization surrounding two or more objects unlessthey are of distinct unrelated types Two references of two unrelated declared types cannot possiblybe referring to the same object anyway so there is no reason to check A better version of swapValue applying both resource ordering and alias detection can be writtenas public void swapValue Cell other if other this alias checkreturn else if System identityHashCode this System identityHashCode other this doSwapValue other elseother doSwapValue this protected synchronized void doSwapValue Cell other same as original public version long t getValue long v other getValue setValue v other setValue t As a minor efficiency tweak we could further streamline the code inside doSwapValue first toacquire the necessary locks and then directly access the value fields This avoids a self call to asynchronized method while already holding the required lock at the minor expense of addinglines of code that would need to be changed if the nature of the fields were ever modified slightly faster versionprotected synchronized void doSwapValue Cell other synchronized other long t value value other value other value t Note that the lock for this is obtained via the synchronized method qualifier but the lock forother is explicitly acquired A further very tiny perhaps nonexistent performance improvementmight be obtained by folding the code in doSwapValue into swapValue remembering toacquire both locks explicitly Lock ordering problems are by no means restricted to methods using nested synchronization Theissue arises in any code sequence in which a synchronized method holding the lock on one object inturn calls a synchronized method on another object However there is less opportunity to applyresource ordering in cascaded calls In the general case one object cannot know for sure which otherobjects will be involved in downstream calls and whether they require synchronization This is onereason that deadlock can be such a hard problem in open systems see when you cannot releasesynchronization during calls see The Java Memory ModelConsider the tiny class defined without any synchronization final class SetCheck private int a private long b void set a b boolean check return b b a In a purely sequential language the method check could never return false This holds eventhough compilers run time systems and hardware might process this code in a way that you mightnot intuitively expect For example any of the following might apply to the execution of methodset The compiler may rearrange the order of the statements so b may be assigned before a Ifthe method is inlined the compiler may further rearrange the orders with respect to yet otherstatements The processor may rearrange the execution order of machine instructions corresponding to thestatements or even execute them at the same time The memory system as governed by cache control units may rearrange the order in whichwrites are committed to memory cells corresponding to the variables These writes mayoverlap with other computations and memory actions The compiler processor and or memory system may interleave the machine level effects ofthe two statements For example on a bit machine the high order word of b may bewritten first followed by the write to a followed by the write to the low order word of b The compiler processor and or memory system may cause the memory cells representing thevariables not to be updated until sometime after if ever a subsequent check is called butinstead to maintain the corresponding values for example in CPU registers in such a waythat the code still has the intended effect In a sequential language none of this can matter so long as program execution obeys as if serialsemantics Sequential programs cannot depend on the internal processing details of statementswithin simple code blocks so they are free to be manipulated in all these ways This provides essentialflexibility for compilers and machines Exploitation of such opportunities via pipelined superscalarCPUs multilevel caches load store balancing interprocedural register allocation and so on isresponsible for a significant amount of the massive improvements in execution speed seen incomputing over the past decade The as if serial property of these manipulations shields sequentialprogrammers from needing to know if or how they take place Programmers who never create theirown threads are almost never impacted by these issues Somewhat more precisely as if serial also known as program order semantics can be defined as anyexecution traversal of the graph formed by ordering only those operations that have value or controldependencies with respect to each other under a language s base expression and statement semantics Things are different in concurrent programming Here it is entirely possible for check to be calledin one thread while set is being executed in another in which case the check might be spying onthe optimized execution of set And if any of the above manipulations occur it is possible forcheck to return false For example as detailed below check could read a value for the longb that is neither nor but instead a half written in between value Also out of order execution ofthe statements in set may cause check to read b as but then read a as still In other words not only may concurrent executions be interleaved but they may also be reordered andotherwise manipulated in an optimized form that bears little resemblance to their source code Ascompiler and run time technology matures and multiprocessors become more prevalent suchphenomena become more common They can lead to surprising results for programmers withbackgrounds in sequential programming in other words just about all programmers who have neverbeen exposed to the underlying execution properties of allegedly sequential code This can be thesource of subtle concurrent programming errors In almost all cases there is an obvious simple way to avoid contemplation of all the complexitiesarising in concurrent programs due to optimized execution mechanics Use synchronization Forexample if both methods in class SetCheck are declared as synchronized then you can besure that no internal processing details can affect the intended outcome of this code But sometimes you cannot or do not want to use synchronization Or perhaps you must reason aboutsomeone else s code that does not use it In these cases you must rely on the minimal guarantees aboutresulting semantics spelled out by the Java Memory Model This model allows the kinds ofmanipulations listed above but bounds their potential effects on execution semantics and additionallypoints to some techniques programmers can use to control some aspects of these semantics most ofwhich are discussed in The Java Memory Model is part of The JavaTM Language Specification described primarily in JLSchapter Here we discuss only the basic motivation properties and programming consequences ofthe model The treatment here reflects a few clarifications and updates that are missing from the firstedition of JLS As of this writing the memory model and other relevant sections of JLS are still being updated to coverthe Java Platform Please check the online supplement for any changes that impact the material in thissection The assumptions underlying the model can be viewed as an idealization of a standard SMP machine ofthe sort described in For purposes of the model every thread can be thought of as running on a different CPU from anyother thread Even on multiprocessors this is infrequent in practice but the fact that this CPU per thread mapping is among the legal ways to implement threads accounts for some of the model sinitially surprising properties For example because CPUs hold registers that cannot be directlyaccessed by other CPUs the model must allow for cases in which one thread does not know aboutvalues being manipulated by another thread However the impact of the model is by no meansrestricted to multiprocessors The actions of compilers and processors can lead to identical concernseven on single CPU systems The model does not specifically address whether the kinds of execution tactics discussed above areperformed by compilers CPUs cache controllers or any other mechanism It does not even discussthem in terms of classes objects and methods familiar to programmers Instead the model defines anabstract relation between threads and main memory Every thread is defined to have a workingmemory an abstraction of caches and registers in which to store values The model guarantees a fewproperties surrounding the interactions of instruction sequences corresponding to methods andmemory cells corresponding to fields Most rules are phrased in terms of when values must betransferred between the main memory and per thread working memory The rules address threeintertwined issues Atomicity Which instructions must have indivisible effects For purposes of the model these rulesneed to be stated only for simple reads and writes of memory cells representing fields instance andstatic variables also including array elements but not including local variables inside methods Visibility Under what conditions the effects of one thread are visible to another The effects of interesthere are writes to fields as seen via reads of those fields Ordering Under what conditions the effects of operations can appear out of order to any given thread The main ordering issues surround reads and writes associated with sequences of assignmentstatements When synchronization is used consistently each of these properties has a simple characterization Allchanges made in one synchronized method or block are atomic and visible with respect to othersynchronized methods and blocks employing the same lock and processing ofsynchronized methods or blocks within any given thread is in program specified order Eventhough processing of statements within blocks may be out of order t his cannot matter to other threadsemploying synchronization When synchronization is not used or is used inconsistently answers become more complex Theguarantees made by the memory model are weaker than most programmers intuitively expect and arealso weaker than those typically provided on any given JVM implementation This imposes additionalobligations on programmers attempting to ensure the object consistency relations that lie at the heartof exclusion practices Objects must maintain invariants as seen by all threads that rely on them notjust by the thread performing any given state modification The most important rules and properties specified by the model are discussed below AtomicityAccesses and updates to the memory cells corresponding to fields of any type except long ordouble are guaranteed to be atomic This includes fields serving as references to other objects Additionally atomicity extends to volatile long and double Even though non volatilelongs and doubles are not guaranteed atomic they are of course allowed to be Atomicity guarantees ensure that when a non long double field is used in an expression youwill obtain either its initial value or some value that was written by some thread but not some jumbleof bits resulting from two or more threads both trying to write values at the same time However asseen below atomicity alone does not guarantee that you will get the value most recently written byany thread For this reason atomicity guarantees per se normally have little impact on concurrentprogram design VisibilityChanges to fields made by one thread are guaranteed to be visible to other threads only under thefollowing conditions A writing thread releases a synchronization lock and a reading thread subsequently acquiresthat same synchronization lock In essence releasing a lock forces a flush of all writes from working memory employed bythe thread and acquiring a lock forces a re load of the values of accessible fields While lockactions provide exclusion only for the operations performed within a synchronizedmethod or block these memory effects are defined to cover all fields used by the threadperforming the action Note the double meaning of synchronized it deals with locks that permit higher levelsynchronization protocols while at the same time dealing with the memory system sometimes via low level memory barrier machine instructions to keep value representationsin synch across threads This reflects one way in which concurrent programming bears moresimilarity to distributed programming than to sequential programming The latter sense ofsynchronized may be viewed as a mechanism by which a method running in one threadindicates that it is willing to send and or receive changes to variables to and from methodsrunning in other threads From this point of view using locks and passing messages might beseen merely as syntactic variants of each other If a field is declared as volatile any value written to it is flushed and made visible bythe writer thread before the writer thread performs any further memory operation i e for thepurposes at hand it is flushed immediately Reader threads must reload the values ofvolatile fields upon each access The first time a thread accesses a field of an object it sees either the initial value of the fieldor a value since written by some other thread As of this writing the JLS does not yet clearly state that the visible initial value read for aninitialized final field is the value assigned in its initializer or constructor However thisanticipated clarification is assumed throughout this book The visible initial default values of non final fields are zero for scalars and null for references Among other consequences it is bad practice to make available the reference to anincompletely constructed object see It can also be risky to start new threads inside aconstructor especially in a class that may be subclassed Thread start has the samememory effects as a lock release by the thread calling start followed by a lock acquire bythe started thread If a Runnable superclass invokes new Thread this start before subclass constructors execute then the object might not be fully initialized when therun method executes Similarly if you create and start a new thread T and then create anobject X used by thread T you cannot be sure that the fields of X will be visible to T unlessyou employ synchronization surrounding all references to object X Or when applicable youcan create X before starting T As a thread terminates all written variables are flushed to main memory For example if one thread synchronizes on the termination of another thread usingThread join then it is guaranteed to see the effects made by that thread see Note that visibility problems never arise when passing references to objects across methods in thesame thread The memory model guarantees that given the eventual occurrence of the above operations aparticular update to a particular field made by one thread will eventually be visible to another Buteventually can be an arbitrarily long time Long stretches of code in threads that use nosynchronization can be hopelessly out of synch with other threads with respect to values of fields Inparticular it is always wrong to write loops waiting for values written by other threads unless thefields are volatile or accessed via synchronization see The model also allows inconsistent visibility in the absence of synchronization For example it ispossible to obtain a fresh value for one field of an object but a stale value for another Similarly it ispossible to read a fresh updated value of a reference variable but a stale value of one of the fields ofthe object now being referenced However the rules do not require visibility failures across threads they merely allow these failures tooccur This is one aspect of the fact that not using synchronization in multithreaded code doesn tguarantee safety violations it just allows them On most current JVM implementations and platforms even those employing multiple processors detectable visibility failures rarely occur The use ofcommon caches across threads sharing a CPU the lack of aggressive compiler based optimizations and the presence of strong cache consistency hardware often cause values to act as if they propagateimmediately among threads This makes testing for freedom from visibility based errors impractical since such errors might occur extremely rarely or only on platforms you do not have access to oronly on those that have not even been built yet These same comments apply to multithreaded safetyfailures more generally Concurrent programs that do not use synchronization fail for many reasons including memory consistency problems OrderingOrdering rules fall under two cases within thread and between thread From the point of view of the thread performing the actions in a method instructions proceedin the normal as if serial manner that applies in sequential programming languages From the point of view of other threads that might be spying on this thread by concurrentlyrunning unsynchronized methods almost anything can happen The only useful constraint isthat the relative orderings of synchronized methods and blocks as well as operations onvolatile fields are always preserved Again these are only the minimal guaranteed properties In any given program or platform you mayfind stricter orderings But you cannot rely on them and you may find it difficult to test for code thatwould fail on JVM implementations that have different properties but still conform to the rules Note that the within thread point of view is implicitly adopted in all other discussions of semantics inJLS For example arithmetic expression evaluation is performed in left to right order JLS section as viewed by the thread performing the operations but not necessarily as viewed by otherthreads The within thread as if serial property is helpful only when only one thread at a time is manipulatingvariables due to synchronization structural exclusion or pure chance When multiple threads are allrunning unsynchronized code that reads and writes common fields then arbitrary interleavings atomicity failures race conditions and visibility failures may result in execution patterns that makethe notion of as if serial just about meaningless with respect to any given thread Even though JLS addresses some particular legal and illegal reorderings that can occur interactionswith these other issues reduce practical guarantees to saying that the results may reflect just about anypossible interleaving of just about any possible reordering So there is no point in trying to reasonabout the ordering properties of such code VolatileIn terms of atomicity visibility and ordering declaring a field as volatile is nearly identical ineffect to using a little fully synchronized class protecting only that field via get set methods as in final class VFloat private float value final synchronized void set float f value f final synchronized float get return value Declaring a field as volatile differs only in that no locking is involved In particular compositeread write operations such as the operation on volatile variables are not performedatomically Also ordering and visibility effects surround only the single access or update to the volatile fielditself Declaring a reference field as volatile does not ensure visibility of non volatile fieldsthat are accessed via this reference Similarly declaring an array field as volatile does not ensurevisibility of its elements Volatility cannot be manually propagated for arrays because array elementsthemselves cannot be declared as volatile Because no locking is involved declaring fields as volatile is likely to be cheaper than usingsynchronization or at least no more expensive However if volatile fields are accessedfrequently inside methods their use is likely to lead to slower performance than would locking theentire methods Declaring fields as volatile can be useful when you do not need locking for any other reason yetvalues must be accurately accessible across multiple threads This may occur when The field need not obey any invariants with respect to others Writes to the field do not depend on its current value No thread ever writes an illegal value with respect to intended semantics The actions of readers do not depend on values of other non volatile fields Using volatile fields can make sense when it is somehow known that only one thread can changea field but many other threads are allowed to read it at any time For example a Thermometerclass might declare its temperature field as volatile As discussed in avolatile can be useful as a completion flag Additional examples are illustrated in wherethe use of lightweight executable frameworks automates some aspects of synchronization butvolatile declarations are needed to ensure that result field values are visible across tasks Further ReadingsFeatures of computer architectures that impact multithreaded programs are described in Schimmel Curt UNIX Systems for Modern Architectures Symmetric Multiprocessing and Caching forKernel Programmers Addison Wesley Patterson David and John Hennessy Computer Organization and Design The Hardware SoftwareInterface Morgan Kaufmann See also its online supplement with links to further resources onspecific machine architectures Memory consistency models are the subject of increasing attention as both multiprocessors andmultithreaded programs become more common and their interactions become more of a concern Atleast with respect to locking the Java memory model is closest to the family of release consistencymodels For an overview see Adve Sarita and K Gharachorloo Shared Memory Consistency Models A Tutorial IEEEComputer December See also follow ups including Recent Advances in MemoryConsistency Models for Hardware Shared Memory Systems Proceedings of the IEEE special issueon distributed shared memory ConfinementConfinement employs encapsulation techniques to structurally guarantee that at most one activity at atime can possibly access a given object This statically ensures that the accessibility of a given objectis unique to a single thread without needing to rely on dynamic locking on each access The maintactic is to define methods and classes that establish leak proof ownership domains guaranteeing thatonly one thread or one thread at a time can ever access a confined object Confinement practices are similar to other security measures that guarantee that no sensitiveinformation ever escapes from a domain The information leakage of interest here is access to objects almost always via references to these objects This issue poses the same kinds of challenges seen inother aspects of security It is sometimes difficult to demonstrate that not even one leak is possible yetconfinement cannot be relied on unless a design is proven leak proof However this task is lesscritical than in some other aspects of security since there are backup strategies Thus when youcannot ensure confinement you can employ other exclusion techniques described in this chapter Confinement relies on the scoping access control and security features of a given language thatsupport data hiding and encapsulation However the senses of confinement needed to ensureuniqueness cannot be completely enforced by language mechanisms There are four categories tocheck to see if a reference r to an object x can escape from a method m executing within someactivity m passes r as an argument in a method invocation or object constructor m passes r as the return value from a method invocation m records r in some field that is accessible from another activity in the most flagrant case static fields that are accessible anywhere m releases in any of the above ways another reference that can in turn be traversed to accessr Selected leakages can sometimes be tolerated if you can somehow guarantee that escapes are allowedonly to methods that cannot cause state changes field assignments in the objects of interest see In some closed classes and subsystems see these matters can be exhaustively checked Inopen systems most constraints can only be maintained as design rules as assisted by tools andreviews This section discusses four sorts of confinement The first and simplest method confinement involvesordinary programming practices surrounding local variables The second thread confinement introduces techniques for restricting access within threads The third object confinement uses OOencapsulation techniques to provide the stronger guarantees needed to ensure uniqueness of access formethods entering objects The fourth group confinement extends these techniques to collaboratingsets of objects operating across multiple threads Confinement Across MethodsIf a given method invocation creates an object and does not let it escape then it can be sure that noother threads will interfere with or even know about its use of that object Hiding access within localscopes is a common encapsulation tactic in all forms of programming With only a modicum of care these techniques can be extended to sequences of method invocations For example consider the following class that uses java awt Point This Point class isdefined as a simple record style class with public x and y fields so it would be unwise to shareinstances across threads class Plotter Fragmentspublic void showNextPoint Point p new Point p x computeX p y computeY display p protected void display Point p somehow arrange to show p Here the showNextPoint method creates a local Point It allows the Point to escape intodisplay p only in a tail call after showNextPoint is sure never to access it again even ifthe Point is later accessed from another thread Access from another thread could occur here Essentially all graphics based programs somehow rely on the AWT event thread see and although it is unlikely that the thread would modify the Point object This is an example of a hand off protocol that ensures that at any given time at most one activelyexecuting method can access an object This tail call version is the simplest and usually best form Similar usages are seen in factory methods that construct and initialize an object and finally return it as seen for example in the ParticleApplet makeThread method in SessionsMany hand off sequences are structured as sessions in which some public entry method constructsobjects that will be confined to a sequence of operations comprising a service This entry methodshould also be responsible for any cleanup operations required upon completion of the sequence Forexample class SessionBasedService Fragments public void service OutputStream output null try output new FileOutputStream doService output catch IOException e handleIOFailure finally try if output null output close catch IOException ignore ignore exception in close void doService OutputStream s throws IOException s write possibly more handoffs When you have a choice between them it is almost always preferable to perform cleanup infinally clauses rather than relying on finalization i e overriding Object finalize Useof finally provides a stronger guarantee about when cleanup will take place which helpsconserve possibly scarce resources such as files In contrast finalizers generally triggerasynchronously as a result of garbage collection if ever Alternative protocolsTail call hand offs do not apply if a method must access an object after a call or must make multiplecalls Additional design rules are needed to cover cases such as a revised Plotter class withmethod public void showNextPointV Point p new Point p x computeX p y computeY display p recordDistance p added Options include Caller copies When the objects being passed around represent data values such as points in whichobject identity does not matter then the caller can make a copy of the object for use by the receiver Here for example display p would be replaced by display new Point p x p y Receiver copies If a method knows nothing about the usage constraints surrounding an objectreference sent as an argument and again if object identity does not matter it can conservativelymake a copy for its own local use Here for example the display method could have as its firstline Point localPoint new Point p x p y Using scalar arguments Uncertainties about caller and receiver responsibilities can be eliminated bynot sending references at all but instead sending scalar arguments providing enough information forthe receiver to construct an object if desired Here for example we could reparameterize displayto protected void display int xcoord int ycoord and the call to display p x p y Trust A receiver or rather its author may promise not to modify or transmit objects accessible viareference arguments It must in turn ensure lack of unwanted access in any downstream calls If none of these can be arranged then pure confinement is not guaranteed to succeed and othersolutions described in this chapter should be applied For example if use of java awt Pointwere not required here you could instead use an ImmutablePoint class to ensure lack ofmodification see Confinement Within ThreadsThread based confinement techniques extend those for method sequences In fact the simplest andoften best technique is to use a thread per session design see that is otherwise identical tosession based confinement For example you can initialize hand offs in the base of a run method Even though this section presupposes only knowledge of the basic Thread usages presented in Chapter you may find a cursory glance through Chapter helpful class ThreadPerSessionBasedService fragments public void service Runnable r new Runnable public void run OutputStream output null try output new FileOutputStream doService output catch IOException e handleIOFailure finally try if output null output close catch IOException ignore new Thread r start void doService OutputStream s throws IOException s write possibly more hand offs Some approaches to concurrent software design such as CSP see arrange or require thatall fields accessible within a thread be strictly confined to that thread This mimics the enforcedisolation of address spaces seen in process versus thread based concurrent programming see However note that it is generally impossible to confine access to every object used in a given thread All threads running on a given JVM must ultimately share access to at least some underlyingresources for example those controlled via methods in the java lang System class Thread specific fieldsIn addition to receiving confined references along call chains the method invocations executingwithin a single thread can access the Thread object representing the thread they are running in andany further information traversable from there The static method Thread currentThread can be called from any method and returns the Thread object of the caller You can exploit this by adding fields to Thread subclasses and supplying methods to access themonly from within the current thread For example class ThreadWithOutputStream extends Thread private OutputStream output ThreadWithOutputStream Runnable r OutputStream s super r output s static ThreadWithOutputStream current throws ClassCastException return ThreadWithOutputStream currentThread static OutputStream getOutput return current output static void setOutput OutputStream s current output s This class could be used for example in class ServiceUsingThreadWithOutputStream Fragments public void service throws IOException OutputStream output new FileOutputStream Runnable r new Runnable public void run try doService catch IOException e new ThreadWithOutputStream r output start void doService throws IOException ThreadWithOutputStream current getOutput write ThreadLocalThe java lang ThreadLocal utility class removes one obstacle to using thread specifictechniques their reliance on special Thread subclasses This class allows thread specific variablesto be added in an ad hoc fashion to just about any code The ThreadLocal class internally maintains a table associating data Object references withThread instances ThreadLocal supports set and get methods to access data held by thecurrent Thread The java lang InheritableThreadLocal class extendsThreadLocal to automatically propagate per thread variables to any threads that are in turncreated by the current thread Most designs employing ThreadLocal may be seen as extensions of the Singleton see pattern Rather than constructing one instance of a resource per program most applications ofThreadLocals construct one instance per thread ThreadLocal variables are normallydeclared as static and usually have package scoped visibility so they may be accessed by any of aset of methods running in a given thread A ThreadLocal could be used in our running example as follows class ServiceUsingThreadLocal Fragmentsstatic ThreadLocal output new ThreadLocal public void service try final OutputStream s new FileOutputStream Runnable r new Runnable public void run output set s try doService catch IOException e finally try s close catch IOException ignore new Thread r start catch IOException e void doService throws IOException OutputStream output get write Applications and consequencesThreadLocals and Thread subclasses holding thread specific fields are typically used onlywhen there is no other good option available Advantages and disadvantages compared to otherapproaches such as session based designs include Housing object references in or associated with Thread objects allows methods runningin the same thread to share them freely without needing to pass them explicitly as parameters This can be a good option for maintaining contextual information such as theAccessControlContext of the current thread as is done in the java securitypackages or the current working directory to be used for opening a set of related files ThreadLocal can also be useful for constructing per thread resource pools see The use of thread specific variables tends to hide parameters that influence behavior and canmake it harder to check for errors or leakage In this sense thread specific variables presentthe same although less extreme traceability problems as static global variables It is simple to guarantee that a status change to a thread specific variable for example closing one output file and opening another affects all relevant code On the other hand itcan be difficult to guarantee that all such changes are properly coordinated No synchronization is necessary for either reads or writes to thread specific fields from withinthe thread However the access paths via currentThread or internal ThreadLocaltables are not likely to be any cheaper than uncontended synchronized method calls Sothe use of thread specific techniques generally improves performance only when objectswould otherwise need to be shared and heavily contended for across threads Use of thread specific variables can detract from reusability by increasing code dependencies This is a more serious problem under the Thread subclass approach For example thedoService method is unusable unless run within a ThreadWithOutputStream Any attempted use outside this context will result in a ClassCastException wheninvoking method current Adding context information via ThreadLocal is sometimes the only way to letcomponents work with existing code that does not propagate required information along callsequences see It is difficult to associate data with execution contexts when using lightweight executableframeworks that are only indirectly based upon class Thread in particular worker threadpools see Confinement Within ObjectsEven when you cannot confine access to an object within a particular method or thread and so mustuse dynamic locking you can confine all accesses internal to that object so that no additional lockingis necessary once a thread enters one of its methods In this way the exclusion control for the outerHost container object automatically propagates to its internal Parts For this to work references to theParts must not be leaked See for strategies that may apply when leakage from containerscannot be precluded Object confinement is seen in OO programs of all kinds The main added requirement in concurrentcontexts is to ensure synchronization at all entry points into the Host object This employs the sametechniques used when building fully synchronized objects holding instances of primitivescalar types such as double But here they are applied to classes holding references to other objects In confinement based designs the Host object may be thought of as owning the inner Parts Conversely the Part objects may be thought of as being physically contained in their Host The Host object constructs new instances of each Part object upon its own construction assigning references to non public fields Fresh construction guarantees that references to thePart objects are not shared by any other object Alternatively the constructor can act as ahand off point As in any confinement technique the Host object must never leak references to any Partobject It must never pass the references as arguments or return values of any method andmust ensure that the fields holding the references are inaccessible Additionally the Partobjects must not leak their own identities for example by sending this as a callbackargument see to an external method This guarantees that the Part objects areexternally accessible only via methods on the Host object In the most conservative variant fixed containment the Host object never reassigns referencefields pointing to the inner Part objects This avoids the need for synchronization surroundingfield updates in the Host object Fixed containment implements the main sense ofaggregation discussed in the Design Patterns book and denoted by UML diamond symbols Unless the Host object is in turn confined within another all appropriate methods of the hostobject are synchronized See for one approach to defining both synchronized andunsynchronized versions of classes This guarantees that all accesses to the Parts and allobjects recursively constructed within them maintain exclusion Note that the Partsrecursively held in a single confinement domain can invoke methods on one another withoutemploying synchronization only external accesses require synchronization Despite the demanding and sometimes difficult to check constraints that they must fulfill objectconfinement techniques are very common in part due to their utility in constructing Adapters andother delegation based designs AdaptersAdapters see can be used to wrap bare unsynchronized ground objects within fullysynchronized host objects This leads to the simplest possible delegation style designs those in whichthe Adapters just forward all messages on to their delegates Synchronized Adapters can be used toenclose legacy code originally written for sequential settings as well as dynamically loaded codethat you do not trust to be safe in multithreaded contexts An Adapter can also provide a single safe entry point into a heavily optimized perhaps even intonative code computationally intensive set of functionality that for the sake of efficiency performs no internal concurrency control Note however that no amount of wrapping can deal withnative code that internally accesses fields unsafely across different threads Given one or more unprotected ground classes you can define a synchronized Adapter class with afield say delegate holding a reference to a ground object to which it forwards requests andrelays replies Note that if any ground method contains a reply of the form return this it shouldbe translated as return this in the Adapter Delegate references need not be final but if theyare assignable care must be taken that the Adapter obtains exclusive access For example an Adaptermight occasionally assign the reference to a new internally constructed delegate As mentioned in when it is important to ensure that Adapters are treated as identical to theirinternally held ground objects you can override the equals and hashCode methods accordingly However there is no reason to do so in confinement based designs since the internal objects are neverleaked out so will never be compared As one simple application synchronized Adapters can be used to place synchronized access andupdate methods around a class containing public instance variables such as a wide open pointclass class BarePoint public double x public double y class SynchedPoint protected final BarePoint delegate new BarePoint publicpublicpublicpublic synchronizedsynchronizedsynchronizedsynchronizeddouble getX return delegate x double getY return delegate y void setX double v delegate x v void setY double v delegate y v The java util Collection framework uses an Adapter based scheme to allow layeredsynchronization of collection classes Except for Vector and Hashtable the basic collectionclasses such as java util ArrayList are unsynchronized However anonymoussynchronized Adapter classes can be constructed around the basic classes using for example List l Collections synchronizedList new ArrayList SubclassingWhen instances of a given class are always intended to be confined within others there is no reason tosynchronize their methods But when some instances are confined and some are not the safest practiceis to synchronize them appropriately even though locking is not required in all usage contexts See however and for situations in which other tactics may apply As compilers tools and run time systems continue to improve they are increasingly able to optimizeaway or minimize the overhead of superfluous locking However when necessary or desirable youcan arrange this manually by defining multiple versions of a class and then instantiating theappropriate version for a given usage context Among the simplest options is subclassing see creating an unprotected base class and then overriding each method m as a synchronized methodcalling super m For example class Address protected String street protected String city Fragmentspublic String getStreet return street public void setStreet String s street s public void printLabel OutputStream s class SynchronizedAddress extends Address public synchronized String getStreet return super getStreet public synchronized void setStreet String s super setStreet s public synchronized void printLabel OutputStream s super printLabel s Confinement Within GroupsGroups of objects accessible across multiple threads can together ensure that only one of them at atime can access a given resource object Here each resource is always owned by only one object butownership may change hands over time Protocols for maintaining exclusive ownership are similar tothose for handing off references across method invocations discussed in but require morestructure to manage conformance across groups of objects and threads Exclusively held resources are analogs of physical objects in the sense that If you have one then you can do something with it that you couldn t do otherwise If you have it then no one else has it If you give it to someone else then you no longer have it If you destroy it then no one will ever have it Any kind of object can be viewed as a resource if it is used in this manner A more concrete way ofcharacterizing this policy is that at most one field of one object refers to any exclusive resource at anygiven time This fact can be exploited to ensure confinement within any given activity thus reducingthe need for dynamic synchronization on resource objects In some contexts and senses protocols involving exclusive resources have been termed tokens batons linear objects capabilities and sometimes just resources Several concurrent and distributedalgorithms hinge on the idea that only one object at a time possesses a token For a hardware basedexample token ring networks maintain a single token that is continually circulated among the nodes Each node may send messages only when it has the token While most transfer protocols are very simple implementation can be error prone Fields containingreferences to objects just don t act much like physical objects when it comes to the notion ofpossession For example statements of the form x r y s do not cause owner y containingfield s to lose possession after completion of the operation The assignment instead results in both rand s still being bound This state of affairs is analogous to real life problems in dealing withintellectual property rights and other forms of permission that do not intrinsically entail physicaltransfer operations This problem has led to a vast array of solutions ranging from informalconventions to arbitrarily heavy legal apparatus To improve reliability you can encapsulate protocols in methods performing the following operations for distinct Resource objects r and s and Owner objects x and y that may hold them in fieldref For emphasis required locks are shown using synchronized blocks Acquire Owner x establishes initial possession of r This is usually the result of constructing orotherwise initializing r and setting synchronized this ref r Forget Owner x causes Resource r not to be possessed by any Owner This is usuallyaccomplished by the current Owner performing synchronized this ref null Put give Owner y sends Owner x a message containing a reference to Resource r as anargument after which y no longer has possession of r but x does xyvoid put Resource s synchronized this ref s void anAction Owner x Resource s synchronized this s ref ref null x put s Take Owner y requests a Resource from Owner x which then sends r as the return value relinquishing possession xyResource take synchronized this Resource r ref ref null return r void anAction Owner x Resource r x take synchronized this ref r Exchange Owner y trades its Resource s for Owner x s Resource r This operation can also beused to perform a take via s exchange null or a put via exchange r ignoring theresult xResource exchange Resource s synchronized this Resource r ref ref s return r yvoid anAction Owner x synchronized this ref x exchange ref One application of such protocols arises when one object say an OutputStream is almostcompletely confined within its host object but must be used occasionally by other clients In thesecases you can allow clients to take the internal object operate on it then put it back In themeantime the host object will be temporarily crippled but at least you are sure not to encounterintegrity violations RingsIn the general case resource management may involve maintaining pools see usingmessage passing networks that adopt particular exchange see or flow see policies oradopting protocols that help avoid deadlock and resource exhaustion see But simpler transferprotocols can be used when you just need to ensure that an interconnected group of cooperatingobjects together strictly confines a resource One way to implement this is to arrange a set of peerobjects in a ring in which each node communicates only with a single neighbor As an unrealistically simplified example consider a set of PrintService objects arranged asnodes in a ring passing around rights to use a Printer If a node is asked to print but does notcurrently have access it tries to take it from its neighbor This request cascades down to a node thathas a printer Defining the relevant methods as synchronized ensures that nodes do not give upthe printer until they are finished with it Here is a snapshot of one possible configuration This design produces the desired effects only if all nodes obey the transfer protocol the connectionsare set up appropriately and at least one node has a printer A sample start up method shows one wayto establish the required structure Many additional extensions would be needed to allow dynamicconnections of new PrintService objects to support more than one Printer and to dealwith situations in which no Printer at all is available class Printer public void printDocument byte doc class PrintService protected PrintService neighbor null node to take fromprotected Printer printer null public synchronized void print byte doc getPrinter printDocument doc protected Printer getPrinter PRE synch lock heldif printer null need to take from neighborprinter neighbor takePrinter return printer synchronized Printer takePrinter called from othersif printer null Printer p printer implement take protocolprinter null return p elsereturn neighbor takePrinter propagate initialization methods called only during start upsynchronized void setNeighbor PrintService n neighbor n synchronized void givePrinter Printer p printer p Sample code to initialize a ring of new servicespublic static void startUpServices int nServices Printer p throws IllegalArgumentException if nServices p null throw new IllegalArgumentException PrintService first new PrintService PrintService pred first for int i i nServices i PrintService s new PrintService s setNeighbor pred pred s first setNeighbor pred first givePrinter p Further ReadingsThe Hermes programming language pioneered several language constructs and techniques forstructuring concurrent and distributed programs including reference transfer as a primitive See Strom Robert David Bacon Arthur Goldberg Andy Lowry Daniel Yellin and Shaula Yemini Hermes A Language for Distributed Computing Prentice Hall The Spring operating system interface definition language embedded hand off policies as argumentqualifiers for methods See A Spring Collection SunSoft Press Techniques based on unique references have also played roles in other OO design and analysismethods See for example Hogg John Doug Lea R C Holt Alan Wills and Dennis de Champeaux The Geneva Conventionon the Treatment of Object Aliasing OOPS Messenger April For a formal approach to confinement in distributed systems see Cardelli Luca and Andrew Gordon Mobile Ambients in Maurice Nivat ed Foundations ofSoftware Science and Computational Structures Springer LNCS Structuring and Refactoring ClassesIt can be difficult to balance the design forces surrounding exclusive access control during initial classdesign Most classes used in concurrent programs undergo iterative refactorings to address concernssuch as Using only a few entry point locks as seen in most confinement based designs tends to workwell when there are few threads due to reduced overhead But performance can quicklydegrade under contention especially on multiprocessors When many threads all contend forthe same entry point lock most threads will spend most of their time waiting for the lock increasing latencies and limiting opportunities for parallelism Most systems evolve to usefiner granularity locks as they grow The best known cases are operating systems that onceused a single giant lock as the entry point to a kernel but increasingly use narrowly scoped briefly held locks in part for better support of multiprocessing Using too many locks can add overhead and increase the chances of unanticipated livenessfailures Using one lock to protect more than one aspect of functionality can result in unnecessarycontention Holding locks for long periods invites liveness and performance problems and complicatesexception processing Locking individual methods does not always maintain intended semantics For example whentwo related attributes are obtained by calling two different locked accessors the valuesobtained might not obey intended relationships if a state transition occurs between calls There is no single optimal strategy However several techniques and patterns can be used to providebetter balance among such forces This section describes strategies for removing unnecessarysynchronization splitting synchronization to match functionality exporting read only operations viaadapters isolating state representations to reduce access costs or improve potential parallelism andgrouping objects to use common locks so as to mirror layered designs While any of these could beused during the initial design of classes several of them rely on technical manipulations that aredifficult and sometimes unwise to exploit during early design efforts Reducing SynchronizationWhen locking presents liveness or performance problems for a given class or program usually thebest solution is to refactor the design to use one or more of the other approaches presented in thischapter However there are cases where the basic logic of a synchronization based design can bemaintained even when some of the synchronized method qualifiers or blocks are removed although sometimes at the expense of weakened semantic guarantees AccessorsSynchronizing a field accessor method sometimes but by no means always adds noticeable overheadto programs Two considerations enter into any decision about whether synchronization of an accessormethod can be removed Legality The value of the underlying field never assumes an illegal value that is you can ensure thatthe field never even momentarily breaks invariants This by definition excludes fields of type longand double Staleness Clients do not necessarily require the most recently updated value of a field but can livewith possibly stale values see If a field is not always legal then the choices are Synchronize the accessor as well as all update methods Ensure somehow that clients realize when they have obtained an illegal value and takeevasive action for example via double checks see Omit the accessor method This applies surprisingly often Ask yourself why any client wouldwant to know the value of a field and what they could do with this value Because objectattributes can change asynchronously in concurrent programs a value obtained by a client inone line of code may have changed before the next line of code is executed Thus accessormethods are not frequently useful in concurrent programs Moreover because they are notfrequently useful synchronization is unlikely to be a performance concern even if you do notremove the accessor methods in such cases If a field is always legal but staleness is not acceptable then you have the additional choice Remove synchronization from the accessor and qualify the instance variable as volatile However this works as expected only for scalar types not references to arrays or Objectsthat help maintain object representations accessing a volatile reference does notautomatically ensure visibility of the fields or elements accessible from that reference In thecase of Object references you can if necessary further ensure that the accessed fields arethemselves volatile The main disadvantage of this approach is that volatiledeclarations impede compiler optimizations of methods using these fields and so can lead toa net performance loss If a field is always legal and staleness is acceptable then you also have the choices Remove synchronization from the accessor without any further alteration If you like to live dangerously just make the field public As an example consider the size method of the ExpandableArray class thatreturns the value of the size field Inspection of all methods reveals that the value of the size fieldis always legal it never assumes a value outside the range data length This would notbe true if for example size were temporarily set to as a resize indicator flag inside the addmethod Assuming that this constraint is documented as an internal requirement for all subclasses andfuture modifications then synchronization can be removed from the accessor The decision about staleness and need for volatile is a matter of judgment about possible usagecontexts that here interacts with among other issues choice of traversal strategies If clients mainlytraverse elements using indexed loops for int i i v size i System out println v get i questionablethen obtaining stale values of size is not likely to be acceptable For example a client might obtainthe value zero even when there are many elements in the array thus skipping the loop entirely Notethat if the loop ran at all the synchronization performed in the first invocation of method get wouldforce a fresher value of size to be returned on the second and subsequent calls to size Alsorecall from that clients must in any case be prepared for the size to change between the indexcheck and the element access so this traversal style is problematic at best anyway However if either aggregates or iterators are used each performing internal synchronization then youcould make an argument for leaving the size method unsynchronized and the size field non volatile and advertising the method as only a heuristic estimate of the current number of elements Still this is unlikely to be acceptable to clients of a general purpose class such asExpandableArray But similar reasoning may be invoked when it is acceptable for clients toobtain values that are guaranteed to be only as recent as the last synchronization points of reading andwriting threads Double checkIf callers of unsynchronized field accessors can somehow realize when they have just read an illegalvalue they can sometimes take evasive action One such action is to re access the field undersynchronization determine its most current value and then take appropriate action This is the essenceof the double check idiom Double check and its variants including looping versions sometimes called test and test and set areseen in latches see spin locks see and caching protocols But the most commonapplication of double check is to conditionally relax synchronization surrounding initialization checks When an uninitialized value for scalars a default zero value is encountered the accessing methodacquires a lock rechecks to see if initialization is really necessary as opposed to having read a stalevalue and if so performs the initialization while still under the synchronization lock to preventmultiple instantiations For example class AnimationApplet extends Applet Fragments int framesPerSecond default zero is illegal valuevoid animate if framesPerSecond the unsynchronized checksynchronized this if framesPerSecond the double checkString param getParameter fps framesPerSecond Integer parseInt param actions using framesPerSecond While there are several legitimate uses double check is extremely delicate It is generally unwise to use double check for fields containing references to objects or arrays Visibility of a reference read without synchronization does not guarantee visibility of non volatile fields accessible from the reference see Even if such a reference isnon null fields accessed via the reference without synchronization may obtain stale values It is difficult at best to use a single flag field as an indicator that a whole set of fields must beinitialized The as if serial reorderings discussed in may cause the flag to be visiblyset before the other fields are visibly initialized Remedies to both of these problems almost always require some sort of locking So theseconsiderations usually lead to avoidance of double checked lazy initialization and adoption ofschemes that instead either eagerly initialize or rely on fully synchronized checks as seen for examplein the Singleton classes in However in a few other cases you may be able to use an even weaker technique single check Here the check initialization and field binding are all performed without synchronization and thus dependon the vagaries of unsynchronized field access This opens up the possibility for multipleinstantiations This is a plausible option only if initialization is side effect free and need not otherwiseentail synchronization and use of multiple threads is rare Open callsAs discussed in a method is stateless if it does not access or rely on any mutable object fields Methods on fully immutable objects are by necessity stateless but stateless methods can occur inother kinds of classes as well for example in purely computational utility methods and during methodinvocations made to acquaintances as opposed to representational support objects see You do not need to synchronize stateless parts of methods This allows other calls tosynchronized methods to execute during unsynchronized sections improving performance andreducing lock interference However synchronization can be split only when the different parts of themethod are not in any way dependent so that it is acceptable for other methods to see and use theobject before full method completion To illustrate consider the following generic server class If helper operation takes a longtime then calls to synchronized methods such as getState might block for an unacceptabletime waiting for the method to be available class ServerWithStateUpdate protected double state protected final Helper helper new Helper public synchronized void service state set to some new valuehelper operation public synchronized double getState return state If helper represents some aspect of the host s state or the call to helper operation relieson or modifies host state then the entire service method must employ synchronization However if helper operation is otherwise independent of the host then the service method can bestructured in the form suggested by the default rules in First update state holding locks Then send messages without holding locks Messages sent without holding locks are also known as open calls As discussed in and classes with methods of this form are among the most well behaved and readily composablecomponents in concurrent and event based systems For example assuming thathelper operation meets our criteria the above class can be rewritten as class ServerWithOpenCall protected double state protected final Helper helper new Helper protected synchronized void updateState state set to some new value public void service updateState helper operation It is still possible to use open calls here even if the helper reference field is mutable for example using block synchronization class ServerWithAssignableHelper protected double state protected Helper helper new Helper synchronized void setHelper Helper h helper h public void service Helper h synchronized this state h helper h operation public synchronized void synchedService see belowservice The synchedService method here reveals a weakness in any technique involving open calls The call to service from within synchedService results in the lock being held throughoutthe duration of service including the call to h operation This defeats the purpose of themethod restructurings Avoiding such problems requires documentation of the intentional lack ofsynchronization in classes used in concurrent settings Data structures that are linked via immutable references are often amenable to these kinds ofmanipulations For example consider a LinkedCell class in which each cell contains a referenceto a successor cell and for which we require that successor cell references be fixed upon construction This is a common requirement for cells serving as Lisp style lists Methods and sections of methodssolely involving the successor need not be synchronized which speeds up traversal For clarity andemphasis the methods here use recursion in practice you would probably use iteration instead class LinkedCell protected int value protected final LinkedCell next public LinkedCell int v LinkedCell t value v next t public synchronized int value return value public synchronized void setValue int v value v public int sum add up all element valuesreturn next null value value next sum public boolean includes int x search for xreturn value x true next null false next includes x Again note that an object remains locked when a synchronized method calls an unsynchronizedone So it would not avoid synchronization to write sum as synchronized int ineffectivelyUnsynchedSum bad ideareturn value nextSum synch still held on call int nextSum return next null next sum Splitting SynchronizationWhen the representations and behavior of one class can be partitioned into independent non interacting or just non conflicting subsets it is almost always worth refactoring the class to usedistinct finer granularity helper objects whose actions are delegated by the host This rule of thumb holds in object oriented design generally But it carries much more force inconcurrent OO programming A set of synchronized operations might deadlock or present otherliveness or lock based performance problems if they were all waiting for the single synchronizationlock associated with a single object But they might be deadlock free and or run more efficiently ifthey are waiting on multiple distinct locks As a general rule the more finely you can subdivide theinternal synchronization of a given class the better will be its liveness properties across a wider rangeof contexts However this sometimes comes at the expense of greater complexity and potential forerror Splitting classesConsider a simplified Shape class that maintains both location and dimension information alongwith time consuming methods adjustLocation and adjustDimensions thatindependently alter them class Shape protected doubleprotected doubleprotected doubleprotected doublepublicpublicpublicpublic Incompletex y width height synchronizedsynchronizedsynchronizedsynchronizeddoubledoubledoubledoublex y width height return x return y return width return height public synchronized void adjustLocation x longCalculation y longCalculation public synchronized void adjustDimensions width longCalculation height longCalculation Under the assumptions that adjustLocation never deals with dimension information andadjustDimensions never deals with location better performance could be obtained by revisingthis class so that callers of adjustLocation need not wait for those callingadjustDimensions and vice versa Splitting classes to reduce granularity is a straightforward exercise in class refactoring Partition some functionality of a Host class into another class say Helper In the Host class declare a final unique field referencing a helper that is initialized to anew Helper in the constructor In other words strictly confine each helper in its host In the Host class forward all appropriate methods to the Helper as open calls usingunsynchronized methods This works because the methods are stateless with respect to theHost class The most extreme result of these steps is a Pass Through Host design in which all messages arerelayed as open calls via simple unsynchronized methods For example here is a pass through version of the Shape class class PassThroughShape protected final AdjustableLoc loc new AdjustableLoc protected final AdjustableDim dim new AdjustableDim public double x public double y return loc x return loc y public double width public double height return dim width return dim height public void adjustLocation loc adjust public void adjustDimensions dim adjust class AdjustableLoc protected double x protected double y public AdjustableLoc double initX double initY x initX y initY public synchronized double x return x public synchronized double y return y public synchronized void adjust x longCalculation y longCalculation protected double longCalculation protected double longCalculation class AdjustableDim protected double width protected double height public AdjustableDim double initW double initH width initW height initH public synchronized double width return width public synchronized double height return height public synchronized void adjust width longCalculation height longCalculation protected double longCalculation protected double longCalculation Splitting locksEven if you do not want to or cannot split a class you can still split the synchronization locksassociated with each subset of functionality This technique is equivalent to one in which you firstsplit a class into helpers and then fold all representations and methods of the helpers except theirsynchronization locks back into the host class However there is no need to proceed in exactly thisway Stripped of all but its synchronization lock any class is reduced to just java lang Object This fact accounts for the idiomatic practice of using instances of class Object as synchronizationaids To recover the underlying design whenever you see an Object used for a synchronization lock youmight ask yourself what kind of helper object a particular lock is a stand in for In the case of lock splitting each Object controls access to a subset of methods so each method in each subset isblock synchronized on a common lock object The basic steps for splitting locks are similar to those for splitting objects For each independent subset of functionality declare a final object say lock initializedin the constructor for the Host class and never reassigned o The lock object can be of any subclass of class Object If it will not be used forany other purpose it might as well be of class Object itself o If a subset is uniquely associated with some existing object uniquely referenced froma field you may use that object as the lock o One of these locks can be associated with the Host object this itself Declare all methods corresponding to each subset as unsynchronized but surround all codewith synchronized lock Among the applications of lock splitting are fixed size hash tables in which each bin of the tablepossesses its own lock This strategy cannot easily be applied to dynamically resizable hash tablessuch as those used in java util Hashtable since they cannot rely on immutability of thelock objects Lock splitting is also seen in classes that carefully manage waiting and notificationoperations as discussed in For a simpler example here is a split version of the Shape class class LockSplitShape protected double x protected double y protected double width protected double height Incompleteprotected final Object locationLock new Object protected final Object dimensionLock new Object public double x synchronized locationLock return x public double y synchronized locationLock return y public void adjustLocation synchronized locationLock x longCalculation y longCalculation and so on Isolating fieldsSome classes manage sets of independent properties and attributes each of which can be manipulatedin isolation of the others For example a Person class may have age income andisMarried fields that can be changed regardless of any other actions being performed on thePerson object as a whole The decision about whether this is acceptable of course rests on theintended usage semantics of a given class You cannot just declare such fields as volatile if you need synchronization protection to avoidconflicts among concurrent attempts to update them However you can use a simple form of splittingto offload synchronization protection to objects used solely to protect basic operations on basic types Such classes play a similar role as classes java lang Double and java lang Integer except that instead of promising immutability they promise atomicity For example you can create aclass such as class SynchronizedInt private int value public SynchronizedInt int v value v public synchronized int get return value public synchronized int set int v returns previousvalueint oldValue value value v return oldValue public synchronized int increment return value and so on The util concurrent package available from the online supplement contains a set of suchclasses one for each basic type that also support other utility operations such as the commit methoddescribed in These classes could be used for example in class Person Fragmentsprotected final SynchronizedInt age new SynchronizedInt protected final SynchronizedBoolean isMarried new SynchronizedBoolean false protected final SynchronizedDouble income new SynchronizedDouble public int getAge return age get public void birthday age increment Linked data structuresLock splitting techniques can minimize access contention to objects serving as entry points into linkeddata structures by finding a middle ground between the extreme strategies of fully synchronizing theentry classes which can limit concurrency and fully synchronizing all the linked node objects beingcontrolled which can be inefficient and can lead to liveness problems As with all lock splitting techniques the main goal is to associate different locks with differentmethods But in the case of linked structures this often leads to further adjustments in the datastructures and algorithms themselves There are no universally applicable recipes for splittingsynchronization in classes controlling access to linked structures but the following class illustratessome common tactics The following LinkedQueue class can serve as a generic unbounded first in first out FIFO queue It maintains separate synchronization for put and poll The putLock lock ensures thatonly one put operation at a time can proceed The pollLock lock similarly ensures that only onepoll operation at a time can proceed A head node always exists in this implementation so that aput and a poll can normally proceed independently After each poll the previous first nodebecomes the new head Additionally the accessed nodes themselves must be locked to preventconflicts when a put and a poll are both simultaneously executing on a queue that was previouslyempty or is about to become empty in which case head and last both refer to the same headernode class LinkedQueue protected Node head new Node null protected Node last head protected final Object pollLock new Object protected final Object putLock new Object public void put Object x Node node new Node x synchronized putLock insert at end of listsynchronized last last next node extend listlast node public Object poll returns null if emptysynchronized pollLock synchronized head Object x null Node first head next get to first real nodeif first null x first object first object null forget old objecthead first first becomes new head return x static class Node Object object Node next null local node class for queueNode Object x object x The online supplement includes queue classes that further refine extend and optimize this basicdesign Read Only AdaptersIn confinement based designs see a Host object cannot reveal the identity of any of its Partobjects This eliminates the choice of returning references to parts in any accessor or propertyinspection method One alternative is instead to return a copy of the Part For example class SynchedPoint could add a method public synchronized BarePoint getPoint return new BarePoint delegate x delegate y When Parts are instances of classes known to implement an appropriate clone method you caninstead return part clone And when you need to return arbitrary sets of values you can usean ad hoc array for example public synchronized double getXY return new double delegate x delegate y However copying can be too expensive when dealing with some objects and does not make sensewhen dealing with others for example objects that maintain references to files threads or otherresources that should not themselves be copied In many cases you can instead selectively permitsome leakage by constructing and returning an Adapter object surrounding the part that exposes onlythose operations that clients may use without introducing any potential interference generally read only operations Unless these methods deal only with immutable state they require synchronization The most secure version of this scheme takes a bit of work to set up Define a base interface describing some non mutative functionality Optionally define a subinterface that supports additional update methods used in the normalmutable implementation class Define a read only adapter that forwards only the exported operations For added security declare that the immutable class is final The use of final means that when you thinkyou have an immutable object you really do it s not of some subclass that supportsmutable operations as well These steps can be applied to the following simple Account class Even though accounts in thisexample are held only by AccountHolders the general purpose mutableUpdatableAccount implementation employs synchronization class InsufficientFunds extends Exception interface Account long balance interface UpdatableAccount extends Account void credit long amount throws InsufficientFunds void debit long amount throws InsufficientFunds Sample implementation of updatable versionclass UpdatableAccountImpl implements UpdatableAccount private long currentBalance public UpdatableAccountImpl long initialBalance currentBalance initialBalance public synchronized long balance return currentBalance public synchronized void credit long amount throws InsufficientFunds if amount currentBalance amount currentBalance amount elsethrow new InsufficientFunds public synchronized void debit long amount throws InsufficientFunds credit amount final class ImmutableAccount implements Account private Account delegate public ImmutableAccount long initialBalance delegate new UpdatableAccountImpl initialBalance ImmutableAccount Account acct delegate acct public long balance forward the immutable methodreturn delegate balance These classes could be used for example in class AccountRecorder A logging facilitypublic void recordBalance Account a System out println a balance or record in file class AccountHolder private UpdatableAccount acct new UpdatableAccountImpl private AccountRecorder recorder public AccountHolder AccountRecorder r recorder r public synchronized void acceptMoney long amount try acct credit amount recorder recordBalance new ImmutableAccount acct catch InsufficientFunds ex System out println Cannot accept negative amount Use of a read only wrapper at line might seem an unnecessary precaution But it guards againstwhat might happen if someone were to write the following subclass and use it in conjunction withAccountHolder class EvilAccountRecorder extends AccountRecorder private long embezzlement public void recordBalance Account a super recordBalance a if a instanceof UpdatableAccount UpdatableAccount u UpdatableAccount a try u debit embezzlement catch InsufficientFunds quietlyignore The java util Collection framework uses a variant of this scheme Rather than declaring aseparate immutable interface the main Collection interface permits mutative methods to throwUnsupportedOperationExceptions Anonymous read only adapter classes throw theseexceptions on all attempted update operations They can be constructed via for example List l new ArrayList untrustedObject use Collections unmodifiableList l Copy on WriteWhen a set of fields comprising the state of an object must maintain a set of interrelated invariants you can isolate these fields in another object that preserves the intended semantic guarantees A good way to go about this is to rely on immutable representation objects that at all times maintainconsistent snapshots of legal object states Relying on immutability eliminates the need to otherwisecoordinate separate readings of related attributes It also normally eliminates the need to hide theserepresentations from clients For example in we had to take special precautions involving block synchronization in orderto guarantee that consistent x y coordinates of Particles were always displayed correctly Andthe Shape classes described in do not even provide a mechanism for doing this One solutionis to employ a separate ImmutablePoint class that maintains location information that is at alltimes consistent class ImmutablePoint private final int x private final int y public ImmutablePoint int initX int initY x initX y initY public int x return x public int y return y ImmutablePoints could be used in the following Dot class that is otherwise similar to theParticle class in This class illustrates the general techniques surrounding copy on writeupdates in which state changes do not directly update fields but instead construct and attach newrepresentation objects Note that synchronization of some form is required here Even though the point representation objectsare immutable the loc reference is mutable While synchronization of the accessor methodlocation might be loosened in accord with the considerations in the shiftX methodmust be synchronized or perhaps otherwise modified in order to preclude multiple concurrentexecutions in which different versions of loc are obtained when accessing l oc x andloc y class Dot protected ImmutablePoint loc public Dot int x int y loc new ImmutablePoint x y public synchronized ImmutablePoint location return loc protected synchronized void updateLoc ImmutablePoint newLoc loc newLoc public void moveTo int x int y updateLoc new ImmutablePoint x y public synchronized void shiftX int delta updateLoc new ImmutablePoint loc x delta loc y Internal copy on writeWhen state representations are strictly internal to an object there is no compelling reason to createnew classes just to enforce immutable access Copy on write can be applied whenever the need toobtain consistent representations quickly and effortlessly overwhelms construction costs It requires atmost one synchronized operation to access all of the state held by an immutable representation object Additionally in some contexts it is convenient to obtain a single snapshot rather than one that reflectsany state modifications made during the use of that snapshot For example copy on write collection objects can be very useful for maintaining collections oflisteners in event and multicast frameworks see Here objects maintain lists of listeners orhandlers that must receive notifications of state changes or other events of interest These lists rarelychange but may be traversed very frequently Also when objects receiving notifications makechanges in the list of notifyees they are almost always intended to take effect the next time anotification is issued not in the current round While there are other good choices for the underlying data structure including the special purposetree based structure used in java awt EventMulticaster and more elaborate structuresmaintaining edit records from a common base an array based copy on write collection class issuitable for most applications Traversal via iterators is not only fast but also avoidsConcurrentModificationExceptions that can occur in some other approaches totraversal see class CopyOnWriteArrayList protected Object array new Object Incompleteprotected synchronized Object getArray return array public synchronized void add Object element int len array length Object newArray new Object len System arraycopy array newArray len newArray len element array newArray public Iterator iterator return new Iterator protected final Object snapshot getArray protected int cursor public boolean hasNext return cursor snapshot length public Object next try return snapshot cursor catch IndexOutOfBoundsException ex throw new NoSuchElementException The util concurrent package available from the online supplement contains a version of thisclass that conforms to the java util List interface This class would be horribly inefficient if used in contexts involving frequent modifications of largecollections but it is well suited for most multicast applications as illustrated in and Optimistic UpdatesOptimistic updates employ a weaker protocol than other copy on write techniques Rather thanengaging locks for the entire duration of state update methods they employ synchronization only atthe beginnings and ends of update methods Typically each method takes the form Get a copy of the current state representation while holding a lock Construct a new state representation without holding any locks Commit to the new state only if the old state has not changed since obtaining it Optimistic update techniques limit synchronization to very brief intervals just long enough toaccess and later update state representations This tends to provide very good performance onmultiprocessors at least under appropriate usage conditions The main added requirement here over conventional copy on write techniques is dealing with thepossibility that Step will fail because some other thread has independently updated the staterepresentation before the current thread has had a chance to do so The potential for failure introducestwo concerns discussed in more detail in that limit the range of applicability of optimisticupdate techniques Failure protocols The choices are either to retry the entire method sequence or to propagate thefailure back to a client which can then take evasive action The most common choice is to retry However this can lead to livelock the optimistic analog of indefinite blocking in which methodscontinuously spin without making any further progress While the probability of livelock is normallyvanishingly small the action may never complete and may expend a lot of CPU resources repeatedlyattempting to do so For this reason optimistic update techniques are bad choices for classes used incontexts that may encounter massive thread contention of unbounded duration However somespecialized wait free optimistic algorithms have been proven to succeed after a bounded number ofattempts regardless of contention see Further Readings Side effects Because they may fail the actions performed while constructing new staterepresentations cannot include any irrevocable side effects For example they should not write to files create threads or draw to GUIs unless these actions can themselves be meaningfully cancelled uponfailure see Atomic commitmentThe heart of any optimistic technique is an atomic commitment method that is used instead ofassignment statements It must conditionally swap in a new state representation only if the existingstate representation is the one expected by the caller There are many ways to distinguish and trackdifferent state representations for example using version numbers transaction identifiers timestamps and signature codes But it is by far most convenient and most common to simply rely on thereference identity of the state object Here is a generic example class Optimistic Generic code sketchprivate State state reference to representation objectprivate synchronized State getState return state private synchronized boolean commit State assumed State next if state assumed state next return true elsereturn false There are several common minor variations in how the commit method is defined For example theversion usually named compareAndSwap returns the current value which may be either the newor the old value depending on whether the operation committed successfully The increasingpopularity of optimistic techniques in systems level concurrent programming is in part due to and inpart the cause of the fact that most modern processors include an efficient built incompareAndSwap instruction or one of its variants While these are not directly accessible fromthe Java programming language it is in principle possible for optimizing compilers to map constructsto use such instructions Even if not optimistic updates are still efficient In a purely optimistic class most update methods take a standard form getting the initial state building a new state representation and then committing if possible else looping or throwing anexception However methods that do not rely on any particular initial states can be written moresimply unconditionally swapping in the new state For example here is an optimistic version of theDot class class OptimisticDot protected ImmutablePoint loc public OptimisticDot int x int y loc new ImmutablePoint x y public synchronized ImmutablePoint location return loc protected synchronized boolean commit ImmutablePoint assumed ImmutablePoint next if loc assumed loc next return true elsereturn false public synchronized void moveTo int x int y bypass commit since the operation is unconditionalloc new ImmutablePoint x y public void shiftX int delta boolean success false do ImmutablePoint old location ImmutablePoint next new ImmutablePoint old x delta old y success commit old next while success If the potential for prolonged interference is a concern rather than simply spinning the loop inshiftX can use an exponential back off scheme as discussed in Open ContainersOrdered hierarchical locking techniques may be applied when you have a layered containment design but cannot or do not want to strictly hide all of the Part objects from other clients If Parts are visible to clients they must employ synchronization But when these parts frequentlyinvoke methods on other parts the resulting designs may be prone to deadlock For example supposeone thread holds the lock on part which in turn makes a call to part while another thread isdoing the opposite You can eliminate this form of deadlock by using the strategy seen in strict object confinementdesigns arrange that the Part objects rely on the Host lock for their synchronization control If clientsmust first obtain the host lock then this form of deadlock cannot occur This solution suffices for most containment designs involving visible components see also for an additional variant Obtaining outermost locks of containers before operating on parts representsa structured approach to applying the resource ordering techniques discussed in However without confinement there is no simple strategy that enforces this solution Classes and their authors must know the rules and stick to them The main policy choice concerns who should know these rules the internal parts or the external clients Neither choice is at all perfect but one must be adopted Internal locking is difficult to retrofit to existing classes and can increase the dependence of aclass on its context External locking fails if any client forgets to use the protocol Internal disciplinesUnder internal containment locking each Part uses its container s synchronization lock for all methodsrequiring dynamic exclusion control In the most efficient case each Part has a final field that isinitialized upon construction and then used for all locking Additional unrelated locking inside the Partmethods may also be acceptable but see For example class Part Code sketchprotected final Object lock public Part Object owner lock owner public Part lock this if no owner use selfpublic void anAction synchronized lock anotherPart help As a matter of design policy you can define most or all classes in this way in order to accommodateusage in various container based frameworks However these designs are more difficult to managewhen the ownership of a Part can change dynamically In this case you must additionally synchronizeaccess to the lock field itself normally using synchronized this before using it to controlaccess to the body of a method A simpler structure is available when you can arrange that each Part class be declared as an inner classof its Host In this case you can use synchronized blocks with Host this as an argument class Host code sketchclass Part public void anAction synchronized Host this anotherPart help External disciplinesIn the most extreme unstructured version of external locking each caller of each method on each Partmust somehow know which lock to acquire before making the call synchronized someLock aPart anAction In finite closed systems developers can even create a list defining which locks are to be associatedwith which objects and then require code authors to conform to these rules This tactic can bedefensible for small non extensible embedded systems that might otherwise be prone to deadlock However this solution of course does not scale well In even slightly larger contexts client code mustbe able to programmatically determine which lock to use One way to arrange this is to constructtables that maintain the required associations between objects and locks A slightly more structuredstrategy is to include in each Part class a method say getLock that returns the lock to use forsynchronization control Clients can then make calls using synchronized aPart getLock aPart anAction This approach is used in the java awt package at least up through release Eachjava awt Component supports method getTreeLock that returns the lock to be used forcontrolling synchronized operations on the current container for example a Frame Choice of howand when to use this lock is then left to client code This introduces opportunities for ad hocextensibility and can result in minor performance improvements compared to internal lockingdisciplines For example a client need not reacquire the lock if it is known to be held already But thisform of external locking also introduces more opportunities for error as well as the need for extensivedocumentation clients must know enough about operations to determine whether and how locksshould be used Multilevel containmentBoth approaches to hierarchical containment locking can be extended past two levels Each layer ofthe hierarchy must have an associated lock Code must pass through the locks at all layers inoutermost to innermost order before invoking update methods Support for an arbitrary level ofnested locks is exceedingly awkward to set up using synchronized blocks or methods but maybe approachable using lock utility classes and managers see Further ReadingsA general account of refactoring classes is Fowler Martin Refactoring Addison Wesley Optimistic update algorithms that can be proven to succeed eventually include the class of wait freealgorithms in which no thread ever blocks on a condition that can be satisfied only by the action ofsome other thread In wait free algorithms every thread succeeds after a finite number of attempts regardless of what other threads do or do not do Most algorithms employ the notion of helping whena thread cannot continue it takes some action to help another thread complete its task The theory ofwait free algorithms is described in Herlihy Maurice Wait free synchronization ACM Transactions on Programming Languages andSystems vol no Practical wait free update algorithms are known for only a small number of common data structures for example queues and lists However these algorithms are increasingly used in underlying run timesupport in operating system kernels and JVM implementations The online supplement contains anadaptation of a wait free queue class described in the following paper as well as links to descriptionsof wait free algorithms implemented in other languages Michael Maged and Michael Scott Simple fast and practical non blocking and blocking concurrentqueue algorithms Proceedings th ACM Symposium on Principles of Distributed Computing ACM Using Lock UtilitiesBuilt in synchronized methods and blocks suffice for many lock based applications but theyhave the following limitations There is no way to back off from an attempt to acquire a lock if it is already held to give upafter waiting for a specified time or to cancel a lock attempt after an interrupt This can makeit difficult to recover from liveness problems There is no way to alter the semantics of a lock for example with respect to reentrancy readversus write protection or fairness There is no access control for synchronization Any method can performsynchronized obj for any accessible object thus leading to potential denial of service problems caused by the holding of needed locks Synchronization within methods and blocks limits use to strict block structured locking Forexample you cannot acquire a lock in one method and release it in another These problems can be overcome by using utility classes to control locking Such classes can beconstructed using the techniques described in Here we restrict attention to their use inimplementing lock based designs While it is possible to create lock classes providing just about anydesired semantics and usage properties we illustrate only two common ones mutual exclusion locksand read write locks For the sake of concreteness presentations rely on the versions of these classesin the util concurrent package available from the online supplement However similarremarks hold for just about any kind of lock utility class that you could construct All lock based designs discussed previously in this chapter can if desired be re implemented usinglock utilities rather than built in synchronized methods and blocks Additional examples maybe found in most of the concurrent systems programming texts listed in This section focuseson usages that are otherwise difficult to arrange The solutions provided by lock utility classes come at the price of more awkward coding idioms andless automatic enforcement of correct usage Using lock utilities requires more care and disciplinethan typically necessary when using synchronized methods and blocks These constructionsmay also entail greater overhead since they are less readily optimized than are uses of built insynchronization MutexesA Mutex short for mutual exclusion lock class can be defined as omitting implementation code public class Mutex implements Sync public void acquire throws InterruptedException public void release public boolean attempt long msec throwsInterruptedException In the util concurrent version Mutex implements interface Sync a standardizedinterface for all classes obeying acquire release protocols As you might expect acquire is analogous to the operations performed on entry into asynchronized block and release is analogous to the operations performed on exit from ablock The attempt operation returns true only if the lock is acquired within the specified time at least to the best of the implementation s ability to measure this time and react in a timely manner see Zero is a legal argument meaning do not wait at all if the lock is not available Also unlike built in synchronization the acquire and attempt methods throwInterruptedException if the current thread has been interrupted while trying to obtain thelock This complicates usage but makes possible the development of responsive and robust code inthe face of cancellation The range of reasonable responses to InterruptedException isdiscussed in more detail in here we illustrate only the most common options A Mutex can be used in the same way as a built in lock by replacing blocks of the form synchronized lock body with the more verbose and awkward before after construction try mutex acquire try body finally mutex release catch InterruptedException ie response to thread cancellation during acquire Unlike synchronized blocks locking in standard Mutex classes is non reentrant If the lock isheld even by the thread performing the acquire the thread will block While it is possible todefine and use a ReentrantLock as well a simple Mutex class suffices in many lockingapplications For example we can use it to re implement the Particle class from class ParticleUsingMutex protected int x protected int y protected final Random rng new Random protected final Mutex mutex new Mutex public ParticleUsingMutex int initialX int initialY x initialX y initialY public void move try mutex acquire try x rng nextInt y rng nextInt finally mutex release catch InterruptedException ie Thread currentThread interrupt public void draw Graphics g int lx ly try mutex acquire try lx x ly y finally mutex release catch InterruptedException ie Thread currentThread interrupt return g drawRect lx ly The try finally constructions surrounding the operation bodies mimic the behavior ofsynchronized blocks in which locks are released no matter how the body exits even if via anuncaught exception As a design rule it is a good idea to use try finally even if you believethat the body cannot throw any exceptions The move and draw methods both return immediately without performing any action if the threadwas interrupted during lock acquisition This is a simple and appropriate response to cancellation However as discussed in the catch clauses are also obligated to propagate cancellationstatus via Thread currentThread interrupt The ParticleUsingMutex class is more resistant to hostile denial of service attacks than is theoriginal Since the built in synchronized lock is not used it doesn t matter if anyone holds it Note however that no such problems could occur in ParticleApplet anyway because allreferences are confined to the applet If we were even more paranoid we might declare mutex asprivate But in most cases this would needlessly preclude extensibility Since any plausiblesubclass would also need to access the lock declaring mutex as private is nearly equivalent todeclaring the class itself as final Method adaptersBetter structure and discipline surrounding locks can be arranged via any of the before after patternsdiscussed in For example the use of method adapters supports definition of generic wrappersthat can run any code within any lock A wrapper can be defined either as method of a class usinglocking or as a separate utility class An example of the latter is class WithMutex private final Mutex mutex public WithMutex Mutex m mutex m public void perform Runnable r throws InterruptedException mutex acquire try r run finally mutex release This could be used by classes that separate out bare actions as internal methods invoked withinwrappers by public methods for example class ParticleUsingWrapper Incomplete protected final WithMutex withMutex new WithMutex new Mutex protected void doMove x rng nextInt y rng nextInt public void move try withMutex perform new Runnable public void run doMove catch InterruptedException ie Thread currentThread interrupt This design encounters somewhat greater overhead so it is mainly applicable in classes protectingrelatively time consuming actions Also the illustrated version applies only to internal actions that canbe expressed as argumentless resultless Runnables So for example it cannot be used with thedraw method However this scheme can be extended by defining additional method adapters thataccept other arguments and or return results as described in Back offsThe attempt method is useful for recovery from deadlocks and other liveness problems involvingmultiple locks When you cannot ensure that lockups are impossible as is the case for at least somecomponents in most open systems you can routinely use attempt instead of acquire providing a heuristic time out value for example a few seconds to indicate possible lockups andthen take evasive action upon failure see The attempt method can also be used in more specialized constructions to deal with particulardeadlock prone constructions For example here is another version of the Cell class from that backs out and retries upon discovering a potential deadlock As a heuristic it includes a shortdelay between retries Because it relies on retries it can livelock This may be acceptable if you canconvince yourself that the probability of infinite livelock is say less than the probability of a randomhardware failure Note that alias checking is needed here and in all similar constructions involving non reentrant locksto avoid lockups while trying to re acquire a lock that is already held see class CellUsingBackoff private long value private final Mutex mutex new Mutex void swapValue CellUsingBackoff other if this other return alias check required herefor try mutex acquire try if other mutex attempt try long t value value other value other value t return finally other mutex release finally mutex release Thread sleep catch InterruptedException ie Thread currentThread interrupt return ReorderingsBack off techniques may be used as safeguards in designs employing lock ordering techniques see and in which there are relatively rare exceptions to a given locking hierarchy In thesecases code requiring multiple locks can try one ordering and if it fails release all locks and try adifferent ordering This strategy can extend the range of applicability of containment based lockingschemes You do not need to be absolutely certain that all locking maintains the desired ordering ifyou can arrange a somewhat more expensive fallback strategy to deal with exceptional cases Thismight occur for example in hierarchical containment designs employing callbacks or collectiontraversals in which it is not possible to ensure conformance to a given set of lock ordering rules To illustrate basic techniques here is a Cell class that employs such a deadlock avoidance shufflefor swapValue Upon getting stuck it attempts to lock the two objects from the opposite direction class CellUsingReorderedBackoff private long value private final Mutex mutex new Mutex private static boolean trySwap CellUsingReorderedBackoff a CellUsingReorderedBackoff b throws InterruptedException boolean success false if a mutex attempt try if b mutex attempt try long t a value a value b value b value t success true finally b mutex release finally a mutex release return success void swapValue CellUsingReorderedBackoff other if this other return alias check required heretry while trySwap this other trySwap other this Thread sleep catch InterruptedException ex Thread currentThread interrupt Non block structured lockingA Mutex may be used in constructions that cannot be expressed using synchronized blocksbecause the acquire release pairs do not occur in the same method or code block For example you can use a Mutex for hand over hand locking also known as lock coupling acrossthe nodes of a linked list during traversal Here the lock for the next node must be obtained while thelock for the current node is still being held But after acquiring the next lock the current lock may bereleased Hand over hand traversal allows extremely fine grained locking and thus increases potentialconcurrency but at the cost of additional complexity and overhead that would normally be worthwhileonly in cases of extreme contention class ListUsingMutex static class Node Object item Node next Mutex lock new Mutex each node keeps its own lockNode Object x Node n item x next n protected Node head pointer to first node of list Use plain synchronization to protect head field We could instead use a Mutex here too but there is no reason to do so protected synchronized Node getHead return head public synchronized void add Object x simple prepend for simplicity here do not allow null elementsif x null throw new IllegalArgumentException The use of synchronized here protects only head field The method does not need to wait out other traversers that have already made it past head node head new Node x head boolean search Object x throws InterruptedException Node p getHead if p null x null return false p lock acquire Prime loop by acquiring first lock If above acquire fails due to interrupt the method will throw InterruptedException now so there is no need for further cleanup for Node nextp null boolean found try found x equals p item if found nextp p next if nextp null try Acquire next lock while still holding currentnextp lock acquire catch InterruptedException ie throw ie Note that finally clause will execute before the throw finally release old lock regardless of outcomep lock release if found return true else if nextp null return false else p nextp other similar traversal and update methods Another application of Mutex that exploits the lack of required block structuring is the constructionof condition variable objects discussed in Lock Ordering ManagersWhen multiple locks must be obtained in some particular order for example in the hierarchicalcontainment schemes discussed in and the general resource ordering techniques discussed in you can help ensure conformance by centralizing the ordering methods in a lock manager class There are numerous techniques for structuring the kinds of locks used defining their ordering rules and establishing the responsibilities of the manager class However nearly any design containsmethods of the following form which illustrates the care required to ensure that locks will be releasedno matter what exceptions occur class LockManager Code sketch protected void sortLocks Sync locks public void runWithinLocks Runnable op Sync locks throws InterruptedException sortLocks locks for help in recovering from exceptionsint lastlocked InterruptedException caught null try for int i i locks length i locks i acquire lastLocked i op run catch InterruptedException ie caught ie finally for int j lastlocked j j locks j release if caught null throw caught Read Write LocksReadWriteLocks maintain a pair of associated locks One way to define them is interface ReadWriteLock Sync readLock Sync writelock The locks returned by the two methods here obey the same Sync interface as Mutex see supporting methods acquire release and attempt As discussed in there are a number of ways to implement this interface depending onselection of the desired policies surrounding their use For the sake of illustration we will assumedefinition of a generic implementation class RWLock The idea behind read write locks is that the readLock may be held simultaneously by multiplereader threads so long as there are no writers The writeLock is exclusive Read Write locks aregenerally preferable to plain locks when The methods in a class can be cleanly separated into those that only access read internallyheld data and those that modify write Reading is not permitted while writing methods are in progress If reads are permitted duringwrites you may instead rely on unsynchronized read methods or copy on write updates see Target applications generally have more readers than writers The methods are relatively time consuming so it pays to introduce a bit more overheadassociated with read write locks compared to simpler techniques in order to allowconcurrency among reader threads Read write locks are often used in classes that provide access to large collections of data wheremethods are structured as class DataRepository Code sketchprotected final ReadWriteLock rw new RWLock public void access throws InterruptedException rw readLock acquire try read data finally rw readLock release public void modify throws InterruptedException rw writeLock acquire try write data finally rw writeLock release Read write locks can be useful in some applications of ordinary collection classes Theutil concurrent package available from the online supplement contains a set of adapterclasses that can be used with java util Collection classes placing read locks aroundpurely inspective methods such as contains and write locks around update methods such asadd Further ReadingsA set of patterns for using different styles of locks can be found in McKenney Paul Selecting Locking Primitives for Parallel Programming Communications of theACM Chapter State DependenceTwo kinds of enabling conditions are generally needed to perform any action External An object receives a message requesting that an action be performed Internal The object is in an appropriate state to perform the action As a non programming example suppose you are asked to write down a telephone message To dothis you need to have a pencil and paper or some other recording device Exclusion techniques are mainly concerned with maintaining invariants State dependent concurrencycontrol imposes additional concerns surrounding preconditions and postconditions Actions may havestate based preconditions that need not always hold when clients invoke methods on the host object Conversely actions may have postconditions that are unattainable when the host object is not in aproper state when the actions of other objects it relies on fail to achieve their own postconditions orwhen the actions of other threads have changed the states of other objects being relied on Most design issues for classes with state dependent actions revolve around the considerationsnecessary to complete a design so that you take into account all possible combinations of messagesand states as in phone ringtake messagehave pencilanswer phonewrite messagedo not have pencilanswer phone As hinted in the table designs usually need to take into account situations in which the object is not ina state that permits any normal action In an ideal system all methods would have no state basedpreconditions and would always fulfill their postconditions When sensible classes and methodsshould be written in this fashion thus avoiding nearly all the issues discussed in this chapter Butmany activities are intrinsically state dependent and just cannot be programmed to achievepostconditions in all states There are two general approaches to the design and implementation of any state dependent action thatstem from liveness first versus safety first design perspectives Optimistic try and see methods can always be tried when invoked but do not always succeed andthus may have to deal with failure Conservative check and act methods refuse to proceed unless preconditions hold When preconditionsdo hold the actions always succeed If methods check neither their preconditions nor their postconditions they can be called only incontexts in which the preconditions are somehow known to hold Reliance on such practices inconcurrent systems is problematic at best Optimistic and conservative approaches are about equally prevalent and appropriate forms of themmay be equally good or bad with respect to various design forces But since their general forms aregoverned by issues that may be outside of your control the two are not always interchangeable Optimistic approaches rely on the existence of exceptions and related mechanism that indicate whenpostconditions do not hold Conservative approaches rely on the availability of guard constructionsthat indicate when preconditions hold and guarantee that they continue to hold across the course of anaction relying on them Mixtures are of course possible and are in fact common In particular manyconservative designs contain code that may encounter exceptions and thus must be prepared to dealwith failure Concurrency control measures that deal with state dependent actions can require significant effort andattention in concurrent programming This chapter divides coverage as follows discusses exceptions and cancellation introduces the guard constructions used in conservative designs along with themechanics used to implement them presents structural patterns for classes employing concurrency control shows how utility classes can reduce complexity while improving reliability performance and flexibility extends problems and solutions to deal with joint actions those depending on thestates of multiple participants provides a brief overview of transactional concurrency control concludes with some techniques seen in the construction of concurrency control utilityclasses Dealing with FailurePure optimistic control designs originate from optimistic update and transaction protocols Butoptimistic approaches of some sort are seen in just about any code making calls to methods that mayencounter failures Try and see designs attempt actions without first ensuring that they will succeed often because the constraints that would ensure success cannot be checked However optimisticmethods always check postconditions often by catching failure exceptions and if they fail to hold apply a chosen failure policy The need for try and see approaches usually stems from inability or unwillingness to checkpreconditions and related constraints This can arise in the following ways Some conditions cannot be computed using the constructs available in a given language orexecution context For example it is not possible to check whether a given lock is being heldor a given reference is unique see In concurrent programs preconditions may have temporal scopes in which case they aresometimes called activation constraints If a constraint is not under the control of the hostobject then even if it is known to hold momentarily it need not hold throughout the course ofan action relying on it For example your pencil may break while you are writing a message A file system that is known at entry to a method to have enough space to write a file may runout of space due to the actions of other independent programs before the method finisheswriting the file Similarly the fact that a given remote machine is currently available saysnothing about whether it will crash or become unreachable in the course of a method relyingon it Some conditions change due to the signaling actions of other threads The most commonexample is cancellation status which may asynchronously become true while any thread isperforming any action see Some constraints are too computationally expensive to check for example a requirement thata matrix be normalized in upper triangular form When actions are simple and easy to undo orthe chances of failure are extremely low it might not be worth computing even simplepreconditions instead relying on fallback strategies upon later detection of failure In all these cases the lack of provisions that would ensure success forces methods to detect and dealwith potential failures to achieve postconditions ExceptionsAccommodations for failure infiltrate the design of multithreaded programs Concurrency introducesthe possibility that one part of a program will fail while others continue But without care a failingaction may leave objects in states such that other threads cannot succeed Methods may throw exceptions as well as set status indicators or issue notifications when they havedetected that their intended effects or postconditions cannot be attained There are six generalresponses to such failed actions abrupt termination continuation ignoring failures rollback roll forward retry and delegation to handlers Abrupt termination and continuation are the two mostextreme responses Rollback and roll forward are intermediate options that ensure that objectsmaintain consistent states Retries locally contain failure points Delegation allows cooperativeresponses to failure across objects and activities Choices among these options must be agreed upon and advertised It is sometimes possible to supportmultiple policies and let client code decide which one to use for example via dialogs asking userswhether to retry reading from a disk Additional examples of these options are illustrated throughoutthis book Abrupt terminationAn extreme response to failure is to let a method die immediately returning usually via an exception regardless of the state of the current object or status of the current activity This may apply if you arecertain that local failure forces failure of the entire activity and that the objects engaged in the activitywill never be used again for example if they are completely confined within a session see For example this might be the case in a file conversion component that fails to open the file to beconverted Abrupt termination is also the default strategy for uncaught and undeclared RuntimeExceptions such as NullPointerException that most often indicateprogramming errors When a normally recoverable failure cannot be dealt with you can force moreextreme responses by escalating it to a throw of a RuntimeException or Error Short of full program termination via System exit options for further recovery from sucherrors are often very limited When objects are intrinsically shared across activities and there is noway to re establish consistent object states upon failure and there is no possible or practical way toback out of a failing operation then the only recourse is to set a broken or corrupted flag inthe object encountering the failure and then abruptly terminate Such a flag should cause all futureoperations to fail until the object is somehow repaired perhaps via the actions of an error handlerobject ContinuationIf a failed invocation has no bearing on either the state of the caller object or the overall functionalityrequirements of the current activity then it may be acceptable just to ignore the exception andcontinue forward While it is ordinarily too irresponsible to contemplate this option may apply inevent frameworks and oneway messaging protocols see For example a failed invocation of achange notification method on a listener object might at worst cause some parts of an animationsequence to be skipped without any other long term consequences Continuation policies are also seen within other error handlers and inside most finally clauses that ignore other incidental exceptions occurring while they are trying to deal with the failure thattriggered them for example ignoring exceptions while closing files They may also be used in threadsthat should never shut down and thus try their best to continue in the face of exceptions RollbackThe most desirable semantics in optimistic designs are clean fail guarantees Either the operationsucceeds completely or it fails in a way that leaves the object in exactly the same state as before theoperation was attempted The optimistic update techniques in demonstrate one form of thisapproach in which the success criterion is lack of interference by other threads trying to performupdates There are two complementary styles for maintaining state representations that can be used inrollbacks Provisional action Before attempting updates construct a new representation that will upon success be swapped in as the current state Methods perform updates on the tentative new version of the staterepresentations but do not commit to the new version until success is assured This way nothingneeds to be undone upon failure Checkpointing Before attempting updates record the current state of the object in a history variable perhaps in the form of a Memento see the Design Patterns book Methods directly perform updateson the current representation But upon failure fields can be reverted to the old values Provisional action is usually necessary when actions are not otherwise fully synchronized Provisionalaction eliminates the possibility that other threads will see inconsistent partially updatedrepresentations It is also more efficient when reads are much more common than writes Checkpointing is usually simpler to arrange and is thus often preferable in other situations In eitherapproach it is not always necessary to create new representation objects to record state often a fewextra fields in the object or local variables inside the methods suffice Situation specific rollback techniques are needed for actions other than state updates that must beundone upon failure including actions resulting from sending other messages Every message sentwithin such a method should have an inverse antimessage For example a credit operation mightbe undone via debit This idea can be extended to maintaining undo lists associated with sequencesof actions in order to allow rollback to any given point Some kinds of operations can neither be provisionally attempted nor undone via antimessages andthus cannot employ rollback techniques This rules out methods with externally visible effects thatirrevocably change the real world by performing IO or actuating physical devices unless it is possibleto undo the actions without harm In the case of IO conventions can be adopted to allow theconceptual equivalent of rollback For example if methods log actions in a log file and the log filesupports a please disregard log entry XYZ option then this can be invoked in case of failure However as discussed further in rollback of most IO objects such as InputStreams themselves is typically not possible There are no control methods to revert the internal buffers orother fields of most IO objects back to the values they held at some arbitrary point Typically the bestyou can do is close the IO objects and construct new ones bound to the same files devices or networkconnections Roll forwardWhen rollback is impossible or undesirable but full continuation is also impossible you may insteadpush ahead as conservatively as possible to re establish some guaranteed legal consistent state thatmay be different from the one holding upon entry to the method Roll forward sometimes knownsimply as recovery is often perfectly acceptable as far as other objects methods and threads areconcerned in many cases they cannot even distinguish it from rollback Some such actions may be placed in finally clauses that perform minimal cleanup for exampleclosing files cancelling other activities necessary to reach safe points of program execution Mostroll forward techniques otherwise take forms similar to rollback techniques But because they do notrequire full representations of saved or provisional state they are usually slightly easier to arrange Some methods can be divided into two conceptual parts a preliminary part that can roll back easily for example by either returning or rethrowing the exception immediately and the part occurringafter a point of no return at which some unrecoverable action has already begun that must beadvanced to a safe point even upon failure For example a method may reach a point in a protocol atwhich an acknowledgment must be sent or received see RetryYou can contain local failure to the current method rather than throwing exceptions back to clients ifyou have reason to believe that retrying an action will succeed Retries are in general only possiblewhen local rollback options can be applied so that the state of the object and status of the activityremain the same at the beginning of each retry attempt Retry based tactics may be used when failure is due to other independent objects that may have beenin temporarily bad or undesired states for example when dealing with IO devices and remotemachines As seen in optimistic state update methods also typically rely on retries sinceinterference patterns are extremely unlikely to persist indefinitely Retries are also common in pollingdesigns for example those discussed in Variants of retries are seen in cascading algorithmsthat first try the most desirable of several alternative actions and if that fails try a series of lessdesirable alternatives until one succeeds Without care retries can consume unbounded amounts of CPU time see You can minimizethe likelihood of repeated contention based failures as well as reduce CPU wastage by insertingheuristic delays between attempts One popular strategy seen for example in Ethernet protocols isexponential backoff in which each delay is proportionally longer than the last one For example you could use the following method to connect to a server that sometimes refusesconnections because it is overloaded The retry loop backs off for a longer time after each failure However it fails upon thread interruption see since there is no point in continuing if thecurrent thread has been cancelled As noted in on some releases of JDK you may need tomodify this to catch InterruptedIOException and rethrowInterrruptedException class ClientUsingSocket Code sketch Socket retryUntilConnected throws InterruptedException first delay is randomly chosen between and secslong delayTime long Math random for try return new Socket server portnumber catch IOException ex Thread sleep delayTime delayTime delayTime increase HandlersCalls callbacks or notifications to error handling objects can be useful when you need to offloaderror processing operations to centralized handlers because an exception in one thread or one part of asystem requires compensating actions in other threads or other parts of a system that wouldn totherwise be known to the method catching the exception They can also be used to make code moreextensible and more resilient
