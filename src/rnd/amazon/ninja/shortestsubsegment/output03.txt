offload synchronization protection to objects used solely to protect basic operations on basic types Such classes play a similar role as classes java lang Double and java lang Integer except that instead of promising immutability they promise atomicity For example you can create aclass such as class SynchronizedInt private int value public SynchronizedInt int v value v public synchronized int get return value public synchronized int set int v returns previousvalueint oldValue value value v return oldValue public synchronized int increment return value and so on The util concurrent package available from the online supplement contains a set of suchclasses one for each basic type that also support other utility operations such as the commit methoddescribed in These classes could be used for example in class Person Fragmentsprotected final SynchronizedInt age new SynchronizedInt protected final SynchronizedBoolean isMarried new SynchronizedBoolean false protected final SynchronizedDouble income new SynchronizedDouble public int getAge return age get public void birthday age increment Linked data structuresLock splitting techniques can minimize access contention to objects serving as entry points into linkeddata structures by finding a middle ground between the extreme strategies of fully synchronizing theentry classes which can limit concurrency and fully synchronizing all the linked node objects beingcontrolled which can be inefficient and can lead to liveness problems As with all lock splitting techniques the main goal is to associate different locks with differentmethods But in the case of linked structures this often leads to further adjustments in the datastructures and algorithms themselves There are no universally applicable recipes for splittingsynchronization in classes controlling access to linked structures but the following class illustratessome common tactics The following LinkedQueue class can serve as a generic unbounded first in first out FIFO queue It maintains separate synchronization for put and poll The putLock lock ensures thatonly one put operation at a time can proceed The pollLock lock similarly ensures that only onepoll operation at a time can proceed A head node always exists in this implementation so that aput and a poll can normally proceed independently After each poll the previous first nodebecomes the new head Additionally the accessed nodes themselves must be locked to preventconflicts when a put and a poll are both simultaneously executing on a queue that was previouslyempty or is about to become empty in which case head and last both refer to the same headernode class LinkedQueue protected Node head new Node null protected Node last head protected final Object pollLock new Object protected final Object putLock new Object public void put Object x Node node new Node x synchronized putLock insert at end of listsynchronized last last next node extend listlast node public Object poll returns null if emptysynchronized pollLock synchronized head Object x null Node first head next get to first real nodeif first null x first object first object null forget old objecthead first first becomes new head return x static class Node Object object Node next null local node class for queueNode Object x object x The online supplement includes queue classes that further refine extend and optimize this basicdesign Read Only AdaptersIn confinement based designs see a Host object cannot reveal the identity of any of its Partobjects This eliminates the choice of returning references to parts in any accessor or propertyinspection method One alternative is instead to return a copy of the Part For example class SynchedPoint could add a method public synchronized BarePoint getPoint return new BarePoint delegate x delegate y When Parts are instances of classes known to implement an appropriate clone method you caninstead return part clone And when you need to return arbitrary sets of values you can usean ad hoc array for example public synchronized double getXY return new double delegate x delegate y However copying can be too expensive when dealing with some objects and does not make sensewhen dealing with others for example objects that maintain references to files threads or otherresources that should not themselves be copied In many cases you can instead selectively permitsome leakage by constructing and returning an Adapter object surrounding the part that exposes onlythose operations that clients may use without introducing any potential interference generally read only operations Unless these methods deal only with immutable state they require synchronization The most secure version of this scheme takes a bit of work to set up Define a base interface describing some non mutative functionality Optionally define a subinterface that supports additional update methods used in the normalmutable implementation class Define a read only adapter that forwards only the exported operations For added security declare that the immutable class is final The use of final means that when you thinkyou have an immutable object you really do it s not of some subclass that supportsmutable operations as well These steps can be applied to the following simple Account class Even though accounts in thisexample are held only by AccountHolders the general purpose mutableUpdatableAccount implementation employs synchronization class InsufficientFunds extends Exception interface Account long balance interface UpdatableAccount extends Account void credit long amount throws InsufficientFunds void debit long amount throws InsufficientFunds Sample implementation of updatable versionclass UpdatableAccountImpl implements UpdatableAccount private long currentBalance public UpdatableAccountImpl long initialBalance currentBalance initialBalance public synchronized long balance return currentBalance public synchronized void credit long amount throws InsufficientFunds if amount currentBalance amount currentBalance amount elsethrow new InsufficientFunds public synchronized void debit long amount throws InsufficientFunds credit amount final class ImmutableAccount implements Account private Account delegate public ImmutableAccount long initialBalance delegate new UpdatableAccountImpl initialBalance ImmutableAccount Account acct delegate acct public long balance forward the immutable methodreturn delegate balance These classes could be used for example in class AccountRecorder A logging facilitypublic void recordBalance Account a System out println a balance or record in file class AccountHolder private UpdatableAccount acct new UpdatableAccountImpl private AccountRecorder recorder public AccountHolder AccountRecorder r recorder r public synchronized void acceptMoney long amount try acct credit amount recorder recordBalance new ImmutableAccount acct catch InsufficientFunds ex System out println Cannot accept negative amount Use of a read only wrapper at line might seem an unnecessary precaution But it guards againstwhat might happen if someone were to write the following subclass and use it in conjunction withAccountHolder class EvilAccountRecorder extends AccountRecorder private long embezzlement public void recordBalance Account a super recordBalance a if a instanceof UpdatableAccount UpdatableAccount u UpdatableAccount a try u debit embezzlement catch InsufficientFunds quietlyignore The java util Collection framework uses a variant of this scheme Rather than declaring aseparate immutable interface the main Collection interface permits mutative methods to throwUnsupportedOperationExceptions Anonymous read only adapter classes throw theseexceptions on all attempted update operations They can be constructed via for example List l new ArrayList untrustedObject use Collections unmodifiableList l Copy on WriteWhen a set of fields comprising the state of an object must maintain a set of interrelated invariants you can isolate these fields in another object that preserves the intended semantic guarantees A good way to go about this is to rely on immutable representation objects that at all times maintainconsistent snapshots of legal object states Relying on immutability eliminates the need to otherwisecoordinate separate readings of related attributes It also normally eliminates the need to hide theserepresentations from clients For example in we had to take special precautions involving block synchronization in orderto guarantee that consistent x y coordinates of Particles were always displayed correctly Andthe Shape classes described in do not even provide a mechanism for doing this One solutionis to employ a separate ImmutablePoint class that maintains location information that is at alltimes consistent class ImmutablePoint private final int x private final int y public ImmutablePoint int initX int initY x initX y initY public int x return x public int y return y ImmutablePoints could be used in the following Dot class that is otherwise similar to theParticle class in This class illustrates the general techniques surrounding copy on writeupdates in which state changes do not directly update fields but instead construct and attach newrepresentation objects Note that synchronization of some form is required here Even though the point representation objectsare immutable the loc reference is mutable While synchronization of the accessor methodlocation might be loosened in accord with the considerations in the shiftX methodmust be synchronized or perhaps otherwise modified in order to preclude multiple concurrentexecutions in which different versions of loc are obtained when accessing l oc x andloc y class Dot protected ImmutablePoint loc public Dot int x int y loc new ImmutablePoint x y public synchronized ImmutablePoint location return loc protected synchronized void updateLoc ImmutablePoint newLoc loc newLoc public void moveTo int x int y updateLoc new ImmutablePoint x y public synchronized void shiftX int delta updateLoc new ImmutablePoint loc x delta loc y Internal copy on writeWhen state representations are strictly internal to an object there is no compelling reason to createnew classes just to enforce immutable access Copy on write can be applied whenever the need toobtain consistent representations quickly and effortlessly overwhelms construction costs It requires atmost one synchronized operation to access all of the state held by an immutable representation object Additionally in some contexts it is convenient to obtain a single snapshot rather than one that reflectsany state modifications made during the use of that snapshot For example copy on write collection objects can be very useful for maintaining collections oflisteners in event and multicast frameworks see Here objects maintain lists of listeners orhandlers that must receive notifications of state changes or other events of interest These lists rarelychange but may be traversed very frequently Also when objects receiving notifications makechanges in the list of notifyees they are almost always intended to take effect the next time anotification is issued not in the current round While there are other good choices for the underlying data structure including the special purposetree based structure used in java awt EventMulticaster and more elaborate structuresmaintaining edit records from a common base an array based copy on write collection class issuitable for most applications Traversal via iterators is not only fast but also avoidsConcurrentModificationExceptions that can occur in some other approaches totraversal see class CopyOnWriteArrayList protected Object array new Object Incompleteprotected synchronized Object getArray return array public synchronized void add Object element int len array length Object newArray new Object len System arraycopy array newArray len newArray len element array newArray public Iterator iterator return new Iterator protected final Object snapshot getArray protected int cursor public boolean hasNext return cursor snapshot length public Object next try return snapshot cursor catch IndexOutOfBoundsException ex throw new NoSuchElementException The util concurrent package available from the online supplement contains a version of thisclass that conforms to the java util List interface This class would be horribly inefficient if used in contexts involving frequent modifications of largecollections but it is well suited for most multicast applications as illustrated in and Optimistic UpdatesOptimistic updates employ a weaker protocol than other copy on write techniques Rather thanengaging locks for the entire duration of state update methods they employ synchronization only atthe beginnings and ends of update methods Typically each method takes the form Get a copy of the current state representation while holding a lock Construct a new state representation without holding any locks Commit to the new state only if the old state has not changed since obtaining it Optimistic update techniques limit synchronization to very brief intervals just long enough toaccess and later update state representations This tends to provide very good performance onmultiprocessors at least under appropriate usage conditions The main added requirement here over conventional copy on write techniques is dealing with thepossibility that Step will fail because some other thread has independently updated the staterepresentation before the current thread has had a chance to do so The potential for failure introducestwo concerns discussed in more detail in that limit the range of applicability of optimisticupdate techniques Failure protocols The choices are either to retry the entire method sequence or to propagate thefailure back to a client which can then take evasive action The most common choice is to retry However this can lead to livelock the optimistic analog of indefinite blocking in which methodscontinuously spin without making any further progress While the probability of livelock is normallyvanishingly small the action may never complete and may expend a lot of CPU resources repeatedlyattempting to do so For this reason optimistic update techniques are bad choices for classes used incontexts that may encounter massive thread contention of unbounded duration However somespecialized wait free optimistic algorithms have been proven to succeed after a bounded number ofattempts regardless of contention see Further Readings Side effects Because they may fail the actions performed while constructing new staterepresentations cannot include any irrevocable side effects For example they should not write to files create threads or draw to GUIs unless these actions can themselves be meaningfully cancelled uponfailure see Atomic commitmentThe heart of any optimistic technique is an atomic commitment method that is used instead ofassignment statements It must conditionally swap in a new state representation only if the existingstate representation is the one expected by the caller There are many ways to distinguish and trackdifferent state representations for example using version numbers transaction identifiers timestamps and signature codes But it is by far most convenient and most common to simply rely on thereference identity of the state object Here is a generic example class Optimistic Generic code sketchprivate State state reference to representation objectprivate synchronized State getState return state private synchronized boolean commit State assumed State next if state assumed state next return true elsereturn false There are several common minor variations in how the commit method is defined For example theversion usually named compareAndSwap returns the current value which may be either the newor the old value depending on whether the operation committed successfully The increasingpopularity of optimistic techniques in systems level concurrent programming is in part due to and inpart the cause of the fact that most modern processors include an efficient built incompareAndSwap instruction or one of its variants While these are not directly accessible fromthe Java programming language it is in principle possible for optimizing compilers to map constructsto use such instructions Even if not optimistic updates are still efficient In a purely optimistic class most update methods take a standard form getting the initial state building a new state representation and then committing if possible else looping or throwing anexception However methods that do not rely on any particular initial states can be written moresimply unconditionally swapping in the new state For example here is an optimistic version of theDot class class OptimisticDot protected ImmutablePoint loc public OptimisticDot int x int y loc new ImmutablePoint x y public synchronized ImmutablePoint location return loc protected synchronized boolean commit ImmutablePoint assumed ImmutablePoint next if loc assumed loc next return true elsereturn false public synchronized void moveTo int x int y bypass commit since the operation is unconditionalloc new ImmutablePoint x y public void shiftX int delta boolean success false do ImmutablePoint old location ImmutablePoint next new ImmutablePoint old x delta old y success commit old next while success If the potential for prolonged interference is a concern rather than simply spinning the loop inshiftX can use an exponential back off scheme as discussed in Open ContainersOrdered hierarchical locking techniques may be applied when you have a layered containment design but cannot or do not want to strictly hide all of the Part objects from other clients If Parts are visible to clients they must employ synchronization But when these parts frequentlyinvoke methods on other parts the resulting designs may be prone to deadlock For example supposeone thread holds the lock on part which in turn makes a call to part while another thread isdoing the opposite You can eliminate this form of deadlock by using the strategy seen in strict object confinementdesigns arrange that the Part objects rely on the Host lock for their synchronization control If clientsmust first obtain the host lock then this form of deadlock cannot occur This solution suffices for most containment designs involving visible components see also for an additional variant Obtaining outermost locks of containers before operating on parts representsa structured approach to applying the resource ordering techniques discussed in However without confinement there is no simple strategy that enforces this solution Classes and their authors must know the rules and stick to them The main policy choice concerns who should know these rules the internal parts or the external clients Neither choice is at all perfect but one must be adopted Internal locking is difficult to retrofit to existing classes and can increase the dependence of aclass on its context External locking fails if any client forgets to use the protocol Internal disciplinesUnder internal containment locking each Part uses its container s synchronization lock for all methodsrequiring dynamic exclusion control In the most efficient case each Part has a final field that isinitialized upon construction and then used for all locking Additional unrelated locking inside the Partmethods may also be acceptable but see For example class Part Code sketchprotected final Object lock public Part Object owner lock owner public Part lock this if no owner use selfpublic void anAction synchronized lock anotherPart help As a matter of design policy you can define most or all classes in this way in order to accommodateusage in various container based frameworks However these designs are more difficult to managewhen the ownership of a Part can change dynamically In this case you must additionally synchronizeaccess to the lock field itself normally using synchronized this before using it to controlaccess to the body of a method A simpler structure is available when you can arrange that each Part class be declared as an inner classof its Host In this case you can use synchronized blocks with Host this as an argument class Host code sketchclass Part public void anAction synchronized Host this anotherPart help External disciplinesIn the most extreme unstructured version of external locking each caller of each method on each Partmust somehow know which lock to acquire before making the call synchronized someLock aPart anAction In finite closed systems developers can even create a list defining which locks are to be associatedwith which objects and then require code authors to conform to these rules This tactic can bedefensible for small non extensible embedded systems that might otherwise be prone to deadlock However this solution of course does not scale well In even slightly larger contexts client code mustbe able to programmatically determine which lock to use One way to arrange this is to constructtables that maintain the required associations between objects and locks A slightly more structuredstrategy is to include in each Part class a method say getLock that returns the lock to use forsynchronization control Clients can then make calls using synchronized aPart getLock aPart anAction This approach is used in the java awt package at least up through release Eachjava awt Component supports method getTreeLock that returns the lock to be used forcontrolling synchronized operations on the current container for example a Frame Choice of howand when to use this lock is then left to client code This introduces opportunities for ad hocextensibility and can result in minor performance improvements compared to internal lockingdisciplines For example a client need not reacquire the lock if it is known to be held already But thisform of external locking also introduces more opportunities for error as well as the need for extensivedocumentation clients must know enough about operations to determine whether and how locksshould be used Multilevel containmentBoth approaches to hierarchical containment locking can be extended past two levels Each layer ofthe hierarchy must have an associated lock Code must pass through the locks at all layers inoutermost to innermost order before invoking update methods Support for an arbitrary level ofnested locks is exceedingly awkward to set up using synchronized blocks or methods but maybe approachable using lock utility classes and managers see Further ReadingsA general account of refactoring classes is Fowler Martin Refactoring Addison Wesley Optimistic update algorithms that can be proven to succeed eventually include the class of wait freealgorithms in which no thread ever blocks on a condition that can be satisfied only by the action ofsome other thread In wait free algorithms every thread succeeds after a finite number of attempts regardless of what other threads do or do not do Most algorithms employ the notion of helping whena thread cannot continue it takes some action to help another thread complete its task The theory ofwait free algorithms is described in Herlihy Maurice Wait free synchronization ACM Transactions on Programming Languages andSystems vol no Practical wait free update algorithms are known for only a small number of common data structures for example queues and lists However these algorithms are increasingly used in underlying run timesupport in operating system kernels and JVM implementations The online supplement contains anadaptation of a wait free queue class described in the following paper as well as links to descriptionsof wait free algorithms implemented in other languages Michael Maged and Michael Scott Simple fast and practical non blocking and blocking concurrentqueue algorithms Proceedings th ACM Symposium on Principles of Distributed Computing ACM Using Lock UtilitiesBuilt in synchronized methods and blocks suffice for many lock based applications but theyhave the following limitations There is no way to back off from an attempt to acquire a lock if it is already held to give upafter waiting for a specified time or to cancel a lock attempt after an interrupt This can makeit difficult to recover from liveness problems There is no way to alter the semantics of a lock for example with respect to reentrancy readversus write protection or fairness There is no access control for synchronization Any method can performsynchronized obj for any accessible object thus leading to potential denial of service problems caused by the holding of needed locks Synchronization within methods and blocks limits use to strict block structured locking Forexample you cannot acquire a lock in one method and release it in another These problems can be overcome by using utility classes to control locking Such classes can beconstructed using the techniques described in Here we restrict attention to their use inimplementing lock based designs While it is possible to create lock classes providing just about anydesired semantics and usage properties we illustrate only two common ones mutual exclusion locksand read write locks For the sake of concreteness presentations rely on the versions of these classesin the util concurrent package available from the online supplement However similarremarks hold for just about any kind of lock utility class that you could construct All lock based designs discussed previously in this chapter can if desired be re implemented usinglock utilities rather than built in synchronized methods and blocks Additional examples maybe found in most of the concurrent systems programming texts listed in This section focuseson usages that are otherwise difficult to arrange The solutions provided by lock utility classes come at the price of more awkward coding idioms andless automatic enforcement of correct usage Using lock utilities requires more care and disciplinethan typically necessary when using synchronized methods and blocks These constructionsmay also entail greater overhead since they are less readily optimized than are uses of built insynchronization MutexesA Mutex short for mutual exclusion lock class can be defined as omitting implementation code public class Mutex implements Sync public void acquire throws InterruptedException public void release public boolean attempt long msec throwsInterruptedException In the util concurrent version Mutex implements interface Sync a standardizedinterface for all classes obeying acquire release protocols As you might expect acquire is analogous to the operations performed on entry into asynchronized block and release is analogous to the operations performed on exit from ablock The attempt operation returns true only if the lock is acquired within the specified time at least to the best of the implementation s ability to measure this time and react in a timely manner see Zero is a legal argument meaning do not wait at all if the lock is not available Also unlike built in synchronization the acquire and attempt methods throwInterruptedException if the current thread has been interrupted while trying to obtain thelock This complicates usage but makes possible the development of responsive and robust code inthe face of cancellation The range of reasonable responses to InterruptedException isdiscussed in more detail in here we illustrate only the most common options A Mutex can be used in the same way as a built in lock by replacing blocks of the form synchronized lock body with the more verbose and awkward before after construction try mutex acquire try body finally mutex release catch InterruptedException ie response to thread cancellation during acquire Unlike synchronized blocks locking in standard Mutex classes is non reentrant If the lock isheld even by the thread performing the acquire the thread will block While it is possible todefine and use a ReentrantLock as well a simple Mutex class suffices in many lockingapplications For example we can use it to re implement the Particle class from class ParticleUsingMutex protected int x protected int y protected final Random rng new Random protected final Mutex mutex new Mutex public ParticleUsingMutex int initialX int initialY x initialX y initialY public void move try mutex acquire try x rng nextInt y rng nextInt finally mutex release catch InterruptedException ie Thread currentThread interrupt public void draw Graphics g int lx ly try mutex acquire try lx x ly y finally mutex release catch InterruptedException ie Thread currentThread interrupt return g drawRect lx ly The try finally constructions surrounding the operation bodies mimic the behavior ofsynchronized blocks in which locks are released no matter how the body exits even if via anuncaught exception As a design rule it is a good idea to use try finally even if you believethat the body cannot throw any exceptions The move and draw methods both return immediately without performing any action if the threadwas interrupted during lock acquisition This is a simple and appropriate response to cancellation However as discussed in the catch clauses are also obligated to propagate cancellationstatus via Thread currentThread interrupt The ParticleUsingMutex class is more resistant to hostile denial of service attacks than is theoriginal Since the built in synchronized lock is not used it doesn t matter if anyone holds it Note however that no such problems could occur in ParticleApplet anyway because allreferences are confined to the applet If we were even more paranoid we might declare mutex asprivate But in most cases this would needlessly preclude extensibility Since any plausiblesubclass would also need to access the lock declaring mutex as private is nearly equivalent todeclaring the class itself as final Method adaptersBetter structure and discipline surrounding locks can be arranged via any of the before after patternsdiscussed in For example the use of method adapters supports definition of generic wrappersthat can run any code within any lock A wrapper can be defined either as method of a class usinglocking or as a separate utility class An example of the latter is class WithMutex private final Mutex mutex public WithMutex Mutex m mutex m public void perform Runnable r throws InterruptedException mutex acquire try r run finally mutex release This could be used by classes that separate out bare actions as internal methods invoked withinwrappers by public methods for example class ParticleUsingWrapper Incomplete protected final WithMutex withMutex new WithMutex new Mutex protected void doMove x rng nextInt y rng nextInt public void move try withMutex perform new Runnable public void run doMove catch InterruptedException ie Thread currentThread interrupt This design encounters somewhat greater overhead so it is mainly applicable in classes protectingrelatively time consuming actions Also the illustrated version applies only to internal actions that canbe expressed as argumentless resultless Runnables So for example it cannot be used with thedraw method However this scheme can be extended by defining additional method adapters thataccept other arguments and or return results as described in Back offsThe attempt method is useful for recovery from deadlocks and other liveness problems involvingmultiple locks When you cannot ensure that lockups are impossible as is the case for at least somecomponents in most open systems you can routinely use attempt instead of acquire providing a heuristic time out value for example a few seconds to indicate possible lockups andthen take evasive action upon failure see The attempt method can also be used in more specialized constructions to deal with particulardeadlock prone constructions For example here is another version of the Cell class from that backs out and retries upon discovering a potential deadlock As a heuristic it includes a shortdelay between retries Because it relies on retries it can livelock This may be acceptable if you canconvince yourself that the probability of infinite livelock is say less than the probability of a randomhardware failure Note that alias checking is needed here and in all similar constructions involving non reentrant locksto avoid lockups while trying to re acquire a lock that is already held see class CellUsingBackoff private long value private final Mutex mutex new Mutex void swapValue CellUsingBackoff other if this other return alias check required herefor try mutex acquire try if other mutex attempt try long t value value other value other value t return finally other mutex release finally mutex release Thread sleep catch InterruptedException ie Thread currentThread interrupt return ReorderingsBack off techniques may be used as safeguards in designs employing lock ordering techniques see and in which there are relatively rare exceptions to a given locking hierarchy In thesecases code requiring multiple locks can try one ordering and if it fails release all locks and try adifferent ordering This strategy can extend the range of applicability of containment based lockingschemes You do not need to be absolutely certain that all locking maintains the desired ordering ifyou can arrange a somewhat more expensive fallback strategy to deal with exceptional cases Thismight occur for example in hierarchical containment designs employing callbacks or collectiontraversals in which it is not possible to ensure conformance to a given set of lock ordering rules To illustrate basic techniques here is a Cell class that employs such a deadlock avoidance shufflefor swapValue Upon getting stuck it attempts to lock the two objects from the opposite direction class CellUsingReorderedBackoff private long value private final Mutex mutex new Mutex private static boolean trySwap CellUsingReorderedBackoff a CellUsingReorderedBackoff b throws InterruptedException boolean success false if a mutex attempt try if b mutex attempt try long t a value a value b value b value t success true finally b mutex release finally a mutex release return success void swapValue CellUsingReorderedBackoff other if this other return alias check required heretry while trySwap this other trySwap other this Thread sleep catch InterruptedException ex Thread currentThread interrupt Non block structured lockingA Mutex may be used in constructions that cannot be expressed using synchronized blocksbecause the acquire release pairs do not occur in the same method or code block For example you can use a Mutex for hand over hand locking also known as lock coupling acrossthe nodes of a linked list during traversal Here the lock for the next node must be obtained while thelock for the current node is still being held But after acquiring the next lock the current lock may bereleased Hand over hand traversal allows extremely fine grained locking and thus increases potentialconcurrency but at the cost of additional complexity and overhead that would normally be worthwhileonly in cases of extreme contention class ListUsingMutex static class Node Object item Node next Mutex lock new Mutex each node keeps its own lockNode Object x Node n item x next n protected Node head pointer to first node of list Use plain synchronization to protect head field We could instead use a Mutex here too but there is no reason to do so protected synchronized Node getHead return head public synchronized void add Object x simple prepend for simplicity here do not allow null elementsif x null throw new IllegalArgumentException The use of synchronized here protects only head field The method does not need to wait out other traversers that have already made it past head node head new Node x head boolean search Object x throws InterruptedException Node p getHead if p null x null return false p lock acquire Prime loop by acquiring first lock If above acquire fails due to interrupt the method will throw InterruptedException now so there is no need for further cleanup for Node nextp null boolean found try found x equals p item if found nextp p next if nextp null try Acquire next lock while still holding currentnextp lock acquire catch InterruptedException ie throw ie Note that finally clause will execute before the throw finally release old lock regardless of outcomep lock release if found return true else if nextp null return false else p nextp other similar traversal and update methods Another application of Mutex that exploits the lack of required block structuring is the constructionof condition variable objects discussed in Lock Ordering ManagersWhen multiple locks must be obtained in some particular order for example in the hierarchicalcontainment schemes discussed in and the general resource ordering techniques discussed in you can help ensure conformance by centralizing the ordering methods in a lock manager class There are numerous techniques for structuring the kinds of locks used defining their ordering rules and establishing the responsibilities of the manager class However nearly any design containsmethods of the following form which illustrates the care required to ensure that locks will be releasedno matter what exceptions occur class LockManager Code sketch protected void sortLocks Sync locks public void runWithinLocks Runnable op Sync locks throws InterruptedException sortLocks locks for help in recovering from exceptionsint lastlocked InterruptedException caught null try for int i i locks length i locks i acquire lastLocked i op run catch InterruptedException ie caught ie finally for int j lastlocked j j locks j release if caught null throw caught Read Write LocksReadWriteLocks maintain a pair of associated locks One way to define them is interface ReadWriteLock Sync readLock Sync writelock The locks returned by the two methods here obey the same Sync interface as Mutex see supporting methods acquire release and attempt As discussed in there are a number of ways to implement this interface depending onselection of the desired policies surrounding their use For the sake of illustration we will assumedefinition of a generic implementation class RWLock The idea behind read write locks is that the readLock may be held simultaneously by multiplereader threads so long as there are no writers The writeLock is exclusive Read Write locks aregenerally preferable to plain locks when The methods in a class can be cleanly separated into those that only access read internallyheld data and those that modify write Reading is not permitted while writing methods are in progress If reads are permitted duringwrites you may instead rely on unsynchronized read methods or copy on write updates see Target applications generally have more readers than writers The methods are relatively time consuming so it pays to introduce a bit more overheadassociated with read write locks compared to simpler techniques in order to allowconcurrency among reader threads Read write locks are often used in classes that provide access to large collections of data wheremethods are structured as class DataRepository Code sketchprotected final ReadWriteLock rw new RWLock public void access throws InterruptedException rw readLock acquire try read data finally rw readLock release public void modify throws InterruptedException rw writeLock acquire try write data finally rw writeLock release Read write locks can be useful in some applications of ordinary collection classes Theutil concurrent package available from the online supplement contains a set of adapterclasses that can be used with java util Collection classes placing read locks aroundpurely inspective methods such as contains and write locks around update methods such asadd Further ReadingsA set of patterns for using different styles of locks can be found in McKenney Paul Selecting Locking Primitives for Parallel Programming Communications of theACM Chapter State DependenceTwo kinds of enabling conditions are generally needed to perform any action External An object receives a message requesting that an action be performed Internal The object is in an appropriate state to perform the action As a non programming example suppose you are asked to write down a telephone message To dothis you need to have a pencil and paper or some other recording device Exclusion techniques are mainly concerned with maintaining invariants State dependent concurrencycontrol imposes additional concerns surrounding preconditions and postconditions Actions may havestate based preconditions that need not always hold when clients invoke methods on the host object Conversely actions may have postconditions that are unattainable when the host object is not in aproper state when the actions of other objects it relies on fail to achieve their own postconditions orwhen the actions of other threads have changed the states of other objects being relied on Most design issues for classes with state dependent actions revolve around the considerationsnecessary to complete a design so that you take into account all possible combinations of messagesand states as in phone ringtake messagehave pencilanswer phonewrite messagedo not have pencilanswer phone As hinted in the table designs usually need to take into account situations in which the object is not ina state that permits any normal action In an ideal system all methods would have no state basedpreconditions and would always fulfill their postconditions When sensible classes and methodsshould be written in this fashion thus avoiding nearly all the issues discussed in this chapter Butmany activities are intrinsically state dependent and just cannot be programmed to achievepostconditions in all states There are two general approaches to the design and implementation of any state dependent action thatstem from liveness first versus safety first design perspectives Optimistic try and see methods can always be tried when invoked but do not always succeed andthus may have to deal with failure Conservative check and act methods refuse to proceed unless preconditions hold When preconditionsdo hold the actions always succeed If methods check neither their preconditions nor their postconditions they can be called only incontexts in which the preconditions are somehow known to hold Reliance on such practices inconcurrent systems is problematic at best Optimistic and conservative approaches are about equally prevalent and appropriate forms of themmay be equally good or bad with respect to various design forces But since their general forms aregoverned by issues that may be outside of your control the two are not always interchangeable Optimistic approaches rely on the existence of exceptions and related mechanism that indicate whenpostconditions do not hold Conservative approaches rely on the availability of guard constructionsthat indicate when preconditions hold and guarantee that they continue to hold across the course of anaction relying on them Mixtures are of course possible and are in fact common In particular manyconservative designs contain code that may encounter exceptions and thus must be prepared to dealwith failure Concurrency control measures that deal with state dependent actions can require significant effort andattention in concurrent programming This chapter divides coverage as follows discusses exceptions and cancellation introduces the guard constructions used in conservative designs along with themechanics used to implement them presents structural patterns for classes employing concurrency control shows how utility classes can reduce complexity while improving reliability performance and flexibility extends problems and solutions to deal with joint actions those depending on thestates of multiple participants provides a brief overview of transactional concurrency control concludes with some techniques seen in the construction of concurrency control utilityclasses Dealing with FailurePure optimistic control designs originate from optimistic update and transaction protocols Butoptimistic approaches of some sort are seen in just about any code making calls to methods that mayencounter failures Try and see designs attempt actions without first ensuring that they will succeed often because the constraints that would ensure success cannot be checked However optimisticmethods always check postconditions often by catching failure exceptions and if they fail to hold apply a chosen failure policy The need for try and see approaches usually stems from inability or unwillingness to checkpreconditions and related constraints This can arise in the following ways Some conditions cannot be computed using the constructs available in a given language orexecution context For example it is not possible to check whether a given lock is being heldor a given reference is unique see In concurrent programs preconditions may have temporal scopes in which case they aresometimes called activation constraints If a constraint is not under the control of the hostobject then even if it is known to hold momentarily it need not hold throughout the course ofan action relying on it For example your pencil may break while you are writing a message A file system that is known at entry to a method to have enough space to write a file may runout of space due to the actions of other independent programs before the method finisheswriting the file Similarly the fact that a given remote machine is currently available saysnothing about whether it will crash or become unreachable in the course of a method relyingon it Some conditions change due to the signaling actions of other threads The most commonexample is cancellation status which may asynchronously become true while any thread isperforming any action see Some constraints are too computationally expensive to check for example a requirement thata matrix be normalized in upper triangular form When actions are simple and easy to undo orthe chances of failure are extremely low it might not be worth computing even simplepreconditions instead relying on fallback strategies upon later detection of failure In all these cases the lack of provisions that would ensure success forces methods to detect and dealwith potential failures to achieve postconditions ExceptionsAccommodations for failure infiltrate the design of multithreaded programs Concurrency introducesthe possibility that one part of a program will fail while others continue But without care a failingaction may leave objects in states such that other threads cannot succeed Methods may throw exceptions as well as set status indicators or issue notifications when they havedetected that their intended effects or postconditions cannot be attained There are six generalresponses to such failed actions abrupt termination continuation ignoring failures rollback roll forward retry and delegation to handlers Abrupt termination and continuation are the two mostextreme responses Rollback and roll forward are intermediate options that ensure that objectsmaintain consistent states Retries locally contain failure points Delegation allows cooperativeresponses to failure across objects and activities Choices among these options must be agreed upon and advertised It is sometimes possible to supportmultiple policies and let client code decide which one to use for example via dialogs asking userswhether to retry reading from a disk Additional examples of these options are illustrated throughoutthis book Abrupt terminationAn extreme response to failure is to let a method die immediately returning usually via an exception regardless of the state of the current object or status of the current activity This may apply if you arecertain that local failure forces failure of the entire activity and that the objects engaged in the activitywill never be used again for example if they are completely confined within a session see For example this might be the case in a file conversion component that fails to open the file to beconverted Abrupt termination is also the default strategy for uncaught and undeclared RuntimeExceptions such as NullPointerException that most often indicateprogramming errors When a normally recoverable failure cannot be dealt with you can force moreextreme responses by escalating it to a throw of a RuntimeException or Error Short of full program termination via System exit options for further recovery from sucherrors are often very limited When objects are intrinsically shared across activities and there is noway to re establish consistent object states upon failure and there is no possible or practical way toback out of a failing operation then the only recourse is to set a broken or corrupted flag inthe object encountering the failure and then abruptly terminate Such a flag should cause all futureoperations to fail until the object is somehow repaired perhaps via the actions of an error handlerobject ContinuationIf a failed invocation has no bearing on either the state of the caller object or the overall functionalityrequirements of the current activity then it may be acceptable just to ignore the exception andcontinue forward While it is ordinarily too irresponsible to contemplate this option may apply inevent frameworks and oneway messaging protocols see For example a failed invocation of achange notification method on a listener object might at worst cause some parts of an animationsequence to be skipped without any other long term consequences Continuation policies are also seen within other error handlers and inside most finally clauses that ignore other incidental exceptions occurring while they are trying to deal with the failure thattriggered them for example ignoring exceptions while closing files They may also be used in threadsthat should never shut down and thus try their best to continue in the face of exceptions RollbackThe most desirable semantics in optimistic designs are clean fail guarantees Either the operationsucceeds completely or it fails in a way that leaves the object in exactly the same state as before theoperation was attempted The optimistic update techniques in demonstrate one form of thisapproach in which the success criterion is lack of interference by other threads trying to performupdates There are two complementary styles for maintaining state representations that can be used inrollbacks Provisional action Before attempting updates construct a new representation that will upon success be swapped in as the current state Methods perform updates on the tentative new version of the staterepresentations but do not commit to the new version until success is assured This way nothingneeds to be undone upon failure Checkpointing Before attempting updates record the current state of the object in a history variable perhaps in the form of a Memento see the Design Patterns book Methods directly perform updateson the current representation But upon failure fields can be reverted to the old values Provisional action is usually necessary when actions are not otherwise fully synchronized Provisionalaction eliminates the possibility that other threads will see inconsistent partially updatedrepresentations It is also more efficient when reads are much more common than writes Checkpointing is usually simpler to arrange and is thus often preferable in other situations In eitherapproach it is not always necessary to create new representation objects to record state often a fewextra fields in the object or local variables inside the methods suffice Situation specific rollback techniques are needed for actions other than state updates that must beundone upon failure including actions resulting from sending other messages Every message sentwithin such a method should have an inverse antimessage For example a credit operation mightbe undone via debit This idea can be extended to maintaining undo lists associated with sequencesof actions in order to allow rollback to any given point Some kinds of operations can neither be provisionally attempted nor undone via antimessages andthus cannot employ rollback techniques This rules out methods with externally visible effects thatirrevocably change the real world by performing IO or actuating physical devices unless it is possibleto undo the actions without harm In the case of IO conventions can be adopted to allow theconceptual equivalent of rollback For example if methods log actions in a log file and the log filesupports a please disregard log entry XYZ option then this can be invoked in case of failure However as discussed further in rollback of most IO objects such as InputStreams themselves is typically not possible There are no control methods to revert the internal buffers orother fields of most IO objects back to the values they held at some arbitrary point Typically the bestyou can do is close the IO objects and construct new ones bound to the same files devices or networkconnections Roll forwardWhen rollback is impossible or undesirable but full continuation is also impossible you may insteadpush ahead as conservatively as possible to re establish some guaranteed legal consistent state thatmay be different from the one holding upon entry to the method Roll forward sometimes knownsimply as recovery is often perfectly acceptable as far as other objects methods and threads areconcerned in many cases they cannot even distinguish it from rollback Some such actions may be placed in finally clauses that perform minimal cleanup for exampleclosing files cancelling other activities necessary to reach safe points of program execution Mostroll forward techniques otherwise take forms similar to rollback techniques But because they do notrequire full representations of saved or provisional state they are usually slightly easier to arrange Some methods can be divided into two conceptual parts a preliminary part that can roll back easily for example by either returning or rethrowing the exception immediately and the part occurringafter a point of no return at which some unrecoverable action has already begun that must beadvanced to a safe point even upon failure For example a method may reach a point in a protocol atwhich an acknowledgment must be sent or received see RetryYou can contain local failure to the current method rather than throwing exceptions back to clients ifyou have reason to believe that retrying an action will succeed Retries are in general only possiblewhen local rollback options can be applied so that the state of the object and status of the activityremain the same at the beginning of each retry attempt Retry based tactics may be used when failure is due to other independent objects that may have beenin temporarily bad or undesired states for example when dealing with IO devices and remotemachines As seen in optimistic state update methods also typically rely on retries sinceinterference patterns are extremely unlikely to persist indefinitely Retries are also common in pollingdesigns for example those discussed in Variants of retries are seen in cascading algorithmsthat first try the most desirable of several alternative actions and if that fails try a series of lessdesirable alternatives until one succeeds Without care retries can consume unbounded amounts of CPU time see You can minimizethe likelihood of repeated contention based failures as well as reduce CPU wastage by insertingheuristic delays between attempts One popular strategy seen for example in Ethernet protocols isexponential backoff in which each delay is proportionally longer than the last one For example you could use the following method to connect to a server that sometimes refusesconnections because it is overloaded The retry loop backs off for a longer time after each failure However it fails upon thread interruption see since there is no point in continuing if thecurrent thread has been cancelled As noted in on some releases of JDK you may need tomodify this to catch InterruptedIOException and rethrowInterrruptedException class ClientUsingSocket Code sketch Socket retryUntilConnected throws InterruptedException first delay is randomly chosen between and secslong delayTime long Math random for try return new Socket server portnumber catch IOException ex Thread sleep delayTime delayTime delayTime increase HandlersCalls callbacks or notifications to error handling objects can be useful when you need to offloaderror processing operations to centralized handlers because an exception in one thread or one part of asystem requires compensating actions in other threads or other parts of a system that wouldn totherwise be known to the method catching the exception They can also be used to make code moreextensible and more resilient when used by clients that cannot be expected to know how to respond tofailures However some care is needed when replacing exceptions with callbacks events and relatednotification techniques When they escape the stack based flow of control rules of exceptions theiruse can make it more difficult to predict and manage
